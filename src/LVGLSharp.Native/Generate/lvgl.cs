// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace lvgl
{
    public unsafe partial class lv_init
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDeinit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_is_initialized", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvIsInitialized();
        }

        /// <summary>
        /// <para>Initialize LVGL library.</para>
        /// <para>Should be called before any other LVGL related function.</para>
        /// </summary>
        public static void LvInit()
        {
            __Internal.LvInit();
        }

        /// <summary>Deinit the 'lv' library</summary>
        public static void LvDeinit()
        {
            __Internal.LvDeinit();
        }

        /// <summary>Returns whether the 'lv' library is currently initialized</summary>
        public static bool LvIsInitialized()
        {
            var ___ret = __Internal.LvIsInitialized();
            return ___ret;
        }
    }

    /// <summary>LVGL error codes.</summary>
    public enum LvResultT
    {
        LV_RESULT_INVALID = 0,
        LV_RESULT_OK = 1
    }

    public unsafe partial class LvDisplayT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDisplayT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDisplayT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDisplayT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDisplayT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDisplayT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDisplayT(native.ToPointer(), skipVTables);
        }

        internal static LvDisplayT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDisplayT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDisplayT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDisplayT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDisplayT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDisplayT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class LvIndevT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvIndevT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvIndevT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvIndevT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvIndevT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvIndevT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvIndevT(native.ToPointer(), skipVTables);
        }

        internal static LvIndevT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvIndevT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvIndevT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvIndevT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvIndevT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvIndevT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>Heap information structure.</summary>
    /// <summary>Heap information structure.</summary>
    public unsafe partial class LvMemMonitorT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal ulong total_size;
            internal ulong free_cnt;
            internal ulong free_size;
            internal ulong free_biggest_size;
            internal ulong used_cnt;
            internal ulong max_used;
            internal byte used_pct;
            internal byte frag_pct;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_mem_monitor_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvMemMonitorT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvMemMonitorT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvMemMonitorT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvMemMonitorT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvMemMonitorT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvMemMonitorT(native.ToPointer(), skipVTables);
        }

        internal static LvMemMonitorT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvMemMonitorT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvMemMonitorT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvMemMonitorT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvMemMonitorT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvMemMonitorT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvMemMonitorT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvMemMonitorT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvMemMonitorT(global::lvgl.LvMemMonitorT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvMemMonitorT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvMemMonitorT.__Internal*) __Instance) = *((global::lvgl.LvMemMonitorT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Total heap size</summary>
        public ulong TotalSize
        {
            get
            {
                return ((__Internal*)__Instance)->total_size;
            }

            set
            {
                ((__Internal*)__Instance)->total_size = value;
            }
        }

        public ulong FreeCnt
        {
            get
            {
                return ((__Internal*)__Instance)->free_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->free_cnt = value;
            }
        }

        /// <summary>Size of available memory</summary>
        public ulong FreeSize
        {
            get
            {
                return ((__Internal*)__Instance)->free_size;
            }

            set
            {
                ((__Internal*)__Instance)->free_size = value;
            }
        }

        public ulong FreeBiggestSize
        {
            get
            {
                return ((__Internal*)__Instance)->free_biggest_size;
            }

            set
            {
                ((__Internal*)__Instance)->free_biggest_size = value;
            }
        }

        public ulong UsedCnt
        {
            get
            {
                return ((__Internal*)__Instance)->used_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->used_cnt = value;
            }
        }

        /// <summary>Max size of Heap memory used</summary>
        public ulong MaxUsed
        {
            get
            {
                return ((__Internal*)__Instance)->max_used;
            }

            set
            {
                ((__Internal*)__Instance)->max_used = value;
            }
        }

        /// <summary>Percentage used</summary>
        public byte UsedPct
        {
            get
            {
                return ((__Internal*)__Instance)->used_pct;
            }

            set
            {
                ((__Internal*)__Instance)->used_pct = value;
            }
        }

        /// <summary>Amount of fragmentation</summary>
        public byte FragPct
        {
            get
            {
                return ((__Internal*)__Instance)->frag_pct;
            }

            set
            {
                ((__Internal*)__Instance)->frag_pct = value;
            }
        }
    }

    public unsafe partial class lv_mem
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_mem_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvMemInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_mem_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvMemDeinit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_mem_add_pool", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMemAddPool(__IntPtr mem, ulong bytes);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_mem_remove_pool", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvMemRemovePool(__IntPtr pool);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_malloc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMalloc(ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_malloc_zeroed", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMallocZeroed(ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_free", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvFree(__IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_realloc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvRealloc(__IntPtr data_p, ulong new_size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_malloc_core", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMallocCore(ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_free_core", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvFreeCore(__IntPtr p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_realloc_core", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvReallocCore(__IntPtr p, ulong new_size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_mem_monitor_core", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvMemMonitorCore(__IntPtr mon_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_mem_test_core", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvMemTestCore();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_mem_test", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvMemTest();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_mem_monitor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvMemMonitor(__IntPtr mon_p);
        }

        /// <summary>Initialize to use malloc/free/realloc etc</summary>
        public static void LvMemInit()
        {
            __Internal.LvMemInit();
        }

        /// <summary>Drop all dynamically allocated memory and reset the memory pools' state</summary>
        public static void LvMemDeinit()
        {
            __Internal.LvMemDeinit();
        }

        public static __IntPtr LvMemAddPool(__IntPtr mem, ulong bytes)
        {
            var ___ret = __Internal.LvMemAddPool(mem, bytes);
            return ___ret;
        }

        public static void LvMemRemovePool(__IntPtr pool)
        {
            __Internal.LvMemRemovePool(pool);
        }

        /// <summary>Allocate memory dynamically</summary>
        /// <param name="size">requested size in bytes</param>
        /// <returns>pointer to allocated uninitialized memory, or NULL on failure</returns>
        public static __IntPtr LvMalloc(ulong size)
        {
            var ___ret = __Internal.LvMalloc(size);
            return ___ret;
        }

        /// <summary>Allocate zeroed memory dynamically</summary>
        /// <param name="size">requested size in bytes</param>
        /// <returns>pointer to allocated zeroed memory, or NULL on failure</returns>
        public static __IntPtr LvMallocZeroed(ulong size)
        {
            var ___ret = __Internal.LvMallocZeroed(size);
            return ___ret;
        }

        /// <summary>Free an allocated data</summary>
        /// <param name="data">pointer to an allocated memory</param>
        public static void LvFree(__IntPtr data)
        {
            __Internal.LvFree(data);
        }

        /// <summary>Reallocate a memory with a new size. The old content will be kept.</summary>
        /// <param name="data_p">
        /// <para>pointer to an allocated memory.</para>
        /// <para>Its content will be copied to the new memory block and freed</para>
        /// </param>
        /// <param name="new_size">the desired new size in byte</param>
        /// <returns>pointer to the new memory, NULL on failure</returns>
        public static __IntPtr LvRealloc(__IntPtr data_p, ulong new_size)
        {
            var ___ret = __Internal.LvRealloc(data_p, new_size);
            return ___ret;
        }

        /// <summary>Used internally to execute a plain `malloc` operation</summary>
        /// <param name="size">size in bytes to `malloc`</param>
        public static __IntPtr LvMallocCore(ulong size)
        {
            var ___ret = __Internal.LvMallocCore(size);
            return ___ret;
        }

        /// <summary>Used internally to execute a plain `free` operation</summary>
        /// <param name="p">memory address to free</param>
        public static void LvFreeCore(__IntPtr p)
        {
            __Internal.LvFreeCore(p);
        }

        /// <summary>Used internally to execute a plain realloc operation</summary>
        /// <param name="p">memory address to realloc</param>
        /// <param name="new_size">size in bytes to realloc</param>
        public static __IntPtr LvReallocCore(__IntPtr p, ulong new_size)
        {
            var ___ret = __Internal.LvReallocCore(p, new_size);
            return ___ret;
        }

        /// <summary>Used internally to execute a plain malloc operation</summary>
        /// <param name="size">size in bytes to malloc</param>
        public static void LvMemMonitorCore(global::lvgl.LvMemMonitorT mon_p)
        {
            var __arg0 = mon_p is null ? __IntPtr.Zero : mon_p.__Instance;
            __Internal.LvMemMonitorCore(__arg0);
        }

        public static byte LvMemTestCore()
        {
            var ___ret = __Internal.LvMemTestCore();
            return ___ret;
        }

        /// <summary>Tests the memory allocation system by allocating and freeing a block of memory.</summary>
        /// <returns>LV_RESULT_OK if the memory allocation system is working properly, or LV_RESULT_INVALID if there is an error.</returns>
        public static byte LvMemTest()
        {
            var ___ret = __Internal.LvMemTest();
            return ___ret;
        }

        /// <summary>Give information about the work memory of dynamic allocation</summary>
        /// <param name="mon_p">
        /// <para>pointer to a lv_mem_monitor_t variable,</para>
        /// <para>the result of the analysis will be stored here</para>
        /// </param>
        public static void LvMemMonitor(global::lvgl.LvMemMonitorT mon_p)
        {
            var __arg0 = mon_p is null ? __IntPtr.Zero : mon_p.__Instance;
            __Internal.LvMemMonitor(__arg0);
        }
    }

    public unsafe partial class lv_string
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_memcpy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMemcpy(__IntPtr dst, __IntPtr src, ulong len);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_memset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvMemset(__IntPtr dst, byte v, ulong len);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_memmove", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMemmove(__IntPtr dst, __IntPtr src, ulong len);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_memcmp", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvMemcmp(__IntPtr p1, __IntPtr p2, ulong len);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_strlen", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong LvStrlen([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_strncpy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* LvStrncpy(sbyte* dst, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string src, ulong dest_size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_strcpy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* LvStrcpy(sbyte* dst, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string src);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_strcmp", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvStrcmp([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string s1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string s2);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_strdup", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* LvStrdup([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string src);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_strcat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* LvStrcat(sbyte* dst, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string src);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_strncat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* LvStrncat(sbyte* dst, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string src, ulong src_len);
        }

        /// <summary>Copies a block of memory from a source address to a destination address.</summary>
        /// <param name="dst">Pointer to the destination array where the content is to be copied.</param>
        /// <param name="src">Pointer to the source of data to be copied.</param>
        /// <param name="len">Number of bytes to copy.</param>
        /// <returns>Pointer to the destination array.</returns>
        /// <remarks>The function does not check for any overlapping of the source and destination memory blocks.</remarks>
        public static __IntPtr LvMemcpy(__IntPtr dst, __IntPtr src, ulong len)
        {
            var ___ret = __Internal.LvMemcpy(dst, src, len);
            return ___ret;
        }

        /// <summary>Fills a block of memory with a specified value.</summary>
        /// <param name="dst">Pointer to the destination array to fill with the specified value.</param>
        /// <param name="v">
        /// <para>Value to be set. The value is passed as an int, but the function fills</para>
        /// <para>the block of memory using the unsigned char conversion of this value.</para>
        /// </param>
        /// <param name="len">Number of bytes to be set to the value.</param>
        public static void LvMemset(__IntPtr dst, byte v, ulong len)
        {
            __Internal.LvMemset(dst, v, len);
        }

        /// <summary>Move a block of memory from source to destination</summary>
        /// <param name="dst">Pointer to the destination array where the content is to be copied.</param>
        /// <param name="src">Pointer to the source of data to be copied.</param>
        /// <param name="len">Number of bytes to copy</param>
        /// <returns>Pointer to the destination array.</returns>
        public static __IntPtr LvMemmove(__IntPtr dst, __IntPtr src, ulong len)
        {
            var ___ret = __Internal.LvMemmove(dst, src, len);
            return ___ret;
        }

        /// <summary>This function will compare two memory blocks</summary>
        /// <param name="p1">Pointer to the first memory block</param>
        /// <param name="p2">Pointer to the second memory block</param>
        /// <param name="len">Number of bytes to compare</param>
        /// <returns>The difference between the value of the first unmatching byte.</returns>
        public static int LvMemcmp(__IntPtr p1, __IntPtr p2, ulong len)
        {
            var ___ret = __Internal.LvMemcmp(p1, p2, len);
            return ___ret;
        }

        /// <summary>Computes the length of the string str up to, but not including the terminating null character.</summary>
        /// <param name="str">Pointer to the null-terminated byte string to be examined.</param>
        /// <returns>The length of the string in bytes.</returns>
        public static ulong LvStrlen(string str)
        {
            var ___ret = __Internal.LvStrlen(str);
            return ___ret;
        }

        /// <summary>Copies up to dest_size characters from the string pointed to by src to the character array pointed to by dst.</summary>
        /// <param name="dst">Pointer to the destination array where the content is to be copied.</param>
        /// <param name="src">Pointer to the source of data to be copied.</param>
        /// <param name="dest_size">Maximum number of characters to be copied to dst, including the null character.</param>
        /// <returns>A pointer to the destination array, which is dst.</returns>
        public static sbyte* LvStrncpy(sbyte* dst, string src, ulong dest_size)
        {
            var ___ret = __Internal.LvStrncpy(dst, src, dest_size);
            return ___ret;
        }

        /// <summary>
        /// <para>Copies the string pointed to by src, including the terminating null character,</para>
        /// <para>to the character array pointed to by dst.</para>
        /// </summary>
        /// <param name="dst">Pointer to the destination array where the content is to be copied.</param>
        /// <param name="src">Pointer to the source of data to be copied.</param>
        /// <returns>A pointer to the destination array, which is dst.</returns>
        public static sbyte* LvStrcpy(sbyte* dst, string src)
        {
            var ___ret = __Internal.LvStrcpy(dst, src);
            return ___ret;
        }

        /// <summary>This function will compare two strings without specified length.</summary>
        /// <param name="s1">pointer to the first string</param>
        /// <param name="s2">pointer to the second string</param>
        /// <returns>the difference between the value of the first unmatching character.</returns>
        public static int LvStrcmp(string s1, string s2)
        {
            var ___ret = __Internal.LvStrcmp(s1, s2);
            return ___ret;
        }

        /// <summary>Duplicate a string by allocating a new one and copying the content.</summary>
        /// <param name="src">Pointer to the source of data to be copied.</param>
        /// <returns>A pointer to the new allocated string. NULL if failed.</returns>
        public static sbyte* LvStrdup(string src)
        {
            var ___ret = __Internal.LvStrdup(src);
            return ___ret;
        }

        /// <summary>
        /// <para>Copies the string pointed to by src, including the terminating null character,</para>
        /// <para>to the end of the string pointed to by dst.</para>
        /// </summary>
        /// <param name="dst">Pointer to the destination string where the content is to be appended.</param>
        /// <param name="src">Pointer to the source of data to be copied.</param>
        /// <returns>A pointer to the destination string, which is dst.</returns>
        public static sbyte* LvStrcat(sbyte* dst, string src)
        {
            var ___ret = __Internal.LvStrcat(dst, src);
            return ___ret;
        }

        /// <summary>
        /// <para>Copies up to src_len characters from the string pointed to by src</para>
        /// <para>to the end of the string pointed to by dst.</para>
        /// <para>A terminating null character is appended to dst even if no null character</para>
        /// <para>was encountered in src after src_len characters were copied.</para>
        /// </summary>
        /// <param name="dst">Pointer to the destination string where the content is to be appended.</param>
        /// <param name="src">Pointer to the source of data to be copied.</param>
        /// <param name="src_len">Maximum number of characters from src to be copied to the end of dst.</param>
        /// <returns>A pointer to the destination string, which is dst.</returns>
        public static sbyte* LvStrncat(sbyte* dst, string src, ulong src_len)
        {
            var ___ret = __Internal.LvStrncat(dst, src, src_len);
            return ___ret;
        }
    }

    public unsafe partial class lv_sprintf
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_snprintf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvSnprintf(sbyte* buffer, ulong count, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format);
        }

        public static int LvSnprintf(sbyte* buffer, ulong count, string format)
        {
            var ___ret = __Internal.LvSnprintf(buffer, count, format);
            return ___ret;
        }
    }

    /// <summary>Log print function. Receives a string buffer to print&quot;.</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvLogPrintGCbT(sbyte level, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string buf);

    public unsafe partial class lv_log
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_log_register_print_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLogRegisterPrintCb(__IntPtr print_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_log", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLog([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_log_add", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLogAdd(sbyte level, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string func, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format);
        }

        /// <summary>
        /// <para>Register custom print/write function to call when a log is added.</para>
        /// <para>It can format its &quot;File path&quot;, &quot;Line number&quot; and &quot;Description&quot; as required</para>
        /// <para>and send the formatted log message to a console or serial port.</para>
        /// </summary>
        /// <param name="print_cb">a function pointer to print a log</param>
        public static void LvLogRegisterPrintCb(global::lvgl.LvLogPrintGCbT print_cb)
        {
            var __arg0 = print_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(print_cb);
            __Internal.LvLogRegisterPrintCb(__arg0);
        }

        /// <summary>
        /// <para>Print a log message via `printf` if enabled with `LV_LOG_PRINTF` in `lv_conf.h`</para>
        /// <para>and/or a print callback if registered with `lv_log_register_print_cb`</para>
        /// </summary>
        /// <param name="format">printf-like format string</param>
        /// <param name="...">parameters for `format`</param>
        public static void LvLog(string format)
        {
            __Internal.LvLog(format);
        }

        /// <summary>Add a log</summary>
        /// <param name="level">the level of log. (From `lv_log_level_t` enum)</param>
        /// <param name="file">name of the file when the log added</param>
        /// <param name="line">line number in the source code where the log added</param>
        /// <param name="func">name of the function when the log added</param>
        /// <param name="format">printf-like format string</param>
        /// <param name="...">parameters for `format`</param>
        public static void LvLogAdd(sbyte level, string file, int line, string func, string format)
        {
            __Internal.LvLogAdd(level, file, line, func, format);
        }
    }

    /// <summary>Timers execute this type of functions.</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvTimerCbT(__IntPtr __0);

    /// <summary>Timer handler resume this type of function.</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvTimerHandlerResumeCbT(__IntPtr data);

    /// <summary>Descriptor of a lv_timer</summary>
    public unsafe partial class LvTimerT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint period;

            [FieldOffset(4)]
            internal uint last_run;

            [FieldOffset(8)]
            internal __IntPtr timer_cb;

            [FieldOffset(16)]
            internal __IntPtr user_data;

            [FieldOffset(24)]
            internal int repeat_count;

            [FieldOffset(28)]
            internal uint paused;

            [FieldOffset(28)]
            internal uint auto_delete;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_timer_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTimerT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTimerT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvTimerT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvTimerT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvTimerT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvTimerT(native.ToPointer(), skipVTables);
        }

        internal static LvTimerT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvTimerT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvTimerT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvTimerT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvTimerT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvTimerT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvTimerT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTimerT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvTimerT(global::lvgl.LvTimerT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTimerT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvTimerT.__Internal*) __Instance) = *((global::lvgl.LvTimerT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>How often the timer should run</summary>
        public uint Period
        {
            get
            {
                return ((__Internal*)__Instance)->period;
            }

            set
            {
                ((__Internal*)__Instance)->period = value;
            }
        }

        /// <summary>Last time the timer ran</summary>
        public uint LastRun
        {
            get
            {
                return ((__Internal*)__Instance)->last_run;
            }

            set
            {
                ((__Internal*)__Instance)->last_run = value;
            }
        }

        /// <summary>Timer function</summary>
        public global::lvgl.LvTimerCbT TimerCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->timer_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvTimerCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvTimerCbT));
            }

            set
            {
                ((__Internal*)__Instance)->timer_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Custom user data</summary>
        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }

        /// <summary>1: One time;  -1 : infinity;  n&gt;0: residual times</summary>
        public int RepeatCount
        {
            get
            {
                return ((__Internal*)__Instance)->repeat_count;
            }

            set
            {
                ((__Internal*)__Instance)->repeat_count = value;
            }
        }

        public uint Paused
        {
            get
            {
                return ((__Internal*)__Instance)->paused;
            }

            set
            {
                ((__Internal*)__Instance)->paused = value;
            }
        }

        public uint AutoDelete
        {
            get
            {
                return ((__Internal*)__Instance)->auto_delete;
            }

            set
            {
                ((__Internal*)__Instance)->auto_delete = value;
            }
        }
    }

    public unsafe partial class LvTimerStateT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal global::lvgl.LvLlT.__Internal timer_ll;
            internal byte lv_timer_run;
            internal byte idle_last;
            internal byte timer_deleted;
            internal byte timer_created;
            internal uint timer_time_until_next;
            internal byte already_running;
            internal uint periodic_last_tick;
            internal uint busy_time;
            internal uint idle_period_start;
            internal uint run_cnt;
            internal __IntPtr resume_cb;
            internal __IntPtr resume_data;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_timer_state_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTimerStateT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTimerStateT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvTimerStateT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvTimerStateT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvTimerStateT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvTimerStateT(native.ToPointer(), skipVTables);
        }

        internal static LvTimerStateT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvTimerStateT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvTimerStateT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvTimerStateT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvTimerStateT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvTimerStateT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvTimerStateT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTimerStateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvTimerStateT(global::lvgl.LvTimerStateT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTimerStateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvTimerStateT.__Internal*) __Instance) = *((global::lvgl.LvTimerStateT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvLlT TimerLl
        {
            get
            {
                return global::lvgl.LvLlT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->timer_ll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->timer_ll = *(global::lvgl.LvLlT.__Internal*) value.__Instance;
            }
        }

        public bool LvTimerRun
        {
            get
            {
                return ((__Internal*)__Instance)->lv_timer_run != 0;
            }

            set
            {
                ((__Internal*)__Instance)->lv_timer_run = (byte) (value ? 1 : 0);
            }
        }

        public byte IdleLast
        {
            get
            {
                return ((__Internal*)__Instance)->idle_last;
            }

            set
            {
                ((__Internal*)__Instance)->idle_last = value;
            }
        }

        public bool TimerDeleted
        {
            get
            {
                return ((__Internal*)__Instance)->timer_deleted != 0;
            }

            set
            {
                ((__Internal*)__Instance)->timer_deleted = (byte) (value ? 1 : 0);
            }
        }

        public bool TimerCreated
        {
            get
            {
                return ((__Internal*)__Instance)->timer_created != 0;
            }

            set
            {
                ((__Internal*)__Instance)->timer_created = (byte) (value ? 1 : 0);
            }
        }

        public uint TimerTimeUntilNext
        {
            get
            {
                return ((__Internal*)__Instance)->timer_time_until_next;
            }

            set
            {
                ((__Internal*)__Instance)->timer_time_until_next = value;
            }
        }

        public bool AlreadyRunning
        {
            get
            {
                return ((__Internal*)__Instance)->already_running != 0;
            }

            set
            {
                ((__Internal*)__Instance)->already_running = (byte) (value ? 1 : 0);
            }
        }

        public uint PeriodicLastTick
        {
            get
            {
                return ((__Internal*)__Instance)->periodic_last_tick;
            }

            set
            {
                ((__Internal*)__Instance)->periodic_last_tick = value;
            }
        }

        public uint BusyTime
        {
            get
            {
                return ((__Internal*)__Instance)->busy_time;
            }

            set
            {
                ((__Internal*)__Instance)->busy_time = value;
            }
        }

        public uint IdlePeriodStart
        {
            get
            {
                return ((__Internal*)__Instance)->idle_period_start;
            }

            set
            {
                ((__Internal*)__Instance)->idle_period_start = value;
            }
        }

        public uint RunCnt
        {
            get
            {
                return ((__Internal*)__Instance)->run_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->run_cnt = value;
            }
        }

        public global::lvgl.LvTimerHandlerResumeCbT ResumeCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->resume_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvTimerHandlerResumeCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvTimerHandlerResumeCbT));
            }

            set
            {
                ((__Internal*)__Instance)->resume_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr ResumeData
        {
            get
            {
                return ((__Internal*)__Instance)->resume_data;
            }

            set
            {
                ((__Internal*)__Instance)->resume_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class lv_timer
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_timer_core_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTimerCoreInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_timer_core_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTimerCoreDeinit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_handler", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvTimerHandler();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_periodic_handler", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTimerPeriodicHandler();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_handler_set_resume_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTimerHandlerSetResumeCb(__IntPtr cb, __IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_create_basic", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTimerCreateBasic();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTimerCreate(__IntPtr timer_xcb, uint period, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_delete", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTimerDelete(__IntPtr timer);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_pause", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTimerPause(__IntPtr timer);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_resume", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTimerResume(__IntPtr timer);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_set_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTimerSetCb(__IntPtr timer, __IntPtr timer_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_set_period", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTimerSetPeriod(__IntPtr timer, uint period);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_ready", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTimerReady(__IntPtr timer);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_set_repeat_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTimerSetRepeatCount(__IntPtr timer, int repeat_count);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_set_auto_delete", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTimerSetAutoDelete(__IntPtr timer, bool auto_delete);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_set_user_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTimerSetUserData(__IntPtr timer, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_reset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTimerReset(__IntPtr timer);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_enable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTimerEnable(bool en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_get_idle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvTimerGetIdle();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_get_time_until_next", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvTimerGetTimeUntilNext();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_timer_get_next", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTimerGetNext(__IntPtr timer);
        }

        /// <summary>Init the lv_timer module</summary>
        public static void LvTimerCoreInit()
        {
            __Internal.LvTimerCoreInit();
        }

        /// <summary>Deinit the lv_timer module</summary>
        public static void LvTimerCoreDeinit()
        {
            __Internal.LvTimerCoreDeinit();
        }

        /// <summary>Call it periodically to handle lv_timers.</summary>
        /// <returns>time till it needs to be run next (in ms)</returns>
        public static uint LvTimerHandler()
        {
            var ___ret = __Internal.LvTimerHandler();
            return ___ret;
        }

        /// <summary>
        /// <para>Call it in the super-loop of main() or threads. It will automatically call lv_timer_handler() at the right time.</para>
        /// <para>This function is used to simplify the porting.</para>
        /// </summary>
        public static void LvTimerPeriodicHandler()
        {
            __Internal.LvTimerPeriodicHandler();
        }

        /// <summary>Set the resume callback to the timer handler</summary>
        /// <param name="cb">the function to call when timer handler is resumed</param>
        /// <param name="data">pointer to a resume data</param>
        public static void LvTimerHandlerSetResumeCb(global::lvgl.LvTimerHandlerResumeCbT cb, __IntPtr data)
        {
            var __arg0 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.LvTimerHandlerSetResumeCb(__arg0, data);
        }

        /// <summary>
        /// <para>Create an &quot;empty&quot; timer. It needs to be initialized with at least</para>
        /// <para>`lv_timer_set_cb` and `lv_timer_set_period`</para>
        /// </summary>
        /// <returns>pointer to the created timer</returns>
        public static global::lvgl.LvTimerT LvTimerCreateBasic()
        {
            var ___ret = __Internal.LvTimerCreateBasic();
            var __result0 = global::lvgl.LvTimerT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create a new lv_timer</summary>
        /// <param name="timer_xcb">
        /// <para>a callback to call periodically.</para>
        /// <para>(the 'x' in the argument name indicates that it's not a fully generic function because it not follows</para>
        /// <para>the `func_name(object, callback, ...)` convention)</para>
        /// </param>
        /// <param name="period">call period in ms unit</param>
        /// <param name="user_data">custom parameter</param>
        /// <returns>pointer to the new timer</returns>
        public static global::lvgl.LvTimerT LvTimerCreate(global::lvgl.LvTimerCbT timer_xcb, uint period, __IntPtr user_data)
        {
            var __arg0 = timer_xcb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(timer_xcb);
            var ___ret = __Internal.LvTimerCreate(__arg0, period, user_data);
            var __result0 = global::lvgl.LvTimerT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Delete a lv_timer</summary>
        /// <param name="timer">pointer to an lv_timer</param>
        public static void LvTimerDelete(global::lvgl.LvTimerT timer)
        {
            var __arg0 = timer is null ? __IntPtr.Zero : timer.__Instance;
            __Internal.LvTimerDelete(__arg0);
        }

        /// <summary>Pause a timer.</summary>
        /// <param name="timer">pointer to an lv_timer</param>
        public static void LvTimerPause(global::lvgl.LvTimerT timer)
        {
            var __arg0 = timer is null ? __IntPtr.Zero : timer.__Instance;
            __Internal.LvTimerPause(__arg0);
        }

        /// <summary>Resume a timer.</summary>
        /// <param name="timer">pointer to an lv_timer</param>
        public static void LvTimerResume(global::lvgl.LvTimerT timer)
        {
            var __arg0 = timer is null ? __IntPtr.Zero : timer.__Instance;
            __Internal.LvTimerResume(__arg0);
        }

        /// <summary>Set the callback to the timer (the function to call periodically)</summary>
        /// <param name="timer">pointer to a timer</param>
        /// <param name="timer_cb">the function to call periodically</param>
        public static void LvTimerSetCb(global::lvgl.LvTimerT timer, global::lvgl.LvTimerCbT timer_cb)
        {
            var __arg0 = timer is null ? __IntPtr.Zero : timer.__Instance;
            var __arg1 = timer_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(timer_cb);
            __Internal.LvTimerSetCb(__arg0, __arg1);
        }

        /// <summary>Set new period for a lv_timer</summary>
        /// <param name="timer">pointer to a lv_timer</param>
        /// <param name="period">the new period</param>
        public static void LvTimerSetPeriod(global::lvgl.LvTimerT timer, uint period)
        {
            var __arg0 = timer is null ? __IntPtr.Zero : timer.__Instance;
            __Internal.LvTimerSetPeriod(__arg0, period);
        }

        /// <summary>Make a lv_timer ready. It will not wait its period.</summary>
        /// <param name="timer">pointer to a lv_timer.</param>
        public static void LvTimerReady(global::lvgl.LvTimerT timer)
        {
            var __arg0 = timer is null ? __IntPtr.Zero : timer.__Instance;
            __Internal.LvTimerReady(__arg0);
        }

        /// <summary>Set the number of times a timer will repeat.</summary>
        /// <param name="timer">pointer to a lv_timer.</param>
        /// <param name="repeat_count">-1 : infinity;  0 : stop ;  n&gt;0: residual times</param>
        public static void LvTimerSetRepeatCount(global::lvgl.LvTimerT timer, int repeat_count)
        {
            var __arg0 = timer is null ? __IntPtr.Zero : timer.__Instance;
            __Internal.LvTimerSetRepeatCount(__arg0, repeat_count);
        }

        /// <summary>Set whether a lv_timer will be deleted automatically when it is called `repeat_count` times.</summary>
        /// <param name="timer">pointer to a lv_timer.</param>
        /// <param name="auto_delete">true: auto delete; false: timer will be paused when it is called `repeat_count` times.</param>
        public static void LvTimerSetAutoDelete(global::lvgl.LvTimerT timer, bool auto_delete)
        {
            var __arg0 = timer is null ? __IntPtr.Zero : timer.__Instance;
            __Internal.LvTimerSetAutoDelete(__arg0, auto_delete);
        }

        /// <summary>Set custom parameter to the lv_timer.</summary>
        /// <param name="timer">pointer to a lv_timer.</param>
        /// <param name="user_data">custom parameter</param>
        public static void LvTimerSetUserData(global::lvgl.LvTimerT timer, __IntPtr user_data)
        {
            var __arg0 = timer is null ? __IntPtr.Zero : timer.__Instance;
            __Internal.LvTimerSetUserData(__arg0, user_data);
        }

        /// <summary>
        /// <para>Reset a lv_timer.</para>
        /// <para>It will be called the previously set period milliseconds later.</para>
        /// </summary>
        /// <param name="timer">pointer to a lv_timer.</param>
        public static void LvTimerReset(global::lvgl.LvTimerT timer)
        {
            var __arg0 = timer is null ? __IntPtr.Zero : timer.__Instance;
            __Internal.LvTimerReset(__arg0);
        }

        /// <summary>Enable or disable the whole lv_timer handling</summary>
        /// <param name="en">true: lv_timer handling is running, false: lv_timer handling is suspended</param>
        public static void LvTimerEnable(bool en)
        {
            __Internal.LvTimerEnable(en);
        }

        /// <summary>Get idle percentage</summary>
        /// <returns>the lv_timer idle in percentage</returns>
        public static uint LvTimerGetIdle()
        {
            var ___ret = __Internal.LvTimerGetIdle();
            return ___ret;
        }

        /// <summary>Get the time remaining until the next timer will run</summary>
        /// <returns>the time remaining in ms</returns>
        public static uint LvTimerGetTimeUntilNext()
        {
            var ___ret = __Internal.LvTimerGetTimeUntilNext();
            return ___ret;
        }

        /// <summary>Iterate through the timers</summary>
        /// <param name="timer">NULL to start iteration or the previous return value to get the next timer</param>
        /// <returns>the next timer or NULL if there is no more timer</returns>
        public static global::lvgl.LvTimerT LvTimerGetNext(global::lvgl.LvTimerT timer)
        {
            var __arg0 = timer is null ? __IntPtr.Zero : timer.__Instance;
            var ___ret = __Internal.LvTimerGetNext(__arg0);
            var __result0 = global::lvgl.LvTimerT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate uint LvTickGetCbT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvDelayCbT(uint ms);

    public unsafe partial class LvTickStateT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal uint sys_time;
            internal byte sys_irq_flag;
            internal __IntPtr tick_get_cb;
            internal __IntPtr delay_cb;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_tick_state_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTickStateT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTickStateT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvTickStateT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvTickStateT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvTickStateT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvTickStateT(native.ToPointer(), skipVTables);
        }

        internal static LvTickStateT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvTickStateT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvTickStateT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvTickStateT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvTickStateT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvTickStateT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvTickStateT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTickStateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvTickStateT(global::lvgl.LvTickStateT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTickStateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvTickStateT.__Internal*) __Instance) = *((global::lvgl.LvTickStateT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint SysTime
        {
            get
            {
                return ((__Internal*)__Instance)->sys_time;
            }

            set
            {
                ((__Internal*)__Instance)->sys_time = value;
            }
        }

        public byte SysIrqFlag
        {
            get
            {
                return ((__Internal*)__Instance)->sys_irq_flag;
            }

            set
            {
                ((__Internal*)__Instance)->sys_irq_flag = value;
            }
        }

        public global::lvgl.LvTickGetCbT TickGetCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->tick_get_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvTickGetCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvTickGetCbT));
            }

            set
            {
                ((__Internal*)__Instance)->tick_get_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.LvDelayCbT DelayCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->delay_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvDelayCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvDelayCbT));
            }

            set
            {
                ((__Internal*)__Instance)->delay_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class lv_tick
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tick_inc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTickInc(uint tick_period);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tick_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvTickGet();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tick_elaps", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvTickElaps(uint prev_tick);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_delay_ms", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDelayMs(uint ms);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tick_set_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTickSetCb(__IntPtr cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_delay_set_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDelaySetCb(__IntPtr cb);
        }

        /// <summary>You have to call this function periodically</summary>
        /// <param name="tick_period">the call period of this function in milliseconds</param>
        public static void LvTickInc(uint tick_period)
        {
            __Internal.LvTickInc(tick_period);
        }

        /// <summary>Get the elapsed milliseconds since start up</summary>
        /// <returns>the elapsed milliseconds</returns>
        public static uint LvTickGet()
        {
            var ___ret = __Internal.LvTickGet();
            return ___ret;
        }

        /// <summary>Get the elapsed milliseconds since a previous time stamp</summary>
        /// <param name="prev_tick">a previous time stamp (return value of lv_tick_get() )</param>
        /// <returns>the elapsed milliseconds since 'prev_tick'</returns>
        public static uint LvTickElaps(uint prev_tick)
        {
            var ___ret = __Internal.LvTickElaps(prev_tick);
            return ___ret;
        }

        /// <summary>
        /// <para>Delay for the given milliseconds.</para>
        /// <para>By default it's a blocking delay, but with `lv_delay_set_cb()`</para>
        /// <para>a custom delay function can be set too</para>
        /// </summary>
        /// <param name="ms">the number of milliseconds to delay</param>
        public static void LvDelayMs(uint ms)
        {
            __Internal.LvDelayMs(ms);
        }

        /// <summary>Set the custom callback for 'lv_tick_get'</summary>
        /// <param name="cb">call this callback on 'lv_tick_get'</param>
        public static void LvTickSetCb(global::lvgl.LvTickGetCbT cb)
        {
            var __arg0 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.LvTickSetCb(__arg0);
        }

        /// <summary>Set a custom callback for 'lv_dalay_ms'</summary>
        /// <param name="cb">call this callback in 'lv_dalay_ms'</param>
        public static void LvDelaySetCb(global::lvgl.LvDelayCbT cb)
        {
            var __arg0 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.LvDelaySetCb(__arg0);
        }
    }

    /// <summary>Dummy type to make handling easier</summary>
    /// <summary>Description of a linked list</summary>
    /// <summary>Description of a linked list</summary>
    public unsafe partial class LvLlT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal uint n_size;
            internal __IntPtr head;
            internal __IntPtr tail;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_ll_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvLlT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvLlT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvLlT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvLlT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvLlT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvLlT(native.ToPointer(), skipVTables);
        }

        internal static LvLlT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvLlT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvLlT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvLlT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvLlT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvLlT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvLlT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvLlT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvLlT(global::lvgl.LvLlT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvLlT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvLlT.__Internal*) __Instance) = *((global::lvgl.LvLlT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint NSize
        {
            get
            {
                return ((__Internal*)__Instance)->n_size;
            }

            set
            {
                ((__Internal*)__Instance)->n_size = value;
            }
        }

        public byte* Head
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->head;
            }

            set
            {
                ((__Internal*)__Instance)->head = (__IntPtr) value;
            }
        }

        public byte* Tail
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->tail;
            }

            set
            {
                ((__Internal*)__Instance)->tail = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class lv_ll
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_ll_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLlInit(__IntPtr ll_p, uint node_size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_ll_ins_head", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvLlInsHead(__IntPtr ll_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_ll_ins_prev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvLlInsPrev(__IntPtr ll_p, __IntPtr n_act);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_ll_ins_tail", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvLlInsTail(__IntPtr ll_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_ll_remove", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLlRemove(__IntPtr ll_p, __IntPtr node_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_ll_clear_custom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLlClearCustom(__IntPtr ll_p, __IntPtr cleanup);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_ll_chg_list", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLlChgList(__IntPtr ll_ori_p, __IntPtr ll_new_p, __IntPtr node, bool head);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_ll_get_head", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvLlGetHead(__IntPtr ll_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_ll_get_tail", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvLlGetTail(__IntPtr ll_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_ll_get_next", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvLlGetNext(__IntPtr ll_p, __IntPtr n_act);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_ll_get_prev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvLlGetPrev(__IntPtr ll_p, __IntPtr n_act);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_ll_get_len", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvLlGetLen(__IntPtr ll_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_ll_move_before", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLlMoveBefore(__IntPtr ll_p, __IntPtr n_act, __IntPtr n_after);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_ll_is_empty", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvLlIsEmpty(__IntPtr ll_p);
        }

        /// <summary>Initialize linked list</summary>
        /// <param name="ll_p">pointer to lv_ll_t variable</param>
        /// <param name="node_size">the size of 1 node in bytes</param>
        public static void LvLlInit(global::lvgl.LvLlT ll_p, uint node_size)
        {
            var __arg0 = ll_p is null ? __IntPtr.Zero : ll_p.__Instance;
            __Internal.LvLlInit(__arg0, node_size);
        }

        /// <summary>Add a new head to a linked list</summary>
        /// <param name="ll_p">pointer to linked list</param>
        /// <returns>pointer to the new head</returns>
        public static __IntPtr LvLlInsHead(global::lvgl.LvLlT ll_p)
        {
            var __arg0 = ll_p is null ? __IntPtr.Zero : ll_p.__Instance;
            var ___ret = __Internal.LvLlInsHead(__arg0);
            return ___ret;
        }

        /// <summary>Insert a new node in front of the n_act node</summary>
        /// <param name="ll_p">pointer to linked list</param>
        /// <param name="n_act">pointer a node</param>
        /// <returns>pointer to the new node</returns>
        public static __IntPtr LvLlInsPrev(global::lvgl.LvLlT ll_p, __IntPtr n_act)
        {
            var __arg0 = ll_p is null ? __IntPtr.Zero : ll_p.__Instance;
            var ___ret = __Internal.LvLlInsPrev(__arg0, n_act);
            return ___ret;
        }

        /// <summary>Add a new tail to a linked list</summary>
        /// <param name="ll_p">pointer to linked list</param>
        /// <returns>pointer to the new tail</returns>
        public static __IntPtr LvLlInsTail(global::lvgl.LvLlT ll_p)
        {
            var __arg0 = ll_p is null ? __IntPtr.Zero : ll_p.__Instance;
            var ___ret = __Internal.LvLlInsTail(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Remove the node 'node_p' from 'll_p' linked list.</para>
        /// <para>It does not free the memory of node.</para>
        /// </summary>
        /// <param name="ll_p">pointer to the linked list of 'node_p'</param>
        /// <param name="node_p">pointer to node in 'll_p' linked list</param>
        public static void LvLlRemove(global::lvgl.LvLlT ll_p, __IntPtr node_p)
        {
            var __arg0 = ll_p is null ? __IntPtr.Zero : ll_p.__Instance;
            __Internal.LvLlRemove(__arg0, node_p);
        }

        public static void LvLlClearCustom(global::lvgl.LvLlT ll_p, global::lvgl.Delegates.Action___IntPtr cleanup)
        {
            var __arg0 = ll_p is null ? __IntPtr.Zero : ll_p.__Instance;
            var __arg1 = cleanup == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cleanup);
            __Internal.LvLlClearCustom(__arg0, __arg1);
        }

        /// <summary>Move a node to a new linked list</summary>
        /// <param name="ll_ori_p">pointer to the original (old) linked list</param>
        /// <param name="ll_new_p">pointer to the new linked list</param>
        /// <param name="node">pointer to a node</param>
        /// <param name="head">
        /// <para>true: be the head in the new list</para>
        /// <para>false be the tail in the new list</para>
        /// </param>
        public static void LvLlChgList(global::lvgl.LvLlT ll_ori_p, global::lvgl.LvLlT ll_new_p, __IntPtr node, bool head)
        {
            var __arg0 = ll_ori_p is null ? __IntPtr.Zero : ll_ori_p.__Instance;
            var __arg1 = ll_new_p is null ? __IntPtr.Zero : ll_new_p.__Instance;
            __Internal.LvLlChgList(__arg0, __arg1, node, head);
        }

        /// <summary>Return with head node of the linked list</summary>
        /// <param name="ll_p">pointer to linked list</param>
        /// <returns>pointer to the head of 'll_p'</returns>
        public static __IntPtr LvLlGetHead(global::lvgl.LvLlT ll_p)
        {
            var __arg0 = ll_p is null ? __IntPtr.Zero : ll_p.__Instance;
            var ___ret = __Internal.LvLlGetHead(__arg0);
            return ___ret;
        }

        /// <summary>Return with tail node of the linked list</summary>
        /// <param name="ll_p">pointer to linked list</param>
        /// <returns>pointer to the tail of 'll_p'</returns>
        public static __IntPtr LvLlGetTail(global::lvgl.LvLlT ll_p)
        {
            var __arg0 = ll_p is null ? __IntPtr.Zero : ll_p.__Instance;
            var ___ret = __Internal.LvLlGetTail(__arg0);
            return ___ret;
        }

        /// <summary>Return with the pointer of the next node after 'n_act'</summary>
        /// <param name="ll_p">pointer to linked list</param>
        /// <param name="n_act">pointer a node</param>
        /// <returns>pointer to the next node</returns>
        public static __IntPtr LvLlGetNext(global::lvgl.LvLlT ll_p, __IntPtr n_act)
        {
            var __arg0 = ll_p is null ? __IntPtr.Zero : ll_p.__Instance;
            var ___ret = __Internal.LvLlGetNext(__arg0, n_act);
            return ___ret;
        }

        /// <summary>Return with the pointer of the previous node after 'n_act'</summary>
        /// <param name="ll_p">pointer to linked list</param>
        /// <param name="n_act">pointer a node</param>
        /// <returns>pointer to the previous node</returns>
        public static __IntPtr LvLlGetPrev(global::lvgl.LvLlT ll_p, __IntPtr n_act)
        {
            var __arg0 = ll_p is null ? __IntPtr.Zero : ll_p.__Instance;
            var ___ret = __Internal.LvLlGetPrev(__arg0, n_act);
            return ___ret;
        }

        /// <summary>Return the length of the linked list.</summary>
        /// <param name="ll_p">pointer to linked list</param>
        /// <returns>length of the linked list</returns>
        public static uint LvLlGetLen(global::lvgl.LvLlT ll_p)
        {
            var __arg0 = ll_p is null ? __IntPtr.Zero : ll_p.__Instance;
            var ___ret = __Internal.LvLlGetLen(__arg0);
            return ___ret;
        }

        /// <summary>Move a node before an other node in the same linked list</summary>
        /// <param name="ll_p">pointer to a linked list</param>
        /// <param name="n_act">pointer to node to move</param>
        /// <param name="n_after">pointer to a node which should be after `n_act`</param>
        public static void LvLlMoveBefore(global::lvgl.LvLlT ll_p, __IntPtr n_act, __IntPtr n_after)
        {
            var __arg0 = ll_p is null ? __IntPtr.Zero : ll_p.__Instance;
            __Internal.LvLlMoveBefore(__arg0, n_act, n_after);
        }

        /// <summary>Check if a linked list is empty</summary>
        /// <param name="ll_p">pointer to a linked list</param>
        /// <returns>true: the linked list is empty; false: not empty</returns>
        public static bool LvLlIsEmpty(global::lvgl.LvLlT ll_p)
        {
            var __arg0 = ll_p is null ? __IntPtr.Zero : ll_p.__Instance;
            var ___ret = __Internal.LvLlIsEmpty(__arg0);
            return ___ret;
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvSqrtResT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal ushort i;
            internal ushort f;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_sqrt_res_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvSqrtResT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvSqrtResT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvSqrtResT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvSqrtResT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvSqrtResT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvSqrtResT(native.ToPointer(), skipVTables);
        }

        internal static LvSqrtResT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvSqrtResT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvSqrtResT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvSqrtResT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvSqrtResT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvSqrtResT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvSqrtResT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvSqrtResT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvSqrtResT(global::lvgl.LvSqrtResT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvSqrtResT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvSqrtResT.__Internal*) __Instance) = *((global::lvgl.LvSqrtResT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort I
        {
            get
            {
                return ((__Internal*)__Instance)->i;
            }

            set
            {
                ((__Internal*)__Instance)->i = value;
            }
        }

        public ushort F
        {
            get
            {
                return ((__Internal*)__Instance)->f;
            }

            set
            {
                ((__Internal*)__Instance)->f = value;
            }
        }
    }

    public unsafe partial class lv_math
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_trigo_sin", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvTrigoSin(short angle);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cubic_bezier", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvCubicBezier(int x, int x1, int y1, int x2, int y2);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_atan2", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort LvAtan2(int x, int y);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_sqrt", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSqrt(uint x, __IntPtr q, uint mask);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_pow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long LvPow(long @base, sbyte exp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_map", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvMap(int x, int min_in, int max_in, int min_out, int max_out);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_rand_set_seed", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvRandSetSeed(uint seed);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_rand", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvRand(uint min, uint max);
        }

        /// <summary>Return with sinus of an angle</summary>
        /// <returns>sinus of 'angle'. sin(-90) = -32767, sin(90) = 32767</returns>
        public static int LvTrigoSin(short angle)
        {
            var ___ret = __Internal.LvTrigoSin(angle);
            return ___ret;
        }

        /// <summary>Calculate the y value of cubic-bezier(x1, y1, x2, y2) function as specified x.</summary>
        /// <param name="x">time in range of [0..LV_BEZIER_VAL_MAX]</param>
        /// <param name="x1">x of control point 1 in range of [0..LV_BEZIER_VAL_MAX]</param>
        /// <param name="y1">y of control point 1 in range of [0..LV_BEZIER_VAL_MAX]</param>
        /// <param name="x2">x of control point 2 in range of [0..LV_BEZIER_VAL_MAX]</param>
        /// <param name="y2">y of control point 2 in range of [0..LV_BEZIER_VAL_MAX]</param>
        /// <returns>the value calculated</returns>
        public static int LvCubicBezier(int x, int x1, int y1, int x2, int y2)
        {
            var ___ret = __Internal.LvCubicBezier(x, x1, y1, x2, y2);
            return ___ret;
        }

        /// <summary>Calculate the atan2 of a vector.</summary>
        /// <returns>the angle in degree calculated from the given parameters in range of [0..360]</returns>
        public static ushort LvAtan2(int x, int y)
        {
            var ___ret = __Internal.LvAtan2(x, y);
            return ___ret;
        }

        /// <summary>Get the square root of a number</summary>
        /// <param name="x">integer which square root should be calculated</param>
        /// <param name="q">store the result here. q-&gt;i: integer part, q-&gt;f: fractional part in 1/256 unit</param>
        /// <param name="mask">
        /// <para>optional to skip some iterations if the magnitude of the root is known.</para>
        /// <para>Set to 0x8000 by default.</para>
        /// <para>If root&lt;16: mask = 0x80</para>
        /// <para>If root&lt;256: mask = 0x800</para>
        /// <para>Else: mask = 0x8000</para>
        /// </param>
        public static void LvSqrt(uint x, global::lvgl.LvSqrtResT q, uint mask)
        {
            var __arg1 = q is null ? __IntPtr.Zero : q.__Instance;
            __Internal.LvSqrt(x, __arg1, mask);
        }

        /// <summary>Calculate the integer exponents.</summary>
        /// <returns>base raised to the power exponent</returns>
        public static long LvPow(long @base, sbyte exp)
        {
            var ___ret = __Internal.LvPow(@base, exp);
            return ___ret;
        }

        /// <summary>Get the mapped of a number given an input and output range</summary>
        /// <param name="x">integer which mapped value should be calculated</param>
        /// <param name="min_in">min input range</param>
        /// <param name="max_in">max input range</param>
        /// <param name="min_out">max output range</param>
        /// <param name="max_out">max output range</param>
        /// <returns>the mapped number</returns>
        public static int LvMap(int x, int min_in, int max_in, int min_out, int max_out)
        {
            var ___ret = __Internal.LvMap(x, min_in, max_in, min_out, max_out);
            return ___ret;
        }

        /// <summary>Set the seed of the pseudo random number generator</summary>
        /// <param name="seed">a number to initialize the random generator</param>
        public static void LvRandSetSeed(uint seed)
        {
            __Internal.LvRandSetSeed(seed);
        }

        /// <summary>Get a pseudo random number in the given range</summary>
        /// <param name="min">the minimum value</param>
        /// <param name="max">the maximum value</param>
        /// <returns>return the random number. min&lt;= return_value&lt;= max</returns>
        public static uint LvRand(uint min, uint max)
        {
            var ___ret = __Internal.LvRand(min, max);
            return ___ret;
        }
    }

    /// <summary>Description of a array</summary>
    /// <summary>Description of a array</summary>
    public unsafe partial class LvArrayT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr data;
            internal uint size;
            internal uint capacity;
            internal uint element_size;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_array_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvArrayT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvArrayT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvArrayT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvArrayT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvArrayT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvArrayT(native.ToPointer(), skipVTables);
        }

        internal static LvArrayT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvArrayT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvArrayT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvArrayT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvArrayT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvArrayT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvArrayT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvArrayT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvArrayT(global::lvgl.LvArrayT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvArrayT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvArrayT.__Internal*) __Instance) = *((global::lvgl.LvArrayT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte* Data
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->data;
            }

            set
            {
                ((__Internal*)__Instance)->data = (__IntPtr) value;
            }
        }

        public uint Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }

        public uint Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->capacity;
            }

            set
            {
                ((__Internal*)__Instance)->capacity = value;
            }
        }

        public uint ElementSize
        {
            get
            {
                return ((__Internal*)__Instance)->element_size;
            }

            set
            {
                ((__Internal*)__Instance)->element_size = value;
            }
        }
    }

    public unsafe partial class lv_array
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_array_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArrayInit(__IntPtr array, uint capacity, uint element_size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_array_resize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArrayResize(__IntPtr array, uint new_capacity);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_array_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArrayDeinit(__IntPtr array);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_array_copy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArrayCopy(__IntPtr target, __IntPtr source);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_array_remove", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvArrayRemove(__IntPtr array, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_array_erase", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvArrayErase(__IntPtr array, uint start, uint end);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_array_concat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvArrayConcat(__IntPtr array, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_array_push_back", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvArrayPushBack(__IntPtr array, __IntPtr element);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_array_assign", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvArrayAssign(__IntPtr array, uint index, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_array_at", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvArrayAt(__IntPtr array, uint index);
        }

        /// <summary>Init an array.</summary>
        /// <param name="array">pointer to an `lv_array_t` variable to initialize</param>
        /// <param name="capacity">the initial capacity of the array</param>
        /// <param name="element_size">the size of an element in bytes</param>
        public static void LvArrayInit(global::lvgl.LvArrayT array, uint capacity, uint element_size)
        {
            var __arg0 = array is null ? __IntPtr.Zero : array.__Instance;
            __Internal.LvArrayInit(__arg0, capacity, element_size);
        }

        /// <summary>Resize the array to the given capacity.</summary>
        /// <param name="array">pointer to an `lv_array_t` variable</param>
        /// <param name="new_capacity">the new capacity of the array</param>
        /// <remarks>if the new capacity is smaller than the current size, the array will be truncated.</remarks>
        public static void LvArrayResize(global::lvgl.LvArrayT array, uint new_capacity)
        {
            var __arg0 = array is null ? __IntPtr.Zero : array.__Instance;
            __Internal.LvArrayResize(__arg0, new_capacity);
        }

        /// <summary>Deinit the array, and free the allocated memory</summary>
        /// <param name="array">pointer to an `lv_array_t` variable to deinitialize</param>
        public static void LvArrayDeinit(global::lvgl.LvArrayT array)
        {
            var __arg0 = array is null ? __IntPtr.Zero : array.__Instance;
            __Internal.LvArrayDeinit(__arg0);
        }

        /// <summary>Copy an array to another.</summary>
        /// <param name="target">pointer to an `lv_array_t` variable to copy to</param>
        /// <param name="source">pointer to an `lv_array_t` variable to copy from</param>
        /// <remarks>this will create a new array with the same capacity and size as the source array.</remarks>
        public static void LvArrayCopy(global::lvgl.LvArrayT target, global::lvgl.LvArrayT source)
        {
            var __arg0 = target is null ? __IntPtr.Zero : target.__Instance;
            var __arg1 = source is null ? __IntPtr.Zero : source.__Instance;
            __Internal.LvArrayCopy(__arg0, __arg1);
        }

        /// <summary>Remove the element at the specified position in the array.</summary>
        /// <param name="array">pointer to an `lv_array_t` variable</param>
        /// <param name="index">the index of the element to remove</param>
        /// <returns>LV_RESULT_OK: success, otherwise: error</returns>
        public static byte LvArrayRemove(global::lvgl.LvArrayT array, uint index)
        {
            var __arg0 = array is null ? __IntPtr.Zero : array.__Instance;
            var ___ret = __Internal.LvArrayRemove(__arg0, index);
            return ___ret;
        }

        /// <summary>Remove from the array either a single element or a range of elements ([start, end)).</summary>
        /// <param name="array">pointer to an `lv_array_t` variable</param>
        /// <param name="start">the index of the first element to be removed</param>
        /// <param name="end">the index of the first element that is not to be removed</param>
        /// <returns>LV_RESULT_OK: success, otherwise: error</returns>
        /// <remarks>
        /// <para>This effectively reduces the container size by the number of elements removed.</para>
        /// <para>When start equals to end, the function has no effect.</para>
        /// </remarks>
        public static byte LvArrayErase(global::lvgl.LvArrayT array, uint start, uint end)
        {
            var __arg0 = array is null ? __IntPtr.Zero : array.__Instance;
            var ___ret = __Internal.LvArrayErase(__arg0, start, end);
            return ___ret;
        }

        /// <summary>Concatenate two arrays. Adds new elements to the end of the array.</summary>
        /// <param name="array">pointer to an `lv_array_t` variable</param>
        /// <param name="other">pointer to the array to concatenate</param>
        /// <returns>LV_RESULT_OK: success, otherwise: error</returns>
        /// <remarks>The destination array is automatically expanded as necessary.</remarks>
        public static byte LvArrayConcat(global::lvgl.LvArrayT array, global::lvgl.LvArrayT other)
        {
            var __arg0 = array is null ? __IntPtr.Zero : array.__Instance;
            var __arg1 = other is null ? __IntPtr.Zero : other.__Instance;
            var ___ret = __Internal.LvArrayConcat(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>
        /// <para>Push back element. Adds a new element to the end of the array.</para>
        /// <para>If the array capacity is not enough for the new element, the array will be resized automatically.</para>
        /// </summary>
        /// <param name="array">pointer to an `lv_array_t` variable</param>
        /// <param name="element">pointer to the element to add</param>
        /// <returns>LV_RESULT_OK: success, otherwise: error</returns>
        public static byte LvArrayPushBack(global::lvgl.LvArrayT array, __IntPtr element)
        {
            var __arg0 = array is null ? __IntPtr.Zero : array.__Instance;
            var ___ret = __Internal.LvArrayPushBack(__arg0, element);
            return ___ret;
        }

        /// <summary>Assigns one content to the array, replacing its current content.</summary>
        /// <param name="array">pointer to an `lv_array_t` variable</param>
        /// <param name="index">the index of the element to replace</param>
        /// <param name="value">pointer to the elements to add</param>
        /// <returns>true: success; false: error</returns>
        public static byte LvArrayAssign(global::lvgl.LvArrayT array, uint index, __IntPtr value)
        {
            var __arg0 = array is null ? __IntPtr.Zero : array.__Instance;
            var ___ret = __Internal.LvArrayAssign(__arg0, index, value);
            return ___ret;
        }

        /// <summary>Returns a pointer to the element at position n in the array.</summary>
        /// <param name="array">pointer to an `lv_array_t` variable</param>
        /// <param name="index">the index of the element to return</param>
        /// <returns>a pointer to the requested element, NULL if `index` is out of range</returns>
        public static __IntPtr LvArrayAt(global::lvgl.LvArrayT array, uint index)
        {
            var __arg0 = array is null ? __IntPtr.Zero : array.__Instance;
            var ___ret = __Internal.LvArrayAt(__arg0, index);
            return ___ret;
        }
    }

    /// <summary>Type for async callback.</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvAsyncCbT(__IntPtr __0);

    public unsafe partial class lv_async
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_async_call", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvAsyncCall(__IntPtr async_xcb, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_async_call_cancel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvAsyncCallCancel(__IntPtr async_xcb, __IntPtr user_data);
        }

        /// <summary>
        /// <para>Call an asynchronous function the next time lv_timer_handler() is run. This function is likely to return</para>
        /// <para>**before** the call actually happens!</para>
        /// </summary>
        /// <param name="async_xcb">
        /// <para>a callback which is the task itself.</para>
        /// <para>(the 'x' in the argument name indicates that it's not a fully generic function because it not follows</para>
        /// <para>the `func_name(object, callback, ...)` convention)</para>
        /// </param>
        /// <param name="user_data">custom parameter</param>
        public static byte LvAsyncCall(global::lvgl.LvAsyncCbT async_xcb, __IntPtr user_data)
        {
            var __arg0 = async_xcb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(async_xcb);
            var ___ret = __Internal.LvAsyncCall(__arg0, user_data);
            return ___ret;
        }

        /// <summary>Cancel an asynchronous function call</summary>
        /// <param name="async_xcb">a callback which is the task itself.</param>
        /// <param name="user_data">custom parameter</param>
        public static byte LvAsyncCallCancel(global::lvgl.LvAsyncCbT async_xcb, __IntPtr user_data)
        {
            var __arg0 = async_xcb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(async_xcb);
            var ___ret = __Internal.LvAsyncCallCancel(__arg0, user_data);
            return ___ret;
        }
    }

    public unsafe partial class LvAnimTimelineT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvAnimTimelineT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvAnimTimelineT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvAnimTimelineT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvAnimTimelineT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvAnimTimelineT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvAnimTimelineT(native.ToPointer(), skipVTables);
        }

        internal static LvAnimTimelineT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvAnimTimelineT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvAnimTimelineT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvAnimTimelineT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvAnimTimelineT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvAnimTimelineT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class lv_anim_timeline
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_timeline_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvAnimTimelineCreate();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_timeline_delete", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAnimTimelineDelete(__IntPtr at);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_timeline_add", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAnimTimelineAdd(__IntPtr at, uint start_time, __IntPtr a);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_timeline_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvAnimTimelineStart(__IntPtr at);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_timeline_pause", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAnimTimelinePause(__IntPtr at);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_timeline_set_reverse", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAnimTimelineSetReverse(__IntPtr at, bool reverse);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_timeline_set_progress", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAnimTimelineSetProgress(__IntPtr at, ushort progress);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_timeline_get_playtime", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvAnimTimelineGetPlaytime(__IntPtr at);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_timeline_get_reverse", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvAnimTimelineGetReverse(__IntPtr at);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_timeline_get_progress", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort LvAnimTimelineGetProgress(__IntPtr at);
        }

        /// <summary>Create an animation timeline.</summary>
        /// <returns>pointer to the animation timeline.</returns>
        public static global::lvgl.LvAnimTimelineT LvAnimTimelineCreate()
        {
            var ___ret = __Internal.LvAnimTimelineCreate();
            var __result0 = global::lvgl.LvAnimTimelineT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Delete animation timeline.</summary>
        /// <param name="at">pointer to the animation timeline.</param>
        public static void LvAnimTimelineDelete(global::lvgl.LvAnimTimelineT at)
        {
            var __arg0 = at is null ? __IntPtr.Zero : at.__Instance;
            __Internal.LvAnimTimelineDelete(__arg0);
        }

        /// <summary>Add animation to the animation timeline.</summary>
        /// <param name="at">pointer to the animation timeline.</param>
        /// <param name="start_time">the time the animation started on the timeline, note that start_time will override the value of delay.</param>
        /// <param name="a">pointer to an animation.</param>
        public static void LvAnimTimelineAdd(global::lvgl.LvAnimTimelineT at, uint start_time, global::lvgl.LvAnimT a)
        {
            var __arg0 = at is null ? __IntPtr.Zero : at.__Instance;
            var __arg2 = a is null ? __IntPtr.Zero : a.__Instance;
            __Internal.LvAnimTimelineAdd(__arg0, start_time, __arg2);
        }

        /// <summary>Start the animation timeline.</summary>
        /// <param name="at">pointer to the animation timeline.</param>
        /// <returns>total time spent in animation timeline.</returns>
        public static uint LvAnimTimelineStart(global::lvgl.LvAnimTimelineT at)
        {
            var __arg0 = at is null ? __IntPtr.Zero : at.__Instance;
            var ___ret = __Internal.LvAnimTimelineStart(__arg0);
            return ___ret;
        }

        /// <summary>Pause the animation timeline.</summary>
        /// <param name="at">pointer to the animation timeline.</param>
        public static void LvAnimTimelinePause(global::lvgl.LvAnimTimelineT at)
        {
            var __arg0 = at is null ? __IntPtr.Zero : at.__Instance;
            __Internal.LvAnimTimelinePause(__arg0);
        }

        /// <summary>Set the playback direction of the animation timeline.</summary>
        /// <param name="at">pointer to the animation timeline.</param>
        /// <param name="reverse">whether to play in reverse.</param>
        public static void LvAnimTimelineSetReverse(global::lvgl.LvAnimTimelineT at, bool reverse)
        {
            var __arg0 = at is null ? __IntPtr.Zero : at.__Instance;
            __Internal.LvAnimTimelineSetReverse(__arg0, reverse);
        }

        /// <summary>Set the progress of the animation timeline.</summary>
        /// <param name="at">pointer to the animation timeline.</param>
        /// <param name="progress">set value 0~65535 to map 0~100% animation progress.</param>
        public static void LvAnimTimelineSetProgress(global::lvgl.LvAnimTimelineT at, ushort progress)
        {
            var __arg0 = at is null ? __IntPtr.Zero : at.__Instance;
            __Internal.LvAnimTimelineSetProgress(__arg0, progress);
        }

        /// <summary>Get the time used to play the animation timeline.</summary>
        /// <param name="at">pointer to the animation timeline.</param>
        /// <returns>total time spent in animation timeline.</returns>
        public static uint LvAnimTimelineGetPlaytime(global::lvgl.LvAnimTimelineT at)
        {
            var __arg0 = at is null ? __IntPtr.Zero : at.__Instance;
            var ___ret = __Internal.LvAnimTimelineGetPlaytime(__arg0);
            return ___ret;
        }

        /// <summary>Get whether the animation timeline is played in reverse.</summary>
        /// <param name="at">pointer to the animation timeline.</param>
        /// <returns>return true if it is reverse playback.</returns>
        public static bool LvAnimTimelineGetReverse(global::lvgl.LvAnimTimelineT at)
        {
            var __arg0 = at is null ? __IntPtr.Zero : at.__Instance;
            var ___ret = __Internal.LvAnimTimelineGetReverse(__arg0);
            return ___ret;
        }

        /// <summary>Get the progress of the animation timeline.</summary>
        /// <param name="at">pointer to the animation timeline.</param>
        /// <returns>return value 0~65535 to map 0~100% animation progress.</returns>
        public static ushort LvAnimTimelineGetProgress(global::lvgl.LvAnimTimelineT at)
        {
            var __arg0 = at is null ? __IntPtr.Zero : at.__Instance;
            var ___ret = __Internal.LvAnimTimelineGetProgress(__arg0);
            return ___ret;
        }
    }

    /// <summary>Can be used to indicate if animations are enabled or disabled in a case</summary>
    public enum LvAnimEnableT
    {
        LV_ANIM_OFF = 0,
        LV_ANIM_ON = 1
    }

    /// <summary>
    /// <para>Generic prototype of &quot;animator&quot; functions.</para>
    /// <para>First parameter is the variable to animate.</para>
    /// <para>Second parameter is the value to set.</para>
    /// <para>Compatible with `lv_xxx_set_yyy(obj, value)` functions</para>
    /// <para>The `x` in `_xcb_t` means it's not a fully generic prototype because</para>
    /// <para>it doesn't receive `lv_anim_t *` as its first argument</para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvAnimExecXcbT(__IntPtr __0, int __1);

    /// <summary>
    /// <para>Same as `lv_anim_exec_xcb_t` but receives `lv_anim_t *` as the first parameter.</para>
    /// <para>It's more consistent but less convenient. Might be used by binding generator functions.</para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvAnimCustomExecCbT(__IntPtr __0, int __1);

    /// <summary>Callback to call when the animation really stars (considering `delay`)</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvAnimStartCbT(__IntPtr __0);

    /// <summary>Callback to call when the animation is ready</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvAnimCompletedCbT(__IntPtr __0);

    /// <summary>Callback used when the animation is deleted</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvAnimDeletedCbT(__IntPtr __0);

    /// <summary>Callback used when the animation values are relative to get the current value</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int LvAnimGetValueCbT(__IntPtr __0);

    /// <summary>Get the current value during an animation</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int LvAnimPathCbT(__IntPtr __0);

    /// <summary>Can be used to indicate if animations are enabled or disabled in a case</summary>
    public unsafe partial class LvAnimStateT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal byte anim_list_changed;
            internal byte anim_run_round;
            internal __IntPtr timer;
            internal global::lvgl.LvLlT.__Internal anim_ll;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_anim_state_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvAnimStateT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvAnimStateT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvAnimStateT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvAnimStateT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvAnimStateT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvAnimStateT(native.ToPointer(), skipVTables);
        }

        internal static LvAnimStateT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvAnimStateT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvAnimStateT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvAnimStateT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvAnimStateT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvAnimStateT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvAnimStateT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvAnimStateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvAnimStateT(global::lvgl.LvAnimStateT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvAnimStateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvAnimStateT.__Internal*) __Instance) = *((global::lvgl.LvAnimStateT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool AnimListChanged
        {
            get
            {
                return ((__Internal*)__Instance)->anim_list_changed != 0;
            }

            set
            {
                ((__Internal*)__Instance)->anim_list_changed = (byte) (value ? 1 : 0);
            }
        }

        public bool AnimRunRound
        {
            get
            {
                return ((__Internal*)__Instance)->anim_run_round != 0;
            }

            set
            {
                ((__Internal*)__Instance)->anim_run_round = (byte) (value ? 1 : 0);
            }
        }

        public global::lvgl.LvTimerT Timer
        {
            get
            {
                var __result0 = global::lvgl.LvTimerT.__GetOrCreateInstance(((__Internal*)__Instance)->timer, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->timer = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvLlT AnimLl
        {
            get
            {
                return global::lvgl.LvLlT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->anim_ll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->anim_ll = *(global::lvgl.LvLlT.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class LvAnimBezier3ParaT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal short x1;
            internal short y1;
            internal short x2;
            internal short y2;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_anim_bezier3_para_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvAnimBezier3ParaT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvAnimBezier3ParaT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvAnimBezier3ParaT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvAnimBezier3ParaT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvAnimBezier3ParaT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvAnimBezier3ParaT(native.ToPointer(), skipVTables);
        }

        internal static LvAnimBezier3ParaT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvAnimBezier3ParaT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvAnimBezier3ParaT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvAnimBezier3ParaT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvAnimBezier3ParaT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvAnimBezier3ParaT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvAnimBezier3ParaT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvAnimBezier3ParaT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvAnimBezier3ParaT(global::lvgl.LvAnimBezier3ParaT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvAnimBezier3ParaT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvAnimBezier3ParaT.__Internal*) __Instance) = *((global::lvgl.LvAnimBezier3ParaT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public short X1
        {
            get
            {
                return ((__Internal*)__Instance)->x1;
            }

            set
            {
                ((__Internal*)__Instance)->x1 = value;
            }
        }

        public short Y1
        {
            get
            {
                return ((__Internal*)__Instance)->y1;
            }

            set
            {
                ((__Internal*)__Instance)->y1 = value;
            }
        }

        public short X2
        {
            get
            {
                return ((__Internal*)__Instance)->x2;
            }

            set
            {
                ((__Internal*)__Instance)->x2 = value;
            }
        }

        public short Y2
        {
            get
            {
                return ((__Internal*)__Instance)->y2;
            }

            set
            {
                ((__Internal*)__Instance)->y2 = value;
            }
        }
    }

    /// <summary>Describes an animation</summary>
    public unsafe partial class LvAnimT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr var;

            [FieldOffset(8)]
            internal __IntPtr exec_cb;

            [FieldOffset(16)]
            internal __IntPtr custom_exec_cb;

            [FieldOffset(24)]
            internal __IntPtr start_cb;

            [FieldOffset(32)]
            internal __IntPtr completed_cb;

            [FieldOffset(40)]
            internal __IntPtr deleted_cb;

            [FieldOffset(48)]
            internal __IntPtr get_value_cb;

            [FieldOffset(56)]
            internal __IntPtr user_data;

            [FieldOffset(64)]
            internal __IntPtr path_cb;

            [FieldOffset(72)]
            internal int start_value;

            [FieldOffset(76)]
            internal int current_value;

            [FieldOffset(80)]
            internal int end_value;

            [FieldOffset(84)]
            internal int duration;

            [FieldOffset(88)]
            internal int act_time;

            [FieldOffset(92)]
            internal uint playback_delay;

            [FieldOffset(96)]
            internal uint playback_duration;

            [FieldOffset(100)]
            internal uint repeat_delay;

            [FieldOffset(104)]
            internal uint repeat_cnt;

            [FieldOffset(108)]
            internal global::lvgl.LvAnimT.LvAnimPathParaT.__Internal parameter;

            [FieldOffset(116)]
            internal uint last_timer_run;

            [FieldOffset(120)]
            internal byte playback_now;

            [FieldOffset(120)]
            internal byte run_round;

            [FieldOffset(120)]
            internal byte start_cb_called;

            [FieldOffset(120)]
            internal byte early_apply;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_anim_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial struct LvAnimPathParaT
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::lvgl.LvAnimBezier3ParaT.__Internal bezier3;

                [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_anim_path_para_t@_lv_anim_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            private LvAnimPathParaT.__Internal __instance;
            internal ref LvAnimPathParaT.__Internal __Instance => ref __instance;

            internal static LvAnimPathParaT __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new LvAnimPathParaT(native.ToPointer(), skipVTables);
            }

            internal static LvAnimPathParaT __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new LvAnimPathParaT(native, skipVTables);
            }

            private LvAnimPathParaT(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private LvAnimPathParaT(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::lvgl.LvAnimT.LvAnimPathParaT.__Internal*) native;
            }

            public LvAnimPathParaT(global::lvgl.LvAnimT.LvAnimPathParaT _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>Parameter used when path is custom_bezier</summary>
            public global::lvgl.LvAnimBezier3ParaT Bezier3
            {
                get
                {
                    return global::lvgl.LvAnimBezier3ParaT.__CreateInstance(__instance.bezier3);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.bezier3 = *(global::lvgl.LvAnimBezier3ParaT.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvAnimT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvAnimT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvAnimT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvAnimT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvAnimT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvAnimT(native.ToPointer(), skipVTables);
        }

        internal static LvAnimT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvAnimT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvAnimT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvAnimT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvAnimT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvAnimT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvAnimT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvAnimT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvAnimT(global::lvgl.LvAnimT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvAnimT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvAnimT.__Internal*) __Instance) = *((global::lvgl.LvAnimT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Variable to animate</summary>
        public __IntPtr Var
        {
            get
            {
                return ((__Internal*)__Instance)->var;
            }

            set
            {
                ((__Internal*)__Instance)->var = (__IntPtr) value;
            }
        }

        /// <summary>Function to execute to animate</summary>
        public global::lvgl.LvAnimExecXcbT ExecCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->exec_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvAnimExecXcbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvAnimExecXcbT));
            }

            set
            {
                ((__Internal*)__Instance)->exec_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>
        /// <para>Function to execute to animate,</para>
        /// <para>same purpose as exec_cb but different parameters</para>
        /// </summary>
        public global::lvgl.LvAnimCustomExecCbT CustomExecCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->custom_exec_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvAnimCustomExecCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvAnimCustomExecCbT));
            }

            set
            {
                ((__Internal*)__Instance)->custom_exec_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Call it when the animation is starts (considering `delay`)</summary>
        public global::lvgl.LvAnimStartCbT StartCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->start_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvAnimStartCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvAnimStartCbT));
            }

            set
            {
                ((__Internal*)__Instance)->start_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Call it when the animation is fully completed</summary>
        public global::lvgl.LvAnimCompletedCbT CompletedCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->completed_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvAnimCompletedCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvAnimCompletedCbT));
            }

            set
            {
                ((__Internal*)__Instance)->completed_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Call it when the animation is deleted</summary>
        public global::lvgl.LvAnimDeletedCbT DeletedCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->deleted_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvAnimDeletedCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvAnimDeletedCbT));
            }

            set
            {
                ((__Internal*)__Instance)->deleted_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Get the current value in relative mode</summary>
        public global::lvgl.LvAnimGetValueCbT GetValueCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_value_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvAnimGetValueCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvAnimGetValueCbT));
            }

            set
            {
                ((__Internal*)__Instance)->get_value_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Custom user data</summary>
        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }

        /// <summary>Describe the path (curve) of animations</summary>
        public global::lvgl.LvAnimPathCbT PathCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->path_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvAnimPathCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvAnimPathCbT));
            }

            set
            {
                ((__Internal*)__Instance)->path_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Start value</summary>
        public int StartValue
        {
            get
            {
                return ((__Internal*)__Instance)->start_value;
            }

            set
            {
                ((__Internal*)__Instance)->start_value = value;
            }
        }

        /// <summary>Current value</summary>
        public int CurrentValue
        {
            get
            {
                return ((__Internal*)__Instance)->current_value;
            }

            set
            {
                ((__Internal*)__Instance)->current_value = value;
            }
        }

        /// <summary>End value</summary>
        public int EndValue
        {
            get
            {
                return ((__Internal*)__Instance)->end_value;
            }

            set
            {
                ((__Internal*)__Instance)->end_value = value;
            }
        }

        /// <summary>Animation time in ms</summary>
        public int Duration
        {
            get
            {
                return ((__Internal*)__Instance)->duration;
            }

            set
            {
                ((__Internal*)__Instance)->duration = value;
            }
        }

        /// <summary>Current time in animation. Set to negative to make delay.</summary>
        public int ActTime
        {
            get
            {
                return ((__Internal*)__Instance)->act_time;
            }

            set
            {
                ((__Internal*)__Instance)->act_time = value;
            }
        }

        /// <summary>Wait before play back</summary>
        public uint PlaybackDelay
        {
            get
            {
                return ((__Internal*)__Instance)->playback_delay;
            }

            set
            {
                ((__Internal*)__Instance)->playback_delay = value;
            }
        }

        /// <summary>Duration of playback animation</summary>
        public uint PlaybackDuration
        {
            get
            {
                return ((__Internal*)__Instance)->playback_duration;
            }

            set
            {
                ((__Internal*)__Instance)->playback_duration = value;
            }
        }

        /// <summary>Wait before repeat</summary>
        public uint RepeatDelay
        {
            get
            {
                return ((__Internal*)__Instance)->repeat_delay;
            }

            set
            {
                ((__Internal*)__Instance)->repeat_delay = value;
            }
        }

        /// <summary>Repeat count for the animation</summary>
        public uint RepeatCnt
        {
            get
            {
                return ((__Internal*)__Instance)->repeat_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->repeat_cnt = value;
            }
        }

        public global::lvgl.LvAnimT.LvAnimPathParaT Parameter
        {
            get
            {
                return global::lvgl.LvAnimT.LvAnimPathParaT.__CreateInstance(((__Internal*)__Instance)->parameter);
            }

            set
            {
                ((__Internal*)__Instance)->parameter = value.__Instance;
            }
        }

        public uint LastTimerRun
        {
            get
            {
                return ((__Internal*)__Instance)->last_timer_run;
            }

            set
            {
                ((__Internal*)__Instance)->last_timer_run = value;
            }
        }

        /// <summary>Play back is in progress</summary>
        public byte PlaybackNow
        {
            get
            {
                return ((__Internal*)__Instance)->playback_now;
            }

            set
            {
                ((__Internal*)__Instance)->playback_now = value;
            }
        }

        /// <summary>Indicates the animation has run in this round</summary>
        public byte RunRound
        {
            get
            {
                return ((__Internal*)__Instance)->run_round;
            }

            set
            {
                ((__Internal*)__Instance)->run_round = value;
            }
        }

        /// <summary>Indicates that the `start_cb` was already called</summary>
        public byte StartCbCalled
        {
            get
            {
                return ((__Internal*)__Instance)->start_cb_called;
            }

            set
            {
                ((__Internal*)__Instance)->start_cb_called = value;
            }
        }

        /// <summary>1: Apply start value immediately even is there is `delay`</summary>
        public byte EarlyApply
        {
            get
            {
                return ((__Internal*)__Instance)->early_apply;
            }

            set
            {
                ((__Internal*)__Instance)->early_apply = value;
            }
        }
    }

    public unsafe partial class lv_anim
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_anim_core_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAnimCoreInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_anim_core_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAnimCoreDeinit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAnimInit(__IntPtr a);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvAnimStart(__IntPtr a);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_get_playtime", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvAnimGetPlaytime(__IntPtr a);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_delete", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvAnimDelete(__IntPtr var, __IntPtr exec_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_delete_all", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAnimDeleteAll();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvAnimGet(__IntPtr var, __IntPtr exec_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_get_timer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvAnimGetTimer();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_count_running", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort LvAnimCountRunning();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_speed", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvAnimSpeed(uint speed);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_speed_clamped", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvAnimSpeedClamped(uint speed, uint min_time, uint max_time);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_refr_now", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAnimRefrNow();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_path_linear", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvAnimPathLinear(__IntPtr a);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_path_ease_in", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvAnimPathEaseIn(__IntPtr a);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_path_ease_out", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvAnimPathEaseOut(__IntPtr a);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_path_ease_in_out", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvAnimPathEaseInOut(__IntPtr a);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_path_overshoot", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvAnimPathOvershoot(__IntPtr a);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_path_bounce", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvAnimPathBounce(__IntPtr a);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_path_step", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvAnimPathStep(__IntPtr a);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_anim_path_custom_bezier3", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvAnimPathCustomBezier3(__IntPtr a);
        }

        /// <summary>Init the animation module</summary>
        public static void LvAnimCoreInit()
        {
            __Internal.LvAnimCoreInit();
        }

        /// <summary>Deinit the animation module</summary>
        public static void LvAnimCoreDeinit()
        {
            __Internal.LvAnimCoreDeinit();
        }

        /// <summary>
        /// <para>Initialize an animation variable.</para>
        /// <para>E.g.:</para>
        /// <para>lv_anim_t a;</para>
        /// <para>lv_anim_init(&amp;a);</para>
        /// <para>lv_anim_set_...(&amp;a);</para>
        /// <para>lv_anim_start(&amp;a);</para>
        /// </summary>
        /// <param name="a">pointer to an `lv_anim_t` variable to initialize</param>
        public static void LvAnimInit(global::lvgl.LvAnimT a)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            __Internal.LvAnimInit(__arg0);
        }

        /// <summary>Create an animation</summary>
        /// <param name="a">an initialized 'anim_t' variable. Not required after call.</param>
        /// <returns>pointer to the created animation (different from the `a` parameter)</returns>
        public static global::lvgl.LvAnimT LvAnimStart(global::lvgl.LvAnimT a)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var ___ret = __Internal.LvAnimStart(__arg0);
            var __result0 = global::lvgl.LvAnimT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the time used to play the animation.</summary>
        /// <param name="a">pointer to an animation.</param>
        /// <returns>the play time in milliseconds.</returns>
        public static uint LvAnimGetPlaytime(global::lvgl.LvAnimT a)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var ___ret = __Internal.LvAnimGetPlaytime(__arg0);
            return ___ret;
        }

        /// <summary>Delete animation(s) of a variable with a given animator function</summary>
        /// <param name="var">pointer to variable</param>
        /// <param name="exec_cb">
        /// <para>a function pointer which is animating 'var',</para>
        /// <para>or NULL to ignore it and delete all the animations of 'var</para>
        /// </param>
        /// <returns>true: at least 1 animation is deleted, false: no animation is deleted</returns>
        public static bool LvAnimDelete(__IntPtr var, global::lvgl.LvAnimExecXcbT exec_cb)
        {
            var __arg1 = exec_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(exec_cb);
            var ___ret = __Internal.LvAnimDelete(var, __arg1);
            return ___ret;
        }

        /// <summary>Delete all the animations</summary>
        public static void LvAnimDeleteAll()
        {
            __Internal.LvAnimDeleteAll();
        }

        /// <summary>Get the animation of a variable and its `exec_cb`.</summary>
        /// <param name="var">pointer to variable</param>
        /// <param name="exec_cb">a function pointer which is animating 'var', or NULL to return first matching 'var'</param>
        /// <returns>pointer to the animation.</returns>
        public static global::lvgl.LvAnimT LvAnimGet(__IntPtr var, global::lvgl.LvAnimExecXcbT exec_cb)
        {
            var __arg1 = exec_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(exec_cb);
            var ___ret = __Internal.LvAnimGet(var, __arg1);
            var __result0 = global::lvgl.LvAnimT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get global animation refresher timer.</summary>
        /// <returns>pointer to the animation refresher timer.</returns>
        public static global::lvgl.LvTimerT LvAnimGetTimer()
        {
            var ___ret = __Internal.LvAnimGetTimer();
            var __result0 = global::lvgl.LvTimerT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the number of currently running animations</summary>
        /// <returns>the number of running animations</returns>
        public static ushort LvAnimCountRunning()
        {
            var ___ret = __Internal.LvAnimCountRunning();
            return ___ret;
        }

        /// <summary>
        /// <para>Store the speed as a special value which can be used as time in animations.</para>
        /// <para>It will be converted to time internally based on the start and end values</para>
        /// </summary>
        /// <param name="speed">the speed of the animation in with unit / sec resolution in 0..10k range</param>
        /// <returns>a special value which can be used as an animation time</returns>
        public static uint LvAnimSpeed(uint speed)
        {
            var ___ret = __Internal.LvAnimSpeed(speed);
            return ___ret;
        }

        /// <summary>
        /// <para>Store the speed as a special value which can be used as time in animations.</para>
        /// <para>It will be converted to time internally based on the start and end values</para>
        /// </summary>
        /// <param name="speed">the speed of the animation in as unit / sec resolution in 0..10k range</param>
        /// <param name="min_time">the minimum time in 0..10k range</param>
        /// <param name="max_time">the maximum time in 0..10k range</param>
        /// <returns>a special value in where all three values are stored and can be used as an animation time</returns>
        /// <remarks>
        /// <para>internally speed is stored as 10 unit/sec</para>
        /// <para>internally min/max_time are stored with 10 ms unit</para>
        /// </remarks>
        public static uint LvAnimSpeedClamped(uint speed, uint min_time, uint max_time)
        {
            var ___ret = __Internal.LvAnimSpeedClamped(speed, min_time, max_time);
            return ___ret;
        }

        /// <summary>
        /// <para>Manually refresh the state of the animations.</para>
        /// <para>Useful to make the animations running in a blocking process where</para>
        /// <para>`lv_timer_handler` can't run for a while.</para>
        /// <para>Shouldn't be used directly because it is called in `lv_refr_now()`.</para>
        /// </summary>
        public static void LvAnimRefrNow()
        {
            __Internal.LvAnimRefrNow();
        }

        /// <summary>Calculate the current value of an animation applying linear characteristic</summary>
        /// <param name="a">pointer to an animation</param>
        /// <returns>the current value to set</returns>
        public static int LvAnimPathLinear(global::lvgl.LvAnimT a)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var ___ret = __Internal.LvAnimPathLinear(__arg0);
            return ___ret;
        }

        /// <summary>Calculate the current value of an animation slowing down the start phase</summary>
        /// <param name="a">pointer to an animation</param>
        /// <returns>the current value to set</returns>
        public static int LvAnimPathEaseIn(global::lvgl.LvAnimT a)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var ___ret = __Internal.LvAnimPathEaseIn(__arg0);
            return ___ret;
        }

        /// <summary>Calculate the current value of an animation slowing down the end phase</summary>
        /// <param name="a">pointer to an animation</param>
        /// <returns>the current value to set</returns>
        public static int LvAnimPathEaseOut(global::lvgl.LvAnimT a)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var ___ret = __Internal.LvAnimPathEaseOut(__arg0);
            return ___ret;
        }

        /// <summary>Calculate the current value of an animation applying an &quot;S&quot; characteristic (cosine)</summary>
        /// <param name="a">pointer to an animation</param>
        /// <returns>the current value to set</returns>
        public static int LvAnimPathEaseInOut(global::lvgl.LvAnimT a)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var ___ret = __Internal.LvAnimPathEaseInOut(__arg0);
            return ___ret;
        }

        /// <summary>Calculate the current value of an animation with overshoot at the end</summary>
        /// <param name="a">pointer to an animation</param>
        /// <returns>the current value to set</returns>
        public static int LvAnimPathOvershoot(global::lvgl.LvAnimT a)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var ___ret = __Internal.LvAnimPathOvershoot(__arg0);
            return ___ret;
        }

        /// <summary>Calculate the current value of an animation with 3 bounces</summary>
        /// <param name="a">pointer to an animation</param>
        /// <returns>the current value to set</returns>
        public static int LvAnimPathBounce(global::lvgl.LvAnimT a)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var ___ret = __Internal.LvAnimPathBounce(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Calculate the current value of an animation applying step characteristic.</para>
        /// <para>(Set end value on the end of the animation)</para>
        /// </summary>
        /// <param name="a">pointer to an animation</param>
        /// <returns>the current value to set</returns>
        public static int LvAnimPathStep(global::lvgl.LvAnimT a)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var ___ret = __Internal.LvAnimPathStep(__arg0);
            return ___ret;
        }

        /// <summary>A custom cubic bezier animation path, need to specify cubic-parameters in a-&gt;parameter.bezier3</summary>
        /// <param name="a">pointer to an animation</param>
        /// <returns>the current value to set</returns>
        public static int LvAnimPathCustomBezier3(global::lvgl.LvAnimT a)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var ___ret = __Internal.LvAnimPathCustomBezier3(__arg0);
            return ___ret;
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public enum LvRbColorT
    {
        LV_RB_COLOR_RED = 0,
        LV_RB_COLOR_BLACK = 1
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate sbyte LvRbCompareT(__IntPtr a, __IntPtr b);

    public unsafe partial class LvRbNodeT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal __IntPtr parent;
            internal __IntPtr left;
            internal __IntPtr right;
            internal global::lvgl.LvRbColorT color;
            internal __IntPtr data;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_rb_node_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvRbNodeT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvRbNodeT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvRbNodeT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvRbNodeT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvRbNodeT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvRbNodeT(native.ToPointer(), skipVTables);
        }

        internal static LvRbNodeT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvRbNodeT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvRbNodeT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvRbNodeT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvRbNodeT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvRbNodeT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvRbNodeT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvRbNodeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvRbNodeT(global::lvgl.LvRbNodeT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvRbNodeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvRbNodeT.__Internal*) __Instance) = *((global::lvgl.LvRbNodeT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvRbNodeT Parent
        {
            get
            {
                var __result0 = global::lvgl.LvRbNodeT.__GetOrCreateInstance(((__Internal*)__Instance)->parent, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->parent = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvRbNodeT Left
        {
            get
            {
                var __result0 = global::lvgl.LvRbNodeT.__GetOrCreateInstance(((__Internal*)__Instance)->left, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->left = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvRbNodeT Right
        {
            get
            {
                var __result0 = global::lvgl.LvRbNodeT.__GetOrCreateInstance(((__Internal*)__Instance)->right, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->right = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvRbColorT Color
        {
            get
            {
                return ((__Internal*)__Instance)->color;
            }

            set
            {
                ((__Internal*)__Instance)->color = value;
            }
        }

        public __IntPtr Data
        {
            get
            {
                return ((__Internal*)__Instance)->data;
            }

            set
            {
                ((__Internal*)__Instance)->data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class LvRbT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr root;
            internal __IntPtr compare;
            internal ulong size;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_rb_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvRbT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvRbT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvRbT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvRbT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvRbT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvRbT(native.ToPointer(), skipVTables);
        }

        internal static LvRbT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvRbT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvRbT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvRbT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvRbT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvRbT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvRbT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvRbT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvRbT(global::lvgl.LvRbT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvRbT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvRbT.__Internal*) __Instance) = *((global::lvgl.LvRbT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvRbNodeT Root
        {
            get
            {
                var __result0 = global::lvgl.LvRbNodeT.__GetOrCreateInstance(((__Internal*)__Instance)->root, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->root = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvRbCompareT Compare
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->compare;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvRbCompareT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvRbCompareT));
            }

            set
            {
                ((__Internal*)__Instance)->compare = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public ulong Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }
    }

    public unsafe partial class lv_rb
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_rb_init", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvRbInit(__IntPtr tree, __IntPtr compare, ulong node_size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_rb_insert", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvRbInsert(__IntPtr tree, __IntPtr key);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_rb_find", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvRbFind(__IntPtr tree, __IntPtr key);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_rb_remove_node", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvRbRemoveNode(__IntPtr tree, __IntPtr node);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_rb_remove", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvRbRemove(__IntPtr tree, __IntPtr key);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_rb_drop_node", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvRbDropNode(__IntPtr tree, __IntPtr node);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_rb_drop", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvRbDrop(__IntPtr tree, __IntPtr key);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_rb_minimum", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvRbMinimum(__IntPtr node);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_rb_maximum", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvRbMaximum(__IntPtr node);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_rb_minimum_from", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvRbMinimumFrom(__IntPtr node);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_rb_maximum_from", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvRbMaximumFrom(__IntPtr node);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_rb_destroy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvRbDestroy(__IntPtr tree);
        }

        /// <summary>
        /// <para>********************</para>
        /// <para>GLOBAL PROTOTYPES</para>
        /// <para>********************</para>
        /// </summary>
        public static bool LvRbInit(global::lvgl.LvRbT tree, global::lvgl.LvRbCompareT compare, ulong node_size)
        {
            var __arg0 = tree is null ? __IntPtr.Zero : tree.__Instance;
            var __arg1 = compare == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(compare);
            var ___ret = __Internal.LvRbInit(__arg0, __arg1, node_size);
            return ___ret;
        }

        public static global::lvgl.LvRbNodeT LvRbInsert(global::lvgl.LvRbT tree, __IntPtr key)
        {
            var __arg0 = tree is null ? __IntPtr.Zero : tree.__Instance;
            var ___ret = __Internal.LvRbInsert(__arg0, key);
            var __result0 = global::lvgl.LvRbNodeT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::lvgl.LvRbNodeT LvRbFind(global::lvgl.LvRbT tree, __IntPtr key)
        {
            var __arg0 = tree is null ? __IntPtr.Zero : tree.__Instance;
            var ___ret = __Internal.LvRbFind(__arg0, key);
            var __result0 = global::lvgl.LvRbNodeT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static __IntPtr LvRbRemoveNode(global::lvgl.LvRbT tree, global::lvgl.LvRbNodeT node)
        {
            var __arg0 = tree is null ? __IntPtr.Zero : tree.__Instance;
            var __arg1 = node is null ? __IntPtr.Zero : node.__Instance;
            var ___ret = __Internal.LvRbRemoveNode(__arg0, __arg1);
            return ___ret;
        }

        public static __IntPtr LvRbRemove(global::lvgl.LvRbT tree, __IntPtr key)
        {
            var __arg0 = tree is null ? __IntPtr.Zero : tree.__Instance;
            var ___ret = __Internal.LvRbRemove(__arg0, key);
            return ___ret;
        }

        public static bool LvRbDropNode(global::lvgl.LvRbT tree, global::lvgl.LvRbNodeT node)
        {
            var __arg0 = tree is null ? __IntPtr.Zero : tree.__Instance;
            var __arg1 = node is null ? __IntPtr.Zero : node.__Instance;
            var ___ret = __Internal.LvRbDropNode(__arg0, __arg1);
            return ___ret;
        }

        public static bool LvRbDrop(global::lvgl.LvRbT tree, __IntPtr key)
        {
            var __arg0 = tree is null ? __IntPtr.Zero : tree.__Instance;
            var ___ret = __Internal.LvRbDrop(__arg0, key);
            return ___ret;
        }

        public static global::lvgl.LvRbNodeT LvRbMinimum(global::lvgl.LvRbT node)
        {
            var __arg0 = node is null ? __IntPtr.Zero : node.__Instance;
            var ___ret = __Internal.LvRbMinimum(__arg0);
            var __result0 = global::lvgl.LvRbNodeT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::lvgl.LvRbNodeT LvRbMaximum(global::lvgl.LvRbT node)
        {
            var __arg0 = node is null ? __IntPtr.Zero : node.__Instance;
            var ___ret = __Internal.LvRbMaximum(__arg0);
            var __result0 = global::lvgl.LvRbNodeT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::lvgl.LvRbNodeT LvRbMinimumFrom(global::lvgl.LvRbNodeT node)
        {
            var __arg0 = node is null ? __IntPtr.Zero : node.__Instance;
            var ___ret = __Internal.LvRbMinimumFrom(__arg0);
            var __result0 = global::lvgl.LvRbNodeT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::lvgl.LvRbNodeT LvRbMaximumFrom(global::lvgl.LvRbNodeT node)
        {
            var __arg0 = node is null ? __IntPtr.Zero : node.__Instance;
            var ___ret = __Internal.LvRbMaximumFrom(__arg0);
            var __result0 = global::lvgl.LvRbNodeT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static void LvRbDestroy(global::lvgl.LvRbT tree)
        {
            var __arg0 = tree is null ? __IntPtr.Zero : tree.__Instance;
            __Internal.LvRbDestroy(__arg0);
        }
    }

    /// <summary>
    /// <para>Possible states of a widget.</para>
    /// <para>OR-ed values are possible</para>
    /// </summary>
    public enum LvStateT
    {
        LV_STATE_DEFAULT = 0,
        LV_STATE_CHECKED = 1,
        LV_STATE_FOCUSED = 2,
        LV_STATE_FOCUS_KEY = 4,
        LV_STATE_EDITED = 8,
        LV_STATE_HOVERED = 16,
        LV_STATE_PRESSED = 32,
        LV_STATE_SCROLLED = 64,
        LV_STATE_DISABLED = 128,
        LV_STATE_USER_1 = 4096,
        LV_STATE_USER_2 = 8192,
        LV_STATE_USER_3 = 16384,
        LV_STATE_USER_4 = 32768,
        /// <summary>Special value can be used in some functions to target all states</summary>
        LV_STATE_ANY = 65535
    }

    /// <summary>
    /// <para>The possible parts of widgets.</para>
    /// <para>The parts can be considered as the internal building block of the widgets.</para>
    /// <para>E.g. slider = background + indicator + knob</para>
    /// <para>Not all parts are used by every widget</para>
    /// </summary>
    public enum LvPartT
    {
        /// <summary>A background like rectangle</summary>
        LV_PART_MAIN = 0,
        /// <summary>The scrollbar(s)</summary>
        LV_PART_SCROLLBAR = 65536,
        /// <summary>Indicator, e.g. for slider, bar, switch, or the tick box of the checkbox</summary>
        LV_PART_INDICATOR = 131072,
        /// <summary>Like handle to grab to adjust the value</summary>
        LV_PART_KNOB = 196608,
        /// <summary>Indicate the currently selected option or section</summary>
        LV_PART_SELECTED = 262144,
        /// <summary>Used if the widget has multiple similar elements (e.g. table cells)</summary>
        LV_PART_ITEMS = 327680,
        /// <summary>Mark a specific place e.g. for text area's cursor or on a chart</summary>
        LV_PART_CURSOR = 393216,
        /// <summary>Extension point for custom widgets</summary>
        LV_PART_CUSTOM_FIRST = 524288,
        /// <summary>Special value can be used in some functions to target all parts</summary>
        LV_PART_ANY = 983040
    }

    /// <summary>
    /// <para>On/Off features controlling the object's behavior.</para>
    /// <para>OR-ed values are possible</para>
    /// </summary>
    /// <remarks>
    /// <para>Note: update obj flags corresponding properties below</para>
    /// <para>whenever add/remove flags or change bit definition of flags.</para>
    /// </remarks>
    public enum LvObjFlagT
    {
        /// <summary>Make the object hidden. (Like it wasn't there at all)</summary>
        LV_OBJ_FLAG_HIDDEN = 1,
        /// <summary>Make the object clickable by the input devices</summary>
        LV_OBJ_FLAG_CLICKABLE = 2,
        /// <summary>Add focused state to the object when clicked</summary>
        LV_OBJ_FLAG_CLICK_FOCUSABLE = 4,
        /// <summary>Toggle checked state when the object is clicked</summary>
        LV_OBJ_FLAG_CHECKABLE = 8,
        /// <summary>Make the object scrollable</summary>
        LV_OBJ_FLAG_SCROLLABLE = 16,
        /// <summary>Allow scrolling inside but with slower speed</summary>
        LV_OBJ_FLAG_SCROLL_ELASTIC = 32,
        /// <summary>Make the object scroll further when &quot;thrown&quot;</summary>
        LV_OBJ_FLAG_SCROLL_MOMENTUM = 64,
        /// <summary>Allow scrolling only one snappable children</summary>
        LV_OBJ_FLAG_SCROLL_ONE = 128,
        /// <summary>Allow propagating the horizontal scroll to a parent</summary>
        LV_OBJ_FLAG_SCROLL_CHAIN_HOR = 256,
        /// <summary>Allow propagating the vertical scroll to a parent</summary>
        LV_OBJ_FLAG_SCROLL_CHAIN_VER = 512,
        LV_OBJ_FLAG_SCROLL_CHAIN = 768,
        /// <summary>Automatically scroll object to make it visible when focused</summary>
        LV_OBJ_FLAG_SCROLL_ON_FOCUS = 1024,
        /// <summary>Allow scrolling the focused object with arrow keys</summary>
        LV_OBJ_FLAG_SCROLL_WITH_ARROW = 2048,
        /// <summary>If scroll snap is enabled on the parent it can snap to this object</summary>
        LV_OBJ_FLAG_SNAPPABLE = 4096,
        /// <summary>Keep the object pressed even if the press slid from the object</summary>
        LV_OBJ_FLAG_PRESS_LOCK = 8192,
        /// <summary>Propagate the events to the parent too</summary>
        LV_OBJ_FLAG_EVENT_BUBBLE = 16384,
        /// <summary>Propagate the gestures to the parent</summary>
        LV_OBJ_FLAG_GESTURE_BUBBLE = 32768,
        /// <summary>Allow performing more accurate hit (click) test. E.g. consider rounded corners.</summary>
        LV_OBJ_FLAG_ADV_HITTEST = 65536,
        /// <summary>Make the object position-able by the layouts</summary>
        LV_OBJ_FLAG_IGNORE_LAYOUT = 131072,
        /// <summary>Do not scroll the object when the parent scrolls and ignore layout</summary>
        LV_OBJ_FLAG_FLOATING = 262144,
        /// <summary>Send `LV_EVENT_DRAW_TASK_ADDED` events</summary>
        LV_OBJ_FLAG_SEND_DRAW_TASK_EVENTS = 524288,
        /// <summary>Do not clip the children to the parent's ext draw size</summary>
        LV_OBJ_FLAG_OVERFLOW_VISIBLE = 1048576,
        /// <summary>Start a new flex track on this item</summary>
        LV_OBJ_FLAG_FLEX_IN_NEW_TRACK = 2097152,
        /// <summary>Custom flag, free to use by layouts</summary>
        LV_OBJ_FLAG_LAYOUT_1 = 8388608,
        /// <summary>Custom flag, free to use by layouts</summary>
        LV_OBJ_FLAG_LAYOUT_2 = 16777216,
        /// <summary>Custom flag, free to use by widget</summary>
        LV_OBJ_FLAG_WIDGET_1 = 33554432,
        /// <summary>Custom flag, free to use by widget</summary>
        LV_OBJ_FLAG_WIDGET_2 = 67108864,
        /// <summary>Custom flag, free to use by user</summary>
        LV_OBJ_FLAG_USER_1 = 134217728,
        /// <summary>Custom flag, free to use by user</summary>
        LV_OBJ_FLAG_USER_2 = 268435456,
        /// <summary>Custom flag, free to use by user</summary>
        LV_OBJ_FLAG_USER_3 = 536870912,
        /// <summary>Custom flag, free to use by user</summary>
        LV_OBJ_FLAG_USER_4 = 1073741824
    }

    /// <summary>
    /// <para>Special, rarely used attributes.</para>
    /// <para>They are allocated automatically if any elements is set.</para>
    /// </summary>
    /// <summary>
    /// <para>On/Off features controlling the object's behavior.</para>
    /// <para>OR-ed values are possible</para>
    /// </summary>
    /// <remarks>
    /// <para>Note: update obj flags corresponding properties below</para>
    /// <para>whenever add/remove flags or change bit definition of flags.</para>
    /// </remarks>
    /// <summary>
    /// <para>Special, rarely used attributes.</para>
    /// <para>They are allocated automatically if any elements is set.</para>
    /// </summary>
    public unsafe partial class LvObjSpecAttrT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr children;

            [FieldOffset(8)]
            internal __IntPtr group_p;

            [FieldOffset(16)]
            internal global::lvgl.LvArrayT.__Internal event_list;

            [FieldOffset(40)]
            internal global::lvgl.LvPointT.__Internal scroll;

            [FieldOffset(48)]
            internal int ext_click_pad;

            [FieldOffset(52)]
            internal int ext_draw_size;

            [FieldOffset(56)]
            internal ushort child_cnt;

            [FieldOffset(58)]
            internal ushort scrollbar_mode;

            [FieldOffset(58)]
            internal ushort scroll_snap_x;

            [FieldOffset(58)]
            internal ushort scroll_snap_y;

            [FieldOffset(58)]
            internal ushort scroll_dir;

            [FieldOffset(59)]
            internal ushort layer_type;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_obj_spec_attr_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvObjSpecAttrT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvObjSpecAttrT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvObjSpecAttrT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvObjSpecAttrT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvObjSpecAttrT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvObjSpecAttrT(native.ToPointer(), skipVTables);
        }

        internal static LvObjSpecAttrT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvObjSpecAttrT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvObjSpecAttrT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvObjSpecAttrT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvObjSpecAttrT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvObjSpecAttrT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvObjSpecAttrT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvObjSpecAttrT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvObjSpecAttrT(global::lvgl.LvObjSpecAttrT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvObjSpecAttrT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvObjSpecAttrT.__Internal*) __Instance) = *((global::lvgl.LvObjSpecAttrT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Store the pointer of the children in an array.</summary>
        public global::lvgl.LvObjT Children
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->children, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->children = new __IntPtr(&__value);
            }
        }

        public global::lvgl.LvGroupT GroupP
        {
            get
            {
                var __result0 = global::lvgl.LvGroupT.__GetOrCreateInstance(((__Internal*)__Instance)->group_p, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->group_p = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvArrayT EventList
        {
            get
            {
                return global::lvgl.LvArrayT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->event_list));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->event_list = *(global::lvgl.LvArrayT.__Internal*) value.__Instance;
            }
        }

        /// <summary>The current X/Y scroll offset</summary>
        public global::lvgl.LvPointT Scroll
        {
            get
            {
                return global::lvgl.LvPointT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->scroll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->scroll = *(global::lvgl.LvPointT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Extra click padding in all direction</summary>
        public int ExtClickPad
        {
            get
            {
                return ((__Internal*)__Instance)->ext_click_pad;
            }

            set
            {
                ((__Internal*)__Instance)->ext_click_pad = value;
            }
        }

        /// <summary>EXTend the size in every direction for drawing.</summary>
        public int ExtDrawSize
        {
            get
            {
                return ((__Internal*)__Instance)->ext_draw_size;
            }

            set
            {
                ((__Internal*)__Instance)->ext_draw_size = value;
            }
        }

        /// <summary>Number of children</summary>
        public ushort ChildCnt
        {
            get
            {
                return ((__Internal*)__Instance)->child_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->child_cnt = value;
            }
        }

        /// <summary>How to display scrollbars, see `lv_scrollbar_mode_t`</summary>
        public ushort ScrollbarMode
        {
            get
            {
                return ((__Internal*)__Instance)->scrollbar_mode;
            }

            set
            {
                ((__Internal*)__Instance)->scrollbar_mode = value;
            }
        }

        /// <summary>Where to align the snappable children horizontally, see `lv_scroll_snap_t`</summary>
        public ushort ScrollSnapX
        {
            get
            {
                return ((__Internal*)__Instance)->scroll_snap_x;
            }

            set
            {
                ((__Internal*)__Instance)->scroll_snap_x = value;
            }
        }

        /// <summary>Where to align the snappable children vertically</summary>
        public ushort ScrollSnapY
        {
            get
            {
                return ((__Internal*)__Instance)->scroll_snap_y;
            }

            set
            {
                ((__Internal*)__Instance)->scroll_snap_y = value;
            }
        }

        /// <summary>The allowed scroll direction(s), see `lv_dir_t`</summary>
        public ushort ScrollDir
        {
            get
            {
                return ((__Internal*)__Instance)->scroll_dir;
            }

            set
            {
                ((__Internal*)__Instance)->scroll_dir = value;
            }
        }

        /// <summary>Cache the layer type here. Element of</summary>
        /// <remarks>_intermediate_layer_type_t</remarks>
        public ushort LayerType
        {
            get
            {
                return ((__Internal*)__Instance)->layer_type;
            }

            set
            {
                ((__Internal*)__Instance)->layer_type = value;
            }
        }
    }

    /// <summary>
    /// <para>Typedefs from various lvgl modules.</para>
    /// <para>They are defined here to avoid circular dependencies.</para>
    /// </summary>
    public unsafe partial class LvObjT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr class_p;

            [FieldOffset(8)]
            internal __IntPtr parent;

            [FieldOffset(16)]
            internal __IntPtr spec_attr;

            [FieldOffset(24)]
            internal __IntPtr styles;

            [FieldOffset(32)]
            internal __IntPtr user_data;

            [FieldOffset(40)]
            internal global::lvgl.LvAreaT.__Internal coords;

            [FieldOffset(56)]
            internal uint flags;

            [FieldOffset(60)]
            internal ushort state;

            [FieldOffset(62)]
            internal ushort layout_inv;

            [FieldOffset(62)]
            internal ushort readjust_scroll_after_layout;

            [FieldOffset(62)]
            internal ushort scr_layout_inv;

            [FieldOffset(62)]
            internal ushort skip_trans;

            [FieldOffset(62)]
            internal ushort style_cnt;

            [FieldOffset(63)]
            internal ushort h_layout;

            [FieldOffset(63)]
            internal ushort w_layout;

            [FieldOffset(63)]
            internal ushort is_deleting;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_obj_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvObjT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvObjT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvObjT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvObjT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvObjT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvObjT(native.ToPointer(), skipVTables);
        }

        internal static LvObjT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvObjT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvObjT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvObjT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvObjT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvObjT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvObjT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvObjT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvObjT(global::lvgl.LvObjT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvObjT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvObjT.__Internal*) __Instance) = *((global::lvgl.LvObjT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjClassT ClassP
        {
            get
            {
                var __result0 = global::lvgl.LvObjClassT.__GetOrCreateInstance(((__Internal*)__Instance)->class_p, false);
                return __result0;
            }
        }

        public global::lvgl.LvObjT Parent
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->parent, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->parent = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjSpecAttrT SpecAttr
        {
            get
            {
                var __result0 = global::lvgl.LvObjSpecAttrT.__GetOrCreateInstance(((__Internal*)__Instance)->spec_attr, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->spec_attr = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjStyleT Styles
        {
            get
            {
                var __result0 = global::lvgl.LvObjStyleT.__GetOrCreateInstance(((__Internal*)__Instance)->styles, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->styles = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }

        public global::lvgl.LvAreaT Coords
        {
            get
            {
                return global::lvgl.LvAreaT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->coords));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->coords = *(global::lvgl.LvAreaT.__Internal*) value.__Instance;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public ushort State
        {
            get
            {
                return ((__Internal*)__Instance)->state;
            }

            set
            {
                ((__Internal*)__Instance)->state = value;
            }
        }

        public ushort LayoutInv
        {
            get
            {
                return ((__Internal*)__Instance)->layout_inv;
            }

            set
            {
                ((__Internal*)__Instance)->layout_inv = value;
            }
        }

        public ushort ReadjustScrollAfterLayout
        {
            get
            {
                return ((__Internal*)__Instance)->readjust_scroll_after_layout;
            }

            set
            {
                ((__Internal*)__Instance)->readjust_scroll_after_layout = value;
            }
        }

        public ushort ScrLayoutInv
        {
            get
            {
                return ((__Internal*)__Instance)->scr_layout_inv;
            }

            set
            {
                ((__Internal*)__Instance)->scr_layout_inv = value;
            }
        }

        public ushort SkipTrans
        {
            get
            {
                return ((__Internal*)__Instance)->skip_trans;
            }

            set
            {
                ((__Internal*)__Instance)->skip_trans = value;
            }
        }

        public ushort StyleCnt
        {
            get
            {
                return ((__Internal*)__Instance)->style_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->style_cnt = value;
            }
        }

        public ushort HLayout
        {
            get
            {
                return ((__Internal*)__Instance)->h_layout;
            }

            set
            {
                ((__Internal*)__Instance)->h_layout = value;
            }
        }

        public ushort WLayout
        {
            get
            {
                return ((__Internal*)__Instance)->w_layout;
            }

            set
            {
                ((__Internal*)__Instance)->w_layout = value;
            }
        }

        public ushort IsDeleting
        {
            get
            {
                return ((__Internal*)__Instance)->is_deleting;
            }

            set
            {
                ((__Internal*)__Instance)->is_deleting = value;
            }
        }
    }

    public unsafe partial class lv_obj
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_add_flag", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjAddFlag(__IntPtr obj, uint f);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_remove_flag", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjRemoveFlag(__IntPtr obj, uint f);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_update_flag", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjUpdateFlag(__IntPtr obj, uint f, bool v);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_add_state", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjAddState(__IntPtr obj, ushort state);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_remove_state", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjRemoveState(__IntPtr obj, ushort state);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_state", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetState(__IntPtr obj, ushort state, bool v);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_has_flag", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjHasFlag(__IntPtr obj, uint f);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_has_flag_any", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjHasFlagAny(__IntPtr obj, uint f);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_state", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort LvObjGetState(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_has_state", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjHasState(__IntPtr obj, ushort state);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_group", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjGetGroup(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_allocate_spec_attr", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjAllocateSpecAttr(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_check_type", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjCheckType(__IntPtr obj, __IntPtr class_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_has_class", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjHasClass(__IntPtr obj, __IntPtr class_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_class", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjGetClass(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_is_valid", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjIsValid(__IntPtr obj);
        }

        /// <summary>Create a base object (a rectangle)</summary>
        /// <param name="parent">pointer to a parent object. If NULL then a screen will be created.</param>
        /// <returns>pointer to the new object</returns>
        public static global::lvgl.LvObjT LvObjCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvObjCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set one or more flags</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="f">OR-ed values from `lv_obj_flag_t` to set.</param>
        public static void LvObjAddFlag(global::lvgl.LvObjT obj, uint f)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjAddFlag(__arg0, f);
        }

        /// <summary>Remove one or more flags</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="f">OR-ed values from `lv_obj_flag_t` to clear.</param>
        public static void LvObjRemoveFlag(global::lvgl.LvObjT obj, uint f)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjRemoveFlag(__arg0, f);
        }

        /// <summary>Set add or remove one or more flags.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="f">OR-ed values from `lv_obj_flag_t` to update.</param>
        /// <param name="v">true: add the flags; false: remove the flags</param>
        public static void LvObjUpdateFlag(global::lvgl.LvObjT obj, uint f, bool v)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjUpdateFlag(__arg0, f, v);
        }

        /// <summary>
        /// <para>Add one or more states to the object. The other state bits will remain unchanged.</para>
        /// <para>If specified in the styles, transition animation will be started from the previous state to the current.</para>
        /// </summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="state">the states to add. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`</param>
        public static void LvObjAddState(global::lvgl.LvObjT obj, ushort state)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjAddState(__arg0, state);
        }

        /// <summary>
        /// <para>Remove one or more states to the object. The other state bits will remain unchanged.</para>
        /// <para>If specified in the styles, transition animation will be started from the previous state to the current.</para>
        /// </summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="state">the states to add. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`</param>
        public static void LvObjRemoveState(global::lvgl.LvObjT obj, ushort state)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjRemoveState(__arg0, state);
        }

        /// <summary>Add or remove one or more states to the object. The other state bits will remain unchanged.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="state">the states to add. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`</param>
        /// <param name="v">true: add the states; false: remove the states</param>
        public static void LvObjSetState(global::lvgl.LvObjT obj, ushort state, bool v)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetState(__arg0, state, v);
        }

        /// <summary>Check if a given flag or all the given flags are set on an object.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="f">the flag(s) to check (OR-ed values can be used)</param>
        /// <returns>true: all flags are set; false: not all flags are set</returns>
        public static bool LvObjHasFlag(global::lvgl.LvObjT obj, uint f)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjHasFlag(__arg0, f);
            return ___ret;
        }

        /// <summary>Check if a given flag or any of the flags are set on an object.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="f">the flag(s) to check (OR-ed values can be used)</param>
        /// <returns>true: at lest one flag flag is set; false: none of the flags are set</returns>
        public static bool LvObjHasFlagAny(global::lvgl.LvObjT obj, uint f)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjHasFlagAny(__arg0, f);
            return ___ret;
        }

        /// <summary>Get the state of an object</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the state (OR-ed values from `lv_state_t`)</returns>
        public static ushort LvObjGetState(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetState(__arg0);
            return ___ret;
        }

        /// <summary>Check if the object is in a given state or not.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="state">a state or combination of states to check</param>
        /// <returns>true: `obj` is in `state`; false: `obj` is not in `state`</returns>
        public static bool LvObjHasState(global::lvgl.LvObjT obj, ushort state)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjHasState(__arg0, state);
            return ___ret;
        }

        /// <summary>Get the group of the object</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the pointer to group of the object</returns>
        public static global::lvgl.LvGroupT LvObjGetGroup(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetGroup(__arg0);
            var __result0 = global::lvgl.LvGroupT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Allocate special data for an object if not allocated yet.</summary>
        /// <param name="obj">pointer to an object</param>
        public static void LvObjAllocateSpecAttr(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjAllocateSpecAttr(__arg0);
        }

        /// <summary>Check the type of obj.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="class_p">a class to check (e.g. `lv_slider_class`)</param>
        /// <returns>true: `class_p` is the `obj` class.</returns>
        public static bool LvObjCheckType(global::lvgl.LvObjT obj, global::lvgl.LvObjClassT class_p)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = class_p is null ? __IntPtr.Zero : class_p.__Instance;
            var ___ret = __Internal.LvObjCheckType(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>
        /// <para>Check if any object has a given class (type).</para>
        /// <para>It checks the ancestor classes too.</para>
        /// </summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="class_p">a class to check (e.g. `lv_slider_class`)</param>
        /// <returns>true: `obj` has the given class</returns>
        public static bool LvObjHasClass(global::lvgl.LvObjT obj, global::lvgl.LvObjClassT class_p)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = class_p is null ? __IntPtr.Zero : class_p.__Instance;
            var ___ret = __Internal.LvObjHasClass(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Get the class (type) of the object</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the class (type) of the object</returns>
        public static global::lvgl.LvObjClassT LvObjGetClass(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetClass(__arg0);
            var __result0 = global::lvgl.LvObjClassT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Check if any object is still &quot;alive&quot;.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>true: valid</returns>
        public static bool LvObjIsValid(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjIsValid(__arg0);
            return ___ret;
        }

        /// <summary>Make the base object's class publicly available.</summary>
        public static global::lvgl.LvObjClassT LvObjClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_obj_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>Possible options how to blend opaque drawings</summary>
    public enum LvBlendModeT
    {
        /// <summary>Simply mix according to the opacity value</summary>
        LV_BLEND_MODE_NORMAL = 0,
        /// <summary>Add the respective color channels</summary>
        LV_BLEND_MODE_ADDITIVE = 1,
        /// <summary>Subtract the foreground from the background</summary>
        LV_BLEND_MODE_SUBTRACTIVE = 2,
        /// <summary>Multiply the foreground and background</summary>
        LV_BLEND_MODE_MULTIPLY = 3
    }

    /// <summary>
    /// <para>Some options to apply decorations on texts.</para>
    /// <para>'OR'ed values can be used.</para>
    /// </summary>
    public enum LvTextDecorT
    {
        LV_TEXT_DECOR_NONE = 0,
        LV_TEXT_DECOR_UNDERLINE = 1,
        LV_TEXT_DECOR_STRIKETHROUGH = 2
    }

    /// <summary>
    /// <para>Selects on which sides border should be drawn</para>
    /// <para>'OR'ed values can be used.</para>
    /// </summary>
    public enum LvBorderSideT
    {
        LV_BORDER_SIDE_NONE = 0,
        LV_BORDER_SIDE_BOTTOM = 1,
        LV_BORDER_SIDE_TOP = 2,
        LV_BORDER_SIDE_LEFT = 4,
        LV_BORDER_SIDE_RIGHT = 8,
        LV_BORDER_SIDE_FULL = 15,
        /// <summary>FOR matrix-like objects (e.g. Button matrix)</summary>
        LV_BORDER_SIDE_INTERNAL = 16
    }

    /// <summary>The direction of the gradient.</summary>
    public enum LvGradDirT
    {
        /// <summary>No gradient (the `grad_color` property is ignored)</summary>
        LV_GRAD_DIR_NONE = 0,
        /// <summary>Vertical (top to bottom) gradient</summary>
        LV_GRAD_DIR_VER = 1,
        /// <summary>Horizontal (left to right) gradient</summary>
        LV_GRAD_DIR_HOR = 2
    }

    /// <summary>Enumeration of all built in style properties</summary>
    /// <remarks>Props are split into groups of 16. When adding a new prop to a group, ensure it does not overflow into the next one.</remarks>
    public enum LvStylePropT
    {
        LV_STYLE_PROP_INV = 0,
        LV_STYLE_WIDTH = 1,
        LV_STYLE_HEIGHT = 2,
        LV_STYLE_LENGTH = 3,
        LV_STYLE_MIN_WIDTH = 4,
        LV_STYLE_MAX_WIDTH = 5,
        LV_STYLE_MIN_HEIGHT = 6,
        LV_STYLE_MAX_HEIGHT = 7,
        LV_STYLE_X = 8,
        LV_STYLE_Y = 9,
        LV_STYLE_ALIGN = 10,
        LV_STYLE_RADIUS = 12,
        LV_STYLE_PAD_TOP = 16,
        LV_STYLE_PAD_BOTTOM = 17,
        LV_STYLE_PAD_LEFT = 18,
        LV_STYLE_PAD_RIGHT = 19,
        LV_STYLE_PAD_ROW = 20,
        LV_STYLE_PAD_COLUMN = 21,
        LV_STYLE_LAYOUT = 22,
        LV_STYLE_MARGIN_TOP = 24,
        LV_STYLE_MARGIN_BOTTOM = 25,
        LV_STYLE_MARGIN_LEFT = 26,
        LV_STYLE_MARGIN_RIGHT = 27,
        LV_STYLE_BG_COLOR = 28,
        LV_STYLE_BG_OPA = 29,
        LV_STYLE_BG_GRAD_DIR = 32,
        LV_STYLE_BG_MAIN_STOP = 33,
        LV_STYLE_BG_GRAD_STOP = 34,
        LV_STYLE_BG_GRAD_COLOR = 35,
        LV_STYLE_BG_MAIN_OPA = 36,
        LV_STYLE_BG_GRAD_OPA = 37,
        LV_STYLE_BG_GRAD = 38,
        LV_STYLE_BASE_DIR = 39,
        LV_STYLE_BG_IMAGE_SRC = 40,
        LV_STYLE_BG_IMAGE_OPA = 41,
        LV_STYLE_BG_IMAGE_RECOLOR = 42,
        LV_STYLE_BG_IMAGE_RECOLOR_OPA = 43,
        LV_STYLE_BG_IMAGE_TILED = 44,
        LV_STYLE_CLIP_CORNER = 45,
        LV_STYLE_BORDER_WIDTH = 48,
        LV_STYLE_BORDER_COLOR = 49,
        LV_STYLE_BORDER_OPA = 50,
        LV_STYLE_BORDER_SIDE = 52,
        LV_STYLE_BORDER_POST = 53,
        LV_STYLE_OUTLINE_WIDTH = 56,
        LV_STYLE_OUTLINE_COLOR = 57,
        LV_STYLE_OUTLINE_OPA = 58,
        LV_STYLE_OUTLINE_PAD = 59,
        LV_STYLE_SHADOW_WIDTH = 60,
        LV_STYLE_SHADOW_COLOR = 61,
        LV_STYLE_SHADOW_OPA = 62,
        LV_STYLE_SHADOW_OFFSET_X = 64,
        LV_STYLE_SHADOW_OFFSET_Y = 65,
        LV_STYLE_SHADOW_SPREAD = 66,
        LV_STYLE_IMAGE_OPA = 68,
        LV_STYLE_IMAGE_RECOLOR = 69,
        LV_STYLE_IMAGE_RECOLOR_OPA = 70,
        LV_STYLE_LINE_WIDTH = 72,
        LV_STYLE_LINE_DASH_WIDTH = 73,
        LV_STYLE_LINE_DASH_GAP = 74,
        LV_STYLE_LINE_ROUNDED = 75,
        LV_STYLE_LINE_COLOR = 76,
        LV_STYLE_LINE_OPA = 77,
        LV_STYLE_ARC_WIDTH = 80,
        LV_STYLE_ARC_ROUNDED = 81,
        LV_STYLE_ARC_COLOR = 82,
        LV_STYLE_ARC_OPA = 83,
        LV_STYLE_ARC_IMAGE_SRC = 84,
        LV_STYLE_TEXT_COLOR = 88,
        LV_STYLE_TEXT_OPA = 89,
        LV_STYLE_TEXT_FONT = 90,
        LV_STYLE_TEXT_LETTER_SPACE = 91,
        LV_STYLE_TEXT_LINE_SPACE = 92,
        LV_STYLE_TEXT_DECOR = 93,
        LV_STYLE_TEXT_ALIGN = 94,
        LV_STYLE_OPA = 95,
        LV_STYLE_OPA_LAYERED = 96,
        LV_STYLE_COLOR_FILTER_DSC = 97,
        LV_STYLE_COLOR_FILTER_OPA = 98,
        LV_STYLE_ANIM = 99,
        LV_STYLE_ANIM_DURATION = 100,
        LV_STYLE_TRANSITION = 102,
        LV_STYLE_BLEND_MODE = 103,
        LV_STYLE_TRANSFORM_WIDTH = 104,
        LV_STYLE_TRANSFORM_HEIGHT = 105,
        LV_STYLE_TRANSLATE_X = 106,
        LV_STYLE_TRANSLATE_Y = 107,
        LV_STYLE_TRANSFORM_SCALE_X = 108,
        LV_STYLE_TRANSFORM_SCALE_Y = 109,
        LV_STYLE_TRANSFORM_ROTATION = 110,
        LV_STYLE_TRANSFORM_PIVOT_X = 111,
        LV_STYLE_TRANSFORM_PIVOT_Y = 112,
        LV_STYLE_TRANSFORM_SKEW_X = 113,
        LV_STYLE_TRANSFORM_SKEW_Y = 114,
        LV_STYLE_BITMAP_MASK_SRC = 115,
        LV_STYLE_ROTARY_SENSITIVITY = 116,
        LV_STYLE_FLEX_FLOW = 125,
        LV_STYLE_FLEX_MAIN_PLACE = 126,
        LV_STYLE_FLEX_CROSS_PLACE = 127,
        LV_STYLE_FLEX_TRACK_PLACE = 128,
        LV_STYLE_FLEX_GROW = 129,
        LV_STYLE_GRID_COLUMN_ALIGN = 130,
        LV_STYLE_GRID_ROW_ALIGN = 131,
        LV_STYLE_GRID_ROW_DSC_ARRAY = 132,
        LV_STYLE_GRID_COLUMN_DSC_ARRAY = 133,
        LV_STYLE_GRID_CELL_COLUMN_POS = 134,
        LV_STYLE_GRID_CELL_COLUMN_SPAN = 135,
        LV_STYLE_GRID_CELL_X_ALIGN = 136,
        LV_STYLE_GRID_CELL_ROW_POS = 137,
        LV_STYLE_GRID_CELL_ROW_SPAN = 138,
        LV_STYLE_GRID_CELL_Y_ALIGN = 139,
        LV_STYLE_LAST_BUILT_IN_PROP = 140,
        LV_STYLE_NUM_BUILT_IN_PROPS = 141,
        LV_STYLE_PROP_ANY = 255,
        LV_STYLE_PROP_CONST = 255
    }

    public enum LvStyleResT
    {
        LV_STYLE_RES_NOT_FOUND = 0,
        LV_STYLE_RES_FOUND = 1
    }

    /// <summary>Descriptor of a style (a collection of properties and values).</summary>
    /// <summary>
    /// <para>A gradient stop definition.</para>
    /// <para>This matches a color and a position in a virtual 0-255 scale.</para>
    /// </summary>
    /// <summary>A descriptor of a gradient.</summary>
    /// <summary>A common type to handle all the property types in the same way.</summary>
    /// <summary>Descriptor for style transitions</summary>
    /// <summary>Descriptor of a constant style property.</summary>
    /// <summary>
    /// <para>A gradient stop definition.</para>
    /// <para>This matches a color and a position in a virtual 0-255 scale.</para>
    /// </summary>
    public unsafe partial class LvGradientStopT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 5)]
        public partial struct __Internal
        {
            internal global::lvgl.LvColorT.__Internal color;
            internal byte opa;
            internal byte frac;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_gradient_stop_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvGradientStopT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvGradientStopT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvGradientStopT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvGradientStopT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvGradientStopT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvGradientStopT(native.ToPointer(), skipVTables);
        }

        internal static LvGradientStopT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvGradientStopT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvGradientStopT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvGradientStopT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvGradientStopT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvGradientStopT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvGradientStopT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvGradientStopT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvGradientStopT(global::lvgl.LvGradientStopT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvGradientStopT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvGradientStopT.__Internal*) __Instance) = *((global::lvgl.LvGradientStopT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The stop color</summary>
        public global::lvgl.LvColorT Color
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        /// <summary>The opacity of the color</summary>
        public byte Opa
        {
            get
            {
                return ((__Internal*)__Instance)->opa;
            }

            set
            {
                ((__Internal*)__Instance)->opa = value;
            }
        }

        /// <summary>The stop position in 1/255 unit</summary>
        public byte Frac
        {
            get
            {
                return ((__Internal*)__Instance)->frac;
            }

            set
            {
                ((__Internal*)__Instance)->frac = value;
            }
        }
    }

    /// <summary>A descriptor of a gradient.</summary>
    public unsafe partial class LvGradDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal fixed byte stops[10];
            internal byte stops_count;
            internal byte dir;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_grad_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvGradDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvGradDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvGradDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvGradDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvGradDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvGradDscT(native.ToPointer(), skipVTables);
        }

        internal static LvGradDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvGradDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvGradDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvGradDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvGradDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvGradDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvGradDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvGradDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvGradDscT(global::lvgl.LvGradDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvGradDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvGradDscT.__Internal*) __Instance) = *((global::lvgl.LvGradDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>A gradient stop array</summary>
        public global::lvgl.LvGradientStopT[] Stops
        {
            get
            {
                global::lvgl.LvGradientStopT[] __value = null;
                if (((__Internal*)__Instance)->stops != null)
                {
                    __value = new global::lvgl.LvGradientStopT[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = global::lvgl.LvGradientStopT.__GetOrCreateInstance((IntPtr)((global::lvgl.LvGradientStopT.__Internal*)&(((__Internal*)__Instance)->stops[i * sizeof(global::lvgl.LvGradientStopT.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 2)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 2; i++)
                        *(global::lvgl.LvGradientStopT.__Internal*) &((__Internal*)__Instance)->stops[i * sizeof(global::lvgl.LvGradientStopT.__Internal)] = *(global::lvgl.LvGradientStopT.__Internal*)value[i].__Instance;
                }
            }
        }

        /// <summary>The number of used stops in the array</summary>
        public byte StopsCount
        {
            get
            {
                return ((__Internal*)__Instance)->stops_count;
            }

            set
            {
                ((__Internal*)__Instance)->stops_count = value;
            }
        }

        /// <summary>
        /// <para>The gradient direction.</para>
        /// <para>Any of LV_GRAD_DIR_HOR, LV_GRAD_DIR_VER, LV_GRAD_DIR_NONE</para>
        /// </summary>
        public byte Dir
        {
            get
            {
                return ((__Internal*)__Instance)->dir;
            }

            set
            {
                ((__Internal*)__Instance)->dir = value;
            }
        }
    }

    /// <summary>A common type to handle all the property types in the same way.</summary>
    public unsafe partial struct LvStyleValueT
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int num;

            [FieldOffset(0)]
            internal __IntPtr ptr;

            [FieldOffset(0)]
            internal global::lvgl.LvColorT.__Internal color;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_style_value_t@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        private LvStyleValueT.__Internal __instance;
        internal ref LvStyleValueT.__Internal __Instance => ref __instance;

        internal static LvStyleValueT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new LvStyleValueT(native.ToPointer(), skipVTables);
        }

        internal static LvStyleValueT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvStyleValueT(native, skipVTables);
        }

        private LvStyleValueT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private LvStyleValueT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::lvgl.LvStyleValueT.__Internal*) native;
        }

        public LvStyleValueT(global::lvgl.LvStyleValueT _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        /// <summary>Number integer number (opacity, enums, booleans or &quot;normal&quot; numbers)</summary>
        public int Num
        {
            get
            {
                return __instance.num;
            }

            set
            {
                __instance.num = value;
            }
        }

        /// <summary>Constant pointers  (font, cone text, etc)</summary>
        public __IntPtr Ptr
        {
            get
            {
                return __instance.ptr;
            }
        }

        /// <summary>Colors</summary>
        public global::lvgl.LvColorT Color
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(__instance.color);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Descriptor for style transitions</summary>
    public unsafe partial class LvStyleTransitionDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr props;
            internal __IntPtr user_data;
            internal __IntPtr path_xcb;
            internal uint time;
            internal uint delay;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_style_transition_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvStyleTransitionDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvStyleTransitionDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvStyleTransitionDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvStyleTransitionDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvStyleTransitionDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvStyleTransitionDscT(native.ToPointer(), skipVTables);
        }

        internal static LvStyleTransitionDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvStyleTransitionDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvStyleTransitionDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvStyleTransitionDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvStyleTransitionDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvStyleTransitionDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvStyleTransitionDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvStyleTransitionDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvStyleTransitionDscT(global::lvgl.LvStyleTransitionDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvStyleTransitionDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvStyleTransitionDscT.__Internal*) __Instance) = *((global::lvgl.LvStyleTransitionDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>An array with the properties to animate.</summary>
        public byte* Props
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->props;
            }
        }

        /// <summary>A custom user data that will be passed to the animation's user_data</summary>
        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }

        /// <summary>A path for the animation.</summary>
        public global::lvgl.LvAnimPathCbT PathXcb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->path_xcb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvAnimPathCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvAnimPathCbT));
            }

            set
            {
                ((__Internal*)__Instance)->path_xcb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Duration of the transition in [ms]</summary>
        public uint Time
        {
            get
            {
                return ((__Internal*)__Instance)->time;
            }

            set
            {
                ((__Internal*)__Instance)->time = value;
            }
        }

        /// <summary>Delay before the transition in [ms]</summary>
        public uint Delay
        {
            get
            {
                return ((__Internal*)__Instance)->delay;
            }

            set
            {
                ((__Internal*)__Instance)->delay = value;
            }
        }
    }

    /// <summary>Descriptor of a constant style property.</summary>
    public unsafe partial class LvStyleConstPropT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr prop_ptr;
            internal global::lvgl.LvStyleValueT.__Internal value;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_style_const_prop_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvStyleConstPropT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvStyleConstPropT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvStyleConstPropT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvStyleConstPropT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvStyleConstPropT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvStyleConstPropT(native.ToPointer(), skipVTables);
        }

        internal static LvStyleConstPropT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvStyleConstPropT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvStyleConstPropT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvStyleConstPropT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvStyleConstPropT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvStyleConstPropT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvStyleConstPropT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvStyleConstPropT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvStyleConstPropT(global::lvgl.LvStyleConstPropT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvStyleConstPropT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvStyleConstPropT.__Internal*) __Instance) = *((global::lvgl.LvStyleConstPropT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte* PropPtr
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->prop_ptr;
            }
        }

        public global::lvgl.LvStyleValueT Value
        {
            get
            {
                return global::lvgl.LvStyleValueT.__CreateInstance(((__Internal*)__Instance)->value);
            }

            set
            {
                ((__Internal*)__Instance)->value = value.__Instance;
            }
        }
    }

    /// <summary>Descriptor of a style (a collection of properties and values).</summary>
    public unsafe partial class LvStyleT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr values_and_props;
            internal uint has_group;
            internal byte prop_cnt;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_style_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvStyleT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvStyleT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvStyleT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvStyleT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvStyleT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvStyleT(native.ToPointer(), skipVTables);
        }

        internal static LvStyleT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvStyleT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvStyleT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvStyleT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvStyleT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvStyleT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvStyleT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvStyleT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvStyleT(global::lvgl.LvStyleT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvStyleT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvStyleT.__Internal*) __Instance) = *((global::lvgl.LvStyleT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr ValuesAndProps
        {
            get
            {
                return ((__Internal*)__Instance)->values_and_props;
            }

            set
            {
                ((__Internal*)__Instance)->values_and_props = (__IntPtr) value;
            }
        }

        public uint HasGroup
        {
            get
            {
                return ((__Internal*)__Instance)->has_group;
            }

            set
            {
                ((__Internal*)__Instance)->has_group = value;
            }
        }

        /// <summary>255 means it's a constant style</summary>
        public byte PropCnt
        {
            get
            {
                return ((__Internal*)__Instance)->prop_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->prop_cnt = value;
            }
        }
    }

    public unsafe partial class lv_style
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleInit(__IntPtr style);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_reset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleReset(__IntPtr style);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_register_prop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvStyleRegisterProp(byte flag);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_get_num_custom_props", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvStyleGetNumCustomProps();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_remove_prop", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvStyleRemoveProp(__IntPtr style, byte prop);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_prop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetProp(__IntPtr style, byte prop, global::lvgl.LvStyleValueT.__Internal value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_get_prop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvStyleGetProp(__IntPtr style, byte prop, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_transition_dsc_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleTransitionDscInit(__IntPtr tr, byte[] props, __IntPtr path_cb, uint time, uint delay, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_prop_get_default", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::lvgl.LvStyleValueT.__Internal LvStylePropGetDefault(byte prop);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_is_empty", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvStyleIsEmpty(__IntPtr style);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_style_prop_lookup_flags", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvStylePropLookupFlags(byte prop);
        }

        /// <summary>Initialize a style</summary>
        /// <param name="style">pointer to a style to initialize</param>
        /// <remarks>
        /// <para>Do not call `lv_style_init` on styles that already have some properties</para>
        /// <para>because this function won't free the used memory, just sets a default state for the style.</para>
        /// <para>In other words be sure to initialize styles only once!</para>
        /// </remarks>
        public static void LvStyleInit(global::lvgl.LvStyleT style)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleInit(__arg0);
        }

        /// <summary>Clear all properties from a style and free all allocated memories.</summary>
        /// <param name="style">pointer to a style</param>
        public static void LvStyleReset(global::lvgl.LvStyleT style)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleReset(__arg0);
        }

        /// <summary>Register a new style property for custom usage</summary>
        /// <returns>
        /// <para>a new property ID, or LV_STYLE_PROP_INV if there are no more available.</para>
        /// <para>lv_style_prop_t MY_PROP;</para>
        /// <para>static inline void lv_style_set_my_prop(lv_style_t * style, lv_color_t value) {</para>
        /// <para>lv_style_value_t v = {.color = value}; lv_style_set_prop(style, MY_PROP, v); }</para>
        /// <para>...</para>
        /// <para>MY_PROP = lv_style_register_prop();</para>
        /// <para>...</para>
        /// <para>lv_style_set_my_prop(&amp;style1, lv_palette_main(LV_PALETTE_RED));</para>
        /// </returns>
        public static byte LvStyleRegisterProp(byte flag)
        {
            var ___ret = __Internal.LvStyleRegisterProp(flag);
            return ___ret;
        }

        /// <summary>Get the number of custom properties that have been registered thus far.</summary>
        public static byte LvStyleGetNumCustomProps()
        {
            var ___ret = __Internal.LvStyleGetNumCustomProps();
            return ___ret;
        }

        /// <summary>Remove a property from a style</summary>
        /// <param name="style">pointer to a style</param>
        /// <param name="prop">a style property ORed with a state.</param>
        /// <returns>true: the property was found and removed; false: the property wasn't found</returns>
        public static bool LvStyleRemoveProp(global::lvgl.LvStyleT style, byte prop)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            var ___ret = __Internal.LvStyleRemoveProp(__arg0, prop);
            return ___ret;
        }

        /// <summary>
        /// <para>Set the value of property in a style.</para>
        /// <para>This function shouldn't be used directly by the user.</para>
        /// <para>Instead use `lv_style_set__name&gt;()`. E.g. `lv_style_set_bg_color()`</para>
        /// </summary>
        /// <param name="style">pointer to style</param>
        /// <param name="prop">the ID of a property (e.g. `LV_STYLE_BG_COLOR`)</param>
        /// <param name="value">`lv_style_value_t` variable in which a field is set according to the type of `prop`</param>
        public static void LvStyleSetProp(global::lvgl.LvStyleT style, byte prop, global::lvgl.LvStyleValueT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            var __arg2 = value.__Instance;
            __Internal.LvStyleSetProp(__arg0, prop, __arg2);
        }

        /// <summary>Get the value of a property</summary>
        /// <param name="style">pointer to a style</param>
        /// <param name="prop">the ID of a property</param>
        /// <param name="value">pointer to a `lv_style_value_t` variable to store the value</param>
        /// <returns>
        /// <para>LV_RESULT_INVALID: the property wasn't found in the style (`value` is unchanged)</para>
        /// <para>LV_RESULT_OK: the property was fond, and `value` is set accordingly</para>
        /// </returns>
        /// <remarks>For performance reasons there are no sanity check on `style`</remarks>
        public static byte LvStyleGetProp(global::lvgl.LvStyleT style, byte prop, global::lvgl.LvStyleValueT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            var ____arg2 = value.__Instance;
            var __arg2 = new __IntPtr(&____arg2);
            var ___ret = __Internal.LvStyleGetProp(__arg0, prop, __arg2);
            return ___ret;
        }

        /// <summary>Initialize a transition descriptor.</summary>
        /// <param name="tr">pointer to a transition descriptor to initialize</param>
        /// <param name="props">an array with the properties to transition. The last element must be zero.</param>
        /// <param name="path_cb">an animation path (ease) callback. If `NULL` liner path will be used.</param>
        /// <param name="time">duration of the transition in [ms]</param>
        /// <param name="delay">delay before the transition in [ms]</param>
        /// <param name="user_data">
        /// <para>any custom data that will be saved in the transition animation and will be available when `path_cb` is called</para>
        /// <para>const static lv_style_prop_t trans_props[] = { LV_STYLE_BG_OPA, LV_STYLE_BG_COLOR, 0 };</para>
        /// <para>static lv_style_transition_dsc_t trans1;</para>
        /// <para>lv_style_transition_dsc_init(&amp;trans1, trans_props, NULL, 300, 0, NULL);</para>
        /// </param>
        public static void LvStyleTransitionDscInit(global::lvgl.LvStyleTransitionDscT tr, byte[] props, global::lvgl.LvAnimPathCbT path_cb, uint time, uint delay, __IntPtr user_data)
        {
            var __arg0 = tr is null ? __IntPtr.Zero : tr.__Instance;
            var __arg2 = path_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(path_cb);
            __Internal.LvStyleTransitionDscInit(__arg0, props, __arg2, time, delay, user_data);
        }

        /// <summary>Get the default value of a property</summary>
        /// <param name="prop">the ID of a property</param>
        /// <returns>the default value</returns>
        public static global::lvgl.LvStyleValueT LvStylePropGetDefault(byte prop)
        {
            var ___ret = __Internal.LvStylePropGetDefault(prop);
            return global::lvgl.LvStyleValueT.__CreateInstance(___ret);
        }

        /// <summary>Checks if a style is empty (has no properties)</summary>
        /// <param name="style">pointer to a style</param>
        /// <returns>true if the style is empty</returns>
        public static bool LvStyleIsEmpty(global::lvgl.LvStyleT style)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            var ___ret = __Internal.LvStyleIsEmpty(__arg0);
            return ___ret;
        }

        /// <summary>Get the flags of a built-in or custom property.</summary>
        /// <param name="prop">a style property</param>
        /// <returns>the flags of the property</returns>
        public static byte LvStylePropLookupFlags(byte prop)
        {
            var ___ret = __Internal.LvStylePropLookupFlags(prop);
            return ___ret;
        }

        /// <summary>
        /// <para>***********************</para>
        /// <para>GLOBAL VARIABLES</para>
        /// <para>***********************</para>
        /// </summary>
        public static byte LvStyleConstPropIdInv
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_inv;
                return *__ptr;
            }
        }
    }

    /// <summary>The font format.</summary>
    public enum LvFontGlyphFormatT
    {
        /// <summary>Maybe not visible</summary>
        LV_FONT_GLYPH_FORMAT_NONE = 0,
        /// <summary>1 bit per pixel</summary>
        LV_FONT_GLYPH_FORMAT_A1 = 1,
        /// <summary>2 bit per pixel</summary>
        LV_FONT_GLYPH_FORMAT_A2 = 2,
        /// <summary>4 bit per pixel</summary>
        LV_FONT_GLYPH_FORMAT_A4 = 4,
        /// <summary>8 bit per pixel</summary>
        LV_FONT_GLYPH_FORMAT_A8 = 8,
        /// <summary>Image format</summary>
        LV_FONT_GLYPH_FORMAT_IMAGE = 9,
        /// <summary>Vectorial format</summary>
        LV_FONT_GLYPH_FORMAT_VECTOR = 10,
        /// <summary>SVG format</summary>
        LV_FONT_GLYPH_FORMAT_SVG = 11,
        /// <summary>Custom format</summary>
        LV_FONT_GLYPH_FORMAT_CUSTOM = 255
    }

    /// <summary>The bitmaps might be upscaled by 3 to achieve subpixel rendering.</summary>
    public enum LvFontSubpxT
    {
        LV_FONT_SUBPX_NONE = 0,
        LV_FONT_SUBPX_HOR = 1,
        LV_FONT_SUBPX_VER = 2,
        LV_FONT_SUBPX_BOTH = 3
    }

    /// <summary>Adjust letter spacing for specific character pairs.</summary>
    public enum LvFontKerningT
    {
        LV_FONT_KERNING_NORMAL = 0,
        LV_FONT_KERNING_NONE = 1
    }

    /// <summary>Describes the properties of a glyph.</summary>
    /// <summary>Describes the properties of a glyph.</summary>
    public unsafe partial class LvFontGlyphDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal __IntPtr resolved_font;
            internal ushort adv_w;
            internal ushort box_w;
            internal ushort box_h;
            internal short ofs_x;
            internal short ofs_y;
            internal byte format;
            internal byte is_placeholder;
            internal global::lvgl.LvFontGlyphDscT.Gid.__Internal gid;
            internal __IntPtr entry;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_font_glyph_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial struct Gid
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal uint index;

                [FieldOffset(0)]
                internal __IntPtr src;

                [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0<unnamed-type-gid>@lv_font_glyph_dsc_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            private Gid.__Internal __instance;
            internal ref Gid.__Internal __Instance => ref __instance;

            internal static Gid __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Gid(native.ToPointer(), skipVTables);
            }

            internal static Gid __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Gid(native, skipVTables);
            }

            private Gid(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Gid(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::lvgl.LvFontGlyphDscT.Gid.__Internal*) native;
            }

            public Gid(global::lvgl.LvFontGlyphDscT.Gid _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>Unicode code point</summary>
            public uint Index
            {
                get
                {
                    return __instance.index;
                }

                set
                {
                    __instance.index = value;
                }
            }

            /// <summary>Pointer to the source data used by image fonts</summary>
            public __IntPtr Src
            {
                get
                {
                    return __instance.src;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFontGlyphDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFontGlyphDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvFontGlyphDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvFontGlyphDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvFontGlyphDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvFontGlyphDscT(native.ToPointer(), skipVTables);
        }

        internal static LvFontGlyphDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvFontGlyphDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvFontGlyphDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvFontGlyphDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvFontGlyphDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvFontGlyphDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvFontGlyphDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFontGlyphDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvFontGlyphDscT(global::lvgl.LvFontGlyphDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFontGlyphDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvFontGlyphDscT.__Internal*) __Instance) = *((global::lvgl.LvFontGlyphDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Pointer to a font where the glyph was actually found after handling fallbacks</summary>
        public global::lvgl.LvFontT ResolvedFont
        {
            get
            {
                var __result0 = global::lvgl.LvFontT.__GetOrCreateInstance(((__Internal*)__Instance)->resolved_font, false);
                return __result0;
            }
        }

        /// <summary>The glyph needs this space. Draw the next glyph after this width.</summary>
        public ushort AdvW
        {
            get
            {
                return ((__Internal*)__Instance)->adv_w;
            }

            set
            {
                ((__Internal*)__Instance)->adv_w = value;
            }
        }

        /// <summary>Width of the glyph's bounding box</summary>
        public ushort BoxW
        {
            get
            {
                return ((__Internal*)__Instance)->box_w;
            }

            set
            {
                ((__Internal*)__Instance)->box_w = value;
            }
        }

        /// <summary>Height of the glyph's bounding box</summary>
        public ushort BoxH
        {
            get
            {
                return ((__Internal*)__Instance)->box_h;
            }

            set
            {
                ((__Internal*)__Instance)->box_h = value;
            }
        }

        /// <summary>x offset of the bounding box</summary>
        public short OfsX
        {
            get
            {
                return ((__Internal*)__Instance)->ofs_x;
            }

            set
            {
                ((__Internal*)__Instance)->ofs_x = value;
            }
        }

        /// <summary>y offset of the bounding box</summary>
        public short OfsY
        {
            get
            {
                return ((__Internal*)__Instance)->ofs_y;
            }

            set
            {
                ((__Internal*)__Instance)->ofs_y = value;
            }
        }

        /// <summary>Font format of the glyph see</summary>
        /// <remarks>_font_glyph_format_t</remarks>
        public byte Format
        {
            get
            {
                return ((__Internal*)__Instance)->format;
            }

            set
            {
                ((__Internal*)__Instance)->format = value;
            }
        }

        /// <summary>Glyph is missing. But placeholder will still be displayed</summary>
        public byte IsPlaceholder
        {
            get
            {
                return ((__Internal*)__Instance)->is_placeholder;
            }

            set
            {
                ((__Internal*)__Instance)->is_placeholder = value;
            }
        }

        /// <summary>The index of the glyph in the font file. Used by the font cache</summary>
        public global::lvgl.LvFontGlyphDscT.Gid gid
        {
            get
            {
                return global::lvgl.LvFontGlyphDscT.Gid.__CreateInstance(((__Internal*)__Instance)->gid);
            }

            set
            {
                ((__Internal*)__Instance)->gid = value.__Instance;
            }
        }

        /// <summary>The cache entry of the glyph draw data. Used by the font cache</summary>
        public global::lvgl.LvCacheEntryT Entry
        {
            get
            {
                var __result0 = global::lvgl.LvCacheEntryT.__GetOrCreateInstance(((__Internal*)__Instance)->entry, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->entry = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Describe the properties of a font</summary>
    public unsafe partial class LvFontT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr get_glyph_dsc;

            [FieldOffset(8)]
            internal __IntPtr get_glyph_bitmap;

            [FieldOffset(16)]
            internal __IntPtr release_glyph;

            [FieldOffset(24)]
            internal int line_height;

            [FieldOffset(28)]
            internal int base_line;

            [FieldOffset(32)]
            internal byte subpx;

            [FieldOffset(32)]
            internal byte kerning;

            [FieldOffset(33)]
            internal sbyte underline_position;

            [FieldOffset(34)]
            internal sbyte underline_thickness;

            [FieldOffset(40)]
            internal __IntPtr dsc;

            [FieldOffset(48)]
            internal __IntPtr fallback;

            [FieldOffset(56)]
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_font_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFontT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFontT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvFontT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvFontT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvFontT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvFontT(native.ToPointer(), skipVTables);
        }

        internal static LvFontT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvFontT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvFontT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvFontT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvFontT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvFontT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvFontT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFontT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvFontT(global::lvgl.LvFontT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFontT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvFontT.__Internal*) __Instance) = *((global::lvgl.LvFontT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Get a glyph's descriptor from a font</summary>
        public global::lvgl.Delegates.Func_bool___IntPtr___IntPtr_uint_uint GetGlyphDsc
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_glyph_dsc;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Func_bool___IntPtr___IntPtr_uint_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Func_bool___IntPtr___IntPtr_uint_uint));
            }

            set
            {
                ((__Internal*)__Instance)->get_glyph_dsc = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Get a glyph's bitmap from a font</summary>
        public global::lvgl.Delegates.Func___IntPtr___IntPtr___IntPtr GetGlyphBitmap
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_glyph_bitmap;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Func___IntPtr___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Func___IntPtr___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->get_glyph_bitmap = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Release a glyph</summary>
        public global::lvgl.Delegates.Action___IntPtr___IntPtr ReleaseGlyph
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->release_glyph;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->release_glyph = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>The real line height where any text fits</summary>
        public int LineHeight
        {
            get
            {
                return ((__Internal*)__Instance)->line_height;
            }

            set
            {
                ((__Internal*)__Instance)->line_height = value;
            }
        }

        /// <summary>Base line measured from the top of the line_height</summary>
        public int BaseLine
        {
            get
            {
                return ((__Internal*)__Instance)->base_line;
            }

            set
            {
                ((__Internal*)__Instance)->base_line = value;
            }
        }

        /// <summary>An element of `lv_font_subpx_t`</summary>
        public byte Subpx
        {
            get
            {
                return ((__Internal*)__Instance)->subpx;
            }

            set
            {
                ((__Internal*)__Instance)->subpx = value;
            }
        }

        /// <summary>An element of `lv_font_kerning_t`</summary>
        public byte Kerning
        {
            get
            {
                return ((__Internal*)__Instance)->kerning;
            }

            set
            {
                ((__Internal*)__Instance)->kerning = value;
            }
        }

        /// <summary>Distance between the top of the underline and base line (&lt;0 means below the base line)</summary>
        public sbyte UnderlinePosition
        {
            get
            {
                return ((__Internal*)__Instance)->underline_position;
            }

            set
            {
                ((__Internal*)__Instance)->underline_position = value;
            }
        }

        /// <summary>Thickness of the underline</summary>
        public sbyte UnderlineThickness
        {
            get
            {
                return ((__Internal*)__Instance)->underline_thickness;
            }

            set
            {
                ((__Internal*)__Instance)->underline_thickness = value;
            }
        }

        /// <summary>Store implementation specific or run_time data or caching here</summary>
        public __IntPtr Dsc
        {
            get
            {
                return ((__Internal*)__Instance)->dsc;
            }
        }

        /// <summary>Fallback font for missing glyph. Resolved recursively</summary>
        public global::lvgl.LvFontT Fallback
        {
            get
            {
                var __result0 = global::lvgl.LvFontT.__GetOrCreateInstance(((__Internal*)__Instance)->fallback, false);
                return __result0;
            }
        }

        /// <summary>Custom user data for font.</summary>
        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class lv_font
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_font_get_glyph_bitmap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvFontGetGlyphBitmap(__IntPtr g_dsc, __IntPtr draw_buf);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_font_get_glyph_dsc", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvFontGetGlyphDsc(__IntPtr font, __IntPtr dsc_out, uint letter, uint letter_next);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_font_glyph_release_draw_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvFontGlyphReleaseDrawData(__IntPtr g_dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_font_get_glyph_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort LvFontGetGlyphWidth(__IntPtr font, uint letter, uint letter_next);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_font_set_kerning", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvFontSetKerning(__IntPtr font, byte kerning);
        }

        /// <summary>Return with the bitmap of a font.</summary>
        /// <param name="g_dsc">the glyph descriptor including which font to use, which supply the glyph_index and the format.</param>
        /// <param name="draw_buf">a draw buffer that can be used to store the bitmap of the glyph, it's OK not to use it.</param>
        /// <returns>pointer to the glyph's data. It can be a draw buffer for bitmap fonts or an image source for imgfonts.</returns>
        /// <remarks>
        /// <para>You must call</para>
        /// <para>_font_get_glyph_dsc to get_dsc (</para>
        /// <para>_font_glyph_dsc_t) before you can call this function.</para>
        /// </remarks>
        public static __IntPtr LvFontGetGlyphBitmap(global::lvgl.LvFontGlyphDscT g_dsc, global::lvgl.LvDrawBufT draw_buf)
        {
            var __arg0 = g_dsc is null ? __IntPtr.Zero : g_dsc.__Instance;
            var __arg1 = draw_buf is null ? __IntPtr.Zero : draw_buf.__Instance;
            var ___ret = __Internal.LvFontGetGlyphBitmap(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Get the descriptor of a glyph</summary>
        /// <param name="font">pointer to font</param>
        /// <param name="dsc_out">store the result descriptor here</param>
        /// <param name="letter">a UNICODE letter code</param>
        /// <param name="letter_next">the next letter after `letter`. Used for kerning</param>
        /// <returns>
        /// <para>true: descriptor is successfully loaded into `dsc_out`.</para>
        /// <para>false: the letter was not found, no data is loaded to `dsc_out`</para>
        /// </returns>
        public static bool LvFontGetGlyphDsc(global::lvgl.LvFontT font, global::lvgl.LvFontGlyphDscT dsc_out, uint letter, uint letter_next)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            var __arg1 = dsc_out is null ? __IntPtr.Zero : dsc_out.__Instance;
            var ___ret = __Internal.LvFontGetGlyphDsc(__arg0, __arg1, letter, letter_next);
            return ___ret;
        }

        /// <summary>Release the bitmap of a font.</summary>
        /// <param name="g_dsc">the glyph descriptor including which font to use, which supply the glyph_index and the format.</param>
        /// <remarks>
        /// <para>You must call</para>
        /// <para>_font_get_glyph_dsc to get_dsc (</para>
        /// <para>_font_glyph_dsc_t) before you can call this function.</para>
        /// </remarks>
        public static void LvFontGlyphReleaseDrawData(global::lvgl.LvFontGlyphDscT g_dsc)
        {
            var __arg0 = g_dsc is null ? __IntPtr.Zero : g_dsc.__Instance;
            __Internal.LvFontGlyphReleaseDrawData(__arg0);
        }

        /// <summary>Get the width of a glyph with kerning</summary>
        /// <param name="font">pointer to a font</param>
        /// <param name="letter">a UNICODE letter</param>
        /// <param name="letter_next">the next letter after `letter`. Used for kerning</param>
        /// <returns>the width of the glyph</returns>
        public static ushort LvFontGetGlyphWidth(global::lvgl.LvFontT font, uint letter, uint letter_next)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            var ___ret = __Internal.LvFontGetGlyphWidth(__arg0, letter, letter_next);
            return ___ret;
        }

        /// <summary>Configure the use of kerning information stored in a font</summary>
        /// <param name="font">pointer to a font</param>
        /// <param name="kerning">`LV_FONT_KERNING_NORMAL` (default) or `LV_FONT_KERNING_NONE`</param>
        public static void LvFontSetKerning(global::lvgl.LvFontT font, byte kerning)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            __Internal.LvFontSetKerning(__arg0, kerning);
        }

        public static global::lvgl.LvFontT LvFontMontserrat14
        {
            get
            {
                var __ptr = (global::lvgl.LvFontT.__Internal*)global::lvgl.__Symbols.lvgl._lv_font_montserrat_14;
                return global::lvgl.LvFontT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate __IntPtr LvDrawBufMallocCb(ulong size, byte color_format);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvDrawBufFreeCb(__IntPtr draw_buf);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate __IntPtr LvDrawBufAlignCb(__IntPtr buf, byte color_format);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvDrawBufCacheOperationCb(__IntPtr draw_buf, __IntPtr area);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate uint LvDrawBufWidthToStrideCb(uint w, byte color_format);

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvDrawBufT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal global::lvgl.LvImageHeaderT.__Internal header;
            internal uint data_size;
            internal __IntPtr data;
            internal __IntPtr unaligned_data;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_buf_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawBufT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawBufT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawBufT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawBufT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawBufT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawBufT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawBufT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawBufT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawBufT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawBufT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawBufT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawBufT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawBufT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawBufT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawBufT(global::lvgl.LvDrawBufT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawBufT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawBufT.__Internal*) __Instance) = *((global::lvgl.LvDrawBufT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvImageHeaderT Header
        {
            get
            {
                return global::lvgl.LvImageHeaderT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->header));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->header = *(global::lvgl.LvImageHeaderT.__Internal*) value.__Instance;
            }
        }

        public uint DataSize
        {
            get
            {
                return ((__Internal*)__Instance)->data_size;
            }

            set
            {
                ((__Internal*)__Instance)->data_size = value;
            }
        }

        public byte* Data
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->data;
            }

            set
            {
                ((__Internal*)__Instance)->data = (__IntPtr) value;
            }
        }

        public __IntPtr UnalignedData
        {
            get
            {
                return ((__Internal*)__Instance)->unaligned_data;
            }

            set
            {
                ((__Internal*)__Instance)->unaligned_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class LvDrawBufHandlersT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal __IntPtr buf_malloc_cb;
            internal __IntPtr buf_free_cb;
            internal __IntPtr align_pointer_cb;
            internal __IntPtr invalidate_cache_cb;
            internal __IntPtr flush_cache_cb;
            internal __IntPtr width_to_stride_cb;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_buf_handlers_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawBufHandlersT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawBufHandlersT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawBufHandlersT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawBufHandlersT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawBufHandlersT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawBufHandlersT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawBufHandlersT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawBufHandlersT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawBufHandlersT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawBufHandlersT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawBufHandlersT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawBufHandlersT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawBufHandlersT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawBufHandlersT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawBufHandlersT(global::lvgl.LvDrawBufHandlersT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawBufHandlersT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawBufHandlersT.__Internal*) __Instance) = *((global::lvgl.LvDrawBufHandlersT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawBufMallocCb BufMallocCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->buf_malloc_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvDrawBufMallocCb) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvDrawBufMallocCb));
            }

            set
            {
                ((__Internal*)__Instance)->buf_malloc_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.LvDrawBufFreeCb BufFreeCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->buf_free_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvDrawBufFreeCb) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvDrawBufFreeCb));
            }

            set
            {
                ((__Internal*)__Instance)->buf_free_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.LvDrawBufAlignCb AlignPointerCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->align_pointer_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvDrawBufAlignCb) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvDrawBufAlignCb));
            }

            set
            {
                ((__Internal*)__Instance)->align_pointer_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.LvDrawBufCacheOperationCb InvalidateCacheCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->invalidate_cache_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvDrawBufCacheOperationCb) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvDrawBufCacheOperationCb));
            }

            set
            {
                ((__Internal*)__Instance)->invalidate_cache_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.LvDrawBufCacheOperationCb FlushCacheCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->flush_cache_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvDrawBufCacheOperationCb) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvDrawBufCacheOperationCb));
            }

            set
            {
                ((__Internal*)__Instance)->flush_cache_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.LvDrawBufWidthToStrideCb WidthToStrideCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->width_to_stride_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvDrawBufWidthToStrideCb) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvDrawBufWidthToStrideCb));
            }

            set
            {
                ((__Internal*)__Instance)->width_to_stride_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class lv_draw_buf
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_draw_buf_init_handlers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawBufInitHandlers();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_init_with_default_handlers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawBufInitWithDefaultHandlers(__IntPtr handlers);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_init_handlers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawBufInitHandlers(__IntPtr handlers, __IntPtr buf_malloc_cb, __IntPtr buf_free_cb, __IntPtr align_pointer_cb, __IntPtr invalidate_cache_cb, __IntPtr flush_cache_cb, __IntPtr width_to_stride_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_get_handlers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawBufGetHandlers();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawBufAlign(__IntPtr buf, byte color_format);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_align_user", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawBufAlignUser(__IntPtr handlers, __IntPtr buf, byte color_format);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_invalidate_cache", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawBufInvalidateCache(__IntPtr draw_buf, __IntPtr area);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_invalidate_cache_user", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawBufInvalidateCacheUser(__IntPtr handlers, __IntPtr draw_buf, __IntPtr area);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_flush_cache", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawBufFlushCache(__IntPtr draw_buf, __IntPtr area);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_flush_cache_user", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawBufFlushCacheUser(__IntPtr handlers, __IntPtr draw_buf, __IntPtr area);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_width_to_stride", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvDrawBufWidthToStride(uint w, byte color_format);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_width_to_stride_user", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvDrawBufWidthToStrideUser(__IntPtr handlers, uint w, byte color_format);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_clear", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawBufClear(__IntPtr draw_buf, __IntPtr a);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_copy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawBufCopy(__IntPtr dest, __IntPtr dest_area, __IntPtr src, __IntPtr src_area);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawBufCreate(uint w, uint h, byte cf, uint stride);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_create_user", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawBufCreateUser(__IntPtr handlers, uint w, uint h, byte cf, uint stride);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_dup", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawBufDup(__IntPtr draw_buf);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_dup_user", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawBufDupUser(__IntPtr handlers, __IntPtr draw_buf);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvDrawBufInit(__IntPtr draw_buf, uint w, uint h, byte cf, uint stride, __IntPtr data, uint data_size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_reshape", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawBufReshape(__IntPtr draw_buf, byte cf, uint w, uint h, uint stride);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_destroy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawBufDestroy(__IntPtr buf);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_destroy_user", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawBufDestroyUser(__IntPtr handlers, __IntPtr buf);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_goto_xy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawBufGotoXy(__IntPtr buf, uint x, uint y);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_adjust_stride", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvDrawBufAdjustStride(__IntPtr src, uint stride);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_premultiply", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvDrawBufPremultiply(__IntPtr draw_buf);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_buf_set_palette", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawBufSetPalette(__IntPtr draw_buf, byte index, global::lvgl.LvColor32T.__Internal color);
        }

        /// <summary>Called internally to initialize the draw_buf_handlers in lv_global</summary>
        public static void LvDrawBufInitHandlers()
        {
            __Internal.LvDrawBufInitHandlers();
        }

        /// <summary>Initialize the draw buffer with the default handlers.</summary>
        /// <param name="handlers">the draw buffer handlers to set</param>
        public static void LvDrawBufInitWithDefaultHandlers(global::lvgl.LvDrawBufHandlersT handlers)
        {
            var __arg0 = handlers is null ? __IntPtr.Zero : handlers.__Instance;
            __Internal.LvDrawBufInitWithDefaultHandlers(__arg0);
        }

        /// <summary>Initialize the draw buffer with given handlers.</summary>
        /// <param name="handlers">the draw buffer handlers to set</param>
        /// <param name="buf_malloc_cb">the callback to allocate memory for the buffer</param>
        /// <param name="buf_free_cb">the callback to free memory of the buffer</param>
        /// <param name="align_pointer_cb">the callback to align the buffer</param>
        /// <param name="invalidate_cache_cb">the callback to invalidate the cache of the buffer</param>
        /// <param name="width_to_stride_cb">the callback to calculate the stride based on the width and color format</param>
        public static void LvDrawBufInitHandlers(global::lvgl.LvDrawBufHandlersT handlers, global::lvgl.LvDrawBufMallocCb buf_malloc_cb, global::lvgl.LvDrawBufFreeCb buf_free_cb, global::lvgl.LvDrawBufAlignCb align_pointer_cb, global::lvgl.LvDrawBufCacheOperationCb invalidate_cache_cb, global::lvgl.LvDrawBufCacheOperationCb flush_cache_cb, global::lvgl.LvDrawBufWidthToStrideCb width_to_stride_cb)
        {
            var __arg0 = handlers is null ? __IntPtr.Zero : handlers.__Instance;
            var __arg1 = buf_malloc_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(buf_malloc_cb);
            var __arg2 = buf_free_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(buf_free_cb);
            var __arg3 = align_pointer_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(align_pointer_cb);
            var __arg4 = invalidate_cache_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(invalidate_cache_cb);
            var __arg5 = flush_cache_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(flush_cache_cb);
            var __arg6 = width_to_stride_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(width_to_stride_cb);
            __Internal.LvDrawBufInitHandlers(__arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6);
        }

        /// <summary>
        /// <para>Get the struct which holds the callbacks for draw buf management.</para>
        /// <para>Custom callback can be set on the returned value</para>
        /// </summary>
        /// <returns>pointer to the struct of handlers</returns>
        public static global::lvgl.LvDrawBufHandlersT LvDrawBufGetHandlers()
        {
            var ___ret = __Internal.LvDrawBufGetHandlers();
            var __result0 = global::lvgl.LvDrawBufHandlersT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Align the address of a buffer. The buffer needs to be large enough for the real data after alignment</summary>
        /// <param name="buf">the data to align</param>
        /// <param name="color_format">the color format of the buffer</param>
        /// <returns>the aligned buffer</returns>
        public static __IntPtr LvDrawBufAlign(__IntPtr buf, byte color_format)
        {
            var ___ret = __Internal.LvDrawBufAlign(buf, color_format);
            return ___ret;
        }

        /// <summary>Align the address of a buffer. The buffer needs to be large enough for the real data after alignment</summary>
        /// <param name="handlers">the draw buffer handlers</param>
        /// <param name="buf">the data to align</param>
        /// <param name="color_format">the color format of the buffer</param>
        /// <returns>the aligned buffer</returns>
        public static __IntPtr LvDrawBufAlignUser(global::lvgl.LvDrawBufHandlersT handlers, __IntPtr buf, byte color_format)
        {
            var __arg0 = handlers is null ? __IntPtr.Zero : handlers.__Instance;
            var ___ret = __Internal.LvDrawBufAlignUser(__arg0, buf, color_format);
            return ___ret;
        }

        /// <summary>Invalidate the cache of the buffer</summary>
        /// <param name="draw_buf">the draw buffer needs to be invalidated</param>
        /// <param name="area">
        /// <para>the area to invalidate in the buffer,</para>
        /// <para>use NULL to invalidate the whole draw buffer address range</para>
        /// </param>
        public static void LvDrawBufInvalidateCache(global::lvgl.LvDrawBufT draw_buf, global::lvgl.LvAreaT area)
        {
            var __arg0 = draw_buf is null ? __IntPtr.Zero : draw_buf.__Instance;
            var __arg1 = area is null ? __IntPtr.Zero : area.__Instance;
            __Internal.LvDrawBufInvalidateCache(__arg0, __arg1);
        }

        /// <summary>Invalidate the cache of the buffer using the user-defined callback</summary>
        /// <param name="handlers">the draw buffer handlers</param>
        /// <param name="draw_buf">the draw buffer needs to be invalidated</param>
        /// <param name="area">the area to invalidate in the buffer,</param>
        public static void LvDrawBufInvalidateCacheUser(global::lvgl.LvDrawBufHandlersT handlers, global::lvgl.LvDrawBufT draw_buf, global::lvgl.LvAreaT area)
        {
            var __arg0 = handlers is null ? __IntPtr.Zero : handlers.__Instance;
            var __arg1 = draw_buf is null ? __IntPtr.Zero : draw_buf.__Instance;
            var __arg2 = area is null ? __IntPtr.Zero : area.__Instance;
            __Internal.LvDrawBufInvalidateCacheUser(__arg0, __arg1, __arg2);
        }

        /// <summary>Flush the cache of the buffer</summary>
        /// <param name="draw_buf">the draw buffer needs to be flushed</param>
        /// <param name="area">
        /// <para>the area to flush in the buffer,</para>
        /// <para>use NULL to flush the whole draw buffer address range</para>
        /// </param>
        public static void LvDrawBufFlushCache(global::lvgl.LvDrawBufT draw_buf, global::lvgl.LvAreaT area)
        {
            var __arg0 = draw_buf is null ? __IntPtr.Zero : draw_buf.__Instance;
            var __arg1 = area is null ? __IntPtr.Zero : area.__Instance;
            __Internal.LvDrawBufFlushCache(__arg0, __arg1);
        }

        /// <summary>Flush the cache of the buffer using the user-defined callback</summary>
        /// <param name="handlers">the draw buffer handlers</param>
        /// <param name="draw_buf">the draw buffer needs to be flushed</param>
        /// <param name="area">the area to flush in the buffer,</param>
        public static void LvDrawBufFlushCacheUser(global::lvgl.LvDrawBufHandlersT handlers, global::lvgl.LvDrawBufT draw_buf, global::lvgl.LvAreaT area)
        {
            var __arg0 = handlers is null ? __IntPtr.Zero : handlers.__Instance;
            var __arg1 = draw_buf is null ? __IntPtr.Zero : draw_buf.__Instance;
            var __arg2 = area is null ? __IntPtr.Zero : area.__Instance;
            __Internal.LvDrawBufFlushCacheUser(__arg0, __arg1, __arg2);
        }

        /// <summary>Calculate the stride in bytes based on a width and color format</summary>
        /// <param name="w">the width in pixels</param>
        /// <param name="color_format">the color format</param>
        /// <returns>the stride in bytes</returns>
        public static uint LvDrawBufWidthToStride(uint w, byte color_format)
        {
            var ___ret = __Internal.LvDrawBufWidthToStride(w, color_format);
            return ___ret;
        }

        /// <summary>Calculate the stride in bytes based on a width and color format</summary>
        /// <param name="handlers">the draw buffer handlers</param>
        /// <param name="w">the width in pixels</param>
        /// <param name="color_format">the color format</param>
        /// <returns>the stride in bytes</returns>
        public static uint LvDrawBufWidthToStrideUser(global::lvgl.LvDrawBufHandlersT handlers, uint w, byte color_format)
        {
            var __arg0 = handlers is null ? __IntPtr.Zero : handlers.__Instance;
            var ___ret = __Internal.LvDrawBufWidthToStrideUser(__arg0, w, color_format);
            return ___ret;
        }

        /// <summary>Clear an area on the buffer</summary>
        /// <param name="draw_buf">pointer to draw buffer</param>
        /// <param name="a">the area to clear, or NULL to clear the whole buffer</param>
        public static void LvDrawBufClear(global::lvgl.LvDrawBufT draw_buf, global::lvgl.LvAreaT a)
        {
            var __arg0 = draw_buf is null ? __IntPtr.Zero : draw_buf.__Instance;
            var __arg1 = a is null ? __IntPtr.Zero : a.__Instance;
            __Internal.LvDrawBufClear(__arg0, __arg1);
        }

        /// <summary>Copy an area from a buffer to an other</summary>
        /// <param name="dest">pointer to the destination draw buffer</param>
        /// <param name="dest_area">the area to copy from the destination buffer, if NULL, use the whole buffer</param>
        /// <param name="src">pointer to the source draw buffer</param>
        /// <param name="src_area">the area to copy from the destination buffer, if NULL, use the whole buffer</param>
        /// <remarks>
        /// <para>`dest_area` and `src_area` should have the same width and height</para>
        /// <para>`dest` and `src` should have same color format. Color converting is not supported fow now.</para>
        /// </remarks>
        public static void LvDrawBufCopy(global::lvgl.LvDrawBufT dest, global::lvgl.LvAreaT dest_area, global::lvgl.LvDrawBufT src, global::lvgl.LvAreaT src_area)
        {
            var __arg0 = dest is null ? __IntPtr.Zero : dest.__Instance;
            var __arg1 = dest_area is null ? __IntPtr.Zero : dest_area.__Instance;
            var __arg2 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg3 = src_area is null ? __IntPtr.Zero : src_area.__Instance;
            __Internal.LvDrawBufCopy(__arg0, __arg1, __arg2, __arg3);
        }

        /// <summary>
        /// <para>Note: Eventually, lv_draw_buf_malloc/free will be kept as private.</para>
        /// <para>For now, we use `create` to distinguish with malloc.</para>
        /// </summary>
        /// <param name="w">the buffer width in pixels</param>
        /// <param name="h">the buffer height in pixels</param>
        /// <param name="cf">the color format for image</param>
        /// <param name="stride">
        /// <para>the stride in bytes for image. Use 0 for automatic calculation based on</para>
        /// <para>w, cf, and global stride alignment configuration.</para>
        /// </param>
        /// <remarks>
        /// <para>Create an draw buf by allocating struct for `lv_draw_buf_t` and allocating a buffer for it</para>
        /// <para>that meets specified requirements.</para>
        /// </remarks>
        public static global::lvgl.LvDrawBufT LvDrawBufCreate(uint w, uint h, byte cf, uint stride)
        {
            var ___ret = __Internal.LvDrawBufCreate(w, h, cf, stride);
            var __result0 = global::lvgl.LvDrawBufT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Note: Eventually, lv_draw_buf_malloc/free will be kept as private.</para>
        /// <para>For now, we use `create` to distinguish with malloc.</para>
        /// </summary>
        /// <param name="handlers">the draw buffer handlers</param>
        /// <param name="w">the buffer width in pixels</param>
        /// <param name="h">the buffer height in pixels</param>
        /// <param name="cf">the color format for image</param>
        /// <param name="stride">
        /// <para>the stride in bytes for image. Use 0 for automatic calculation based on</para>
        /// <para>w, cf, and global stride alignment configuration.</para>
        /// </param>
        /// <remarks>
        /// <para>Create an draw buf by allocating struct for `lv_draw_buf_t` and allocating a buffer for it</para>
        /// <para>that meets specified requirements.</para>
        /// </remarks>
        public static global::lvgl.LvDrawBufT LvDrawBufCreateUser(global::lvgl.LvDrawBufHandlersT handlers, uint w, uint h, byte cf, uint stride)
        {
            var __arg0 = handlers is null ? __IntPtr.Zero : handlers.__Instance;
            var ___ret = __Internal.LvDrawBufCreateUser(__arg0, w, h, cf, stride);
            var __result0 = global::lvgl.LvDrawBufT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Duplicate a draw buf with same image size, stride and color format. Copy the image data too.</summary>
        /// <param name="draw_buf">the draw buf to duplicate</param>
        /// <returns>the duplicated draw buf on success, NULL if failed</returns>
        public static global::lvgl.LvDrawBufT LvDrawBufDup(global::lvgl.LvDrawBufT draw_buf)
        {
            var __arg0 = draw_buf is null ? __IntPtr.Zero : draw_buf.__Instance;
            var ___ret = __Internal.LvDrawBufDup(__arg0);
            var __result0 = global::lvgl.LvDrawBufT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Duplicate a draw buf with same image size, stride and color format. Copy the image data too.</summary>
        /// <param name="handlers">the draw buffer handlers</param>
        /// <param name="draw_buf">the draw buf to duplicate</param>
        /// <returns>the duplicated draw buf on success, NULL if failed</returns>
        public static global::lvgl.LvDrawBufT LvDrawBufDupUser(global::lvgl.LvDrawBufHandlersT handlers, global::lvgl.LvDrawBufT draw_buf)
        {
            var __arg0 = handlers is null ? __IntPtr.Zero : handlers.__Instance;
            var __arg1 = draw_buf is null ? __IntPtr.Zero : draw_buf.__Instance;
            var ___ret = __Internal.LvDrawBufDupUser(__arg0, __arg1);
            var __result0 = global::lvgl.LvDrawBufT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Initialize a draw buf with the given buffer and parameters. Clear draw buffer flag to zero.</summary>
        /// <param name="draw_buf">the draw buf to initialize</param>
        /// <param name="w">the buffer width in pixels</param>
        /// <param name="h">the buffer height in pixels</param>
        /// <param name="cf">the color format</param>
        /// <param name="stride">the stride in bytes. Use 0 for automatic calculation</param>
        /// <param name="data">the buffer used for drawing. Unaligned `data` will be aligned internally</param>
        /// <param name="data_size">the size of the buffer in bytes</param>
        /// <returns>return LV_RESULT_OK on success, LV_RESULT_INVALID otherwise</returns>
        public static byte LvDrawBufInit(global::lvgl.LvDrawBufT draw_buf, uint w, uint h, byte cf, uint stride, __IntPtr data, uint data_size)
        {
            var __arg0 = draw_buf is null ? __IntPtr.Zero : draw_buf.__Instance;
            var ___ret = __Internal.LvDrawBufInit(__arg0, w, h, cf, stride, data, data_size);
            return ___ret;
        }

        /// <summary>
        /// <para>Keep using the existing memory, reshape the draw buffer to the given width and height.</para>
        /// <para>Return NULL if data_size is smaller than the required size.</para>
        /// </summary>
        /// <param name="draw_buf">pointer to a draw buffer</param>
        /// <param name="cf">the new color format, use 0 or LV_COLOR_FORMAT_UNKNOWN to keep using the original color format.</param>
        /// <param name="w">the new width in pixels</param>
        /// <param name="h">the new height in pixels</param>
        /// <param name="stride">the stride in bytes for image. Use 0 for automatic calculation.</param>
        public static global::lvgl.LvDrawBufT LvDrawBufReshape(global::lvgl.LvDrawBufT draw_buf, byte cf, uint w, uint h, uint stride)
        {
            var __arg0 = draw_buf is null ? __IntPtr.Zero : draw_buf.__Instance;
            var ___ret = __Internal.LvDrawBufReshape(__arg0, cf, w, h, stride);
            var __result0 = global::lvgl.LvDrawBufT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Destroy a draw buf by free the actual buffer if it's marked as LV_IMAGE_FLAGS_ALLOCATED in header.</para>
        /// <para>Then free the lv_draw_buf_t struct.</para>
        /// </summary>
        /// <param name="buf">the draw buffer to destroy</param>
        public static void LvDrawBufDestroy(global::lvgl.LvDrawBufT buf)
        {
            var __arg0 = buf is null ? __IntPtr.Zero : buf.__Instance;
            __Internal.LvDrawBufDestroy(__arg0);
        }

        /// <summary>
        /// <para>Destroy a draw buf by free the actual buffer if it's marked as LV_IMAGE_FLAGS_ALLOCATED in header.</para>
        /// <para>Then free the lv_draw_buf_t struct.</para>
        /// </summary>
        /// <param name="handlers">the draw buffer handlers</param>
        /// <param name="buf">the draw buffer to destroy</param>
        public static void LvDrawBufDestroyUser(global::lvgl.LvDrawBufHandlersT handlers, global::lvgl.LvDrawBufT buf)
        {
            var __arg0 = handlers is null ? __IntPtr.Zero : handlers.__Instance;
            var __arg1 = buf is null ? __IntPtr.Zero : buf.__Instance;
            __Internal.LvDrawBufDestroyUser(__arg0, __arg1);
        }

        /// <summary>Return pointer to the buffer at the given coordinates</summary>
        public static __IntPtr LvDrawBufGotoXy(global::lvgl.LvDrawBufT buf, uint x, uint y)
        {
            var __arg0 = buf is null ? __IntPtr.Zero : buf.__Instance;
            var ___ret = __Internal.LvDrawBufGotoXy(__arg0, x, y);
            return ___ret;
        }

        /// <summary>Adjust the stride of a draw buf in place.</summary>
        /// <param name="src">pointer to a draw buffer</param>
        /// <param name="stride">the new stride in bytes for image. Use LV_STRIDE_AUTO for automatic calculation.</param>
        /// <returns>LV_RESULT_OK: success or LV_RESULT_INVALID: failed</returns>
        public static byte LvDrawBufAdjustStride(global::lvgl.LvDrawBufT src, uint stride)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var ___ret = __Internal.LvDrawBufAdjustStride(__arg0, stride);
            return ___ret;
        }

        /// <summary>
        /// <para>Premultiply draw buffer color with alpha channel.</para>
        /// <para>If it's already premultiplied, return directly.</para>
        /// <para>Only color formats with alpha channel will be processed.</para>
        /// </summary>
        /// <returns>LV_RESULT_OK: premultiply success</returns>
        public static byte LvDrawBufPremultiply(global::lvgl.LvDrawBufT draw_buf)
        {
            var __arg0 = draw_buf is null ? __IntPtr.Zero : draw_buf.__Instance;
            var ___ret = __Internal.LvDrawBufPremultiply(__arg0);
            return ___ret;
        }

        /// <summary>Set the palette color of an indexed image. Valid only for `LV_COLOR_FORMAT_I1/2/4/8`</summary>
        /// <param name="draw_buf">pointer to an image descriptor</param>
        /// <param name="index">
        /// <para>the palette color to set:</para>
        /// <para>- for `LV_COLOR_FORMAT_I1`: 0..1</para>
        /// <para>- for `LV_COLOR_FORMAT_I2`: 0..3</para>
        /// <para>- for `LV_COLOR_FORMAT_I4`: 0..15</para>
        /// <para>- for `LV_COLOR_FORMAT_I8`: 0..255</para>
        /// </param>
        /// <param name="color">the color to set in lv_color32_t format</param>
        public static void LvDrawBufSetPalette(global::lvgl.LvDrawBufT draw_buf, byte index, global::lvgl.LvColor32T color)
        {
            var __arg0 = draw_buf is null ? __IntPtr.Zero : draw_buf.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            __Internal.LvDrawBufSetPalette(__arg0, index, *(global::lvgl.LvColor32T.__Internal*) __arg2);
        }
    }

    /// <summary>Alignments</summary>
    public enum LvAlignT
    {
        LV_ALIGN_DEFAULT = 0,
        LV_ALIGN_TOP_LEFT = 1,
        LV_ALIGN_TOP_MID = 2,
        LV_ALIGN_TOP_RIGHT = 3,
        LV_ALIGN_BOTTOM_LEFT = 4,
        LV_ALIGN_BOTTOM_MID = 5,
        LV_ALIGN_BOTTOM_RIGHT = 6,
        LV_ALIGN_LEFT_MID = 7,
        LV_ALIGN_RIGHT_MID = 8,
        LV_ALIGN_CENTER = 9,
        LV_ALIGN_OUT_TOP_LEFT = 10,
        LV_ALIGN_OUT_TOP_MID = 11,
        LV_ALIGN_OUT_TOP_RIGHT = 12,
        LV_ALIGN_OUT_BOTTOM_LEFT = 13,
        LV_ALIGN_OUT_BOTTOM_MID = 14,
        LV_ALIGN_OUT_BOTTOM_RIGHT = 15,
        LV_ALIGN_OUT_LEFT_TOP = 16,
        LV_ALIGN_OUT_LEFT_MID = 17,
        LV_ALIGN_OUT_LEFT_BOTTOM = 18,
        LV_ALIGN_OUT_RIGHT_TOP = 19,
        LV_ALIGN_OUT_RIGHT_MID = 20,
        LV_ALIGN_OUT_RIGHT_BOTTOM = 21
    }

    public enum LvDirT
    {
        LV_DIR_NONE = 0,
        LV_DIR_LEFT = 1,
        LV_DIR_RIGHT = 2,
        LV_DIR_TOP = 4,
        LV_DIR_BOTTOM = 8,
        LV_DIR_HOR = 3,
        LV_DIR_VER = 12,
        LV_DIR_ALL = 15
    }

    /// <summary>Represents a point on the screen.</summary>
    /// <summary>Represents an area of the screen.</summary>
    /// <summary>Represents a point on the screen.</summary>
    public unsafe partial class LvPointT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal int x;
            internal int y;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_point_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvPointT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvPointT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvPointT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvPointT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvPointT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvPointT(native.ToPointer(), skipVTables);
        }

        internal static LvPointT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvPointT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvPointT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvPointT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvPointT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvPointT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvPointT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvPointT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvPointT(global::lvgl.LvPointT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvPointT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvPointT.__Internal*) __Instance) = *((global::lvgl.LvPointT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public int Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }
    }

    public unsafe partial class LvPointPreciseT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal int x;
            internal int y;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_point_precise_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvPointPreciseT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvPointPreciseT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvPointPreciseT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvPointPreciseT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvPointPreciseT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvPointPreciseT(native.ToPointer(), skipVTables);
        }

        internal static LvPointPreciseT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvPointPreciseT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvPointPreciseT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvPointPreciseT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvPointPreciseT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvPointPreciseT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvPointPreciseT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvPointPreciseT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvPointPreciseT(global::lvgl.LvPointPreciseT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvPointPreciseT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvPointPreciseT.__Internal*) __Instance) = *((global::lvgl.LvPointPreciseT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public int Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }
    }

    /// <summary>Represents an area of the screen.</summary>
    public unsafe partial class LvAreaT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal int x1;
            internal int y1;
            internal int x2;
            internal int y2;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_area_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvAreaT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvAreaT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvAreaT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvAreaT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvAreaT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvAreaT(native.ToPointer(), skipVTables);
        }

        internal static LvAreaT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvAreaT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvAreaT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvAreaT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvAreaT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvAreaT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvAreaT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvAreaT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvAreaT(global::lvgl.LvAreaT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvAreaT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvAreaT.__Internal*) __Instance) = *((global::lvgl.LvAreaT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int X1
        {
            get
            {
                return ((__Internal*)__Instance)->x1;
            }

            set
            {
                ((__Internal*)__Instance)->x1 = value;
            }
        }

        public int Y1
        {
            get
            {
                return ((__Internal*)__Instance)->y1;
            }

            set
            {
                ((__Internal*)__Instance)->y1 = value;
            }
        }

        public int X2
        {
            get
            {
                return ((__Internal*)__Instance)->x2;
            }

            set
            {
                ((__Internal*)__Instance)->x2 = value;
            }
        }

        public int Y2
        {
            get
            {
                return ((__Internal*)__Instance)->y2;
            }

            set
            {
                ((__Internal*)__Instance)->y2 = value;
            }
        }
    }

    public unsafe partial class lv_area
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_area_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAreaSet(__IntPtr area_p, int x1, int y1, int x2, int y2);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_area_set_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAreaSetWidth(__IntPtr area_p, int w);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_area_set_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAreaSetHeight(__IntPtr area_p, int h);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_area_set_pos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAreaSetPos(__IntPtr area_p, int x, int y);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_area_get_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvAreaGetSize(__IntPtr area_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_area_increase", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAreaIncrease(__IntPtr area, int w_extra, int h_extra);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_area_move", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAreaMove(__IntPtr area, int x_ofs, int y_ofs);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_area_intersect", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvAreaIntersect(__IntPtr res_p, __IntPtr a1_p, __IntPtr a2_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_area_diff", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte LvAreaDiff(global::lvgl.LvAreaT.__Internal[] res_p, __IntPtr a1_p, __IntPtr a2_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_area_join", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAreaJoin(__IntPtr a_res_p, __IntPtr a1_p, __IntPtr a2_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_area_is_point_on", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvAreaIsPointOn(__IntPtr a_p, __IntPtr p_p, int radius);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_area_is_on", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvAreaIsOn(__IntPtr a1_p, __IntPtr a2_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_area_is_in", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvAreaIsIn(__IntPtr ain_p, __IntPtr aholder_p, int radius);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_area_is_out", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvAreaIsOut(__IntPtr aout_p, __IntPtr aholder_p, int radius);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_area_is_equal", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvAreaIsEqual(__IntPtr a, __IntPtr b);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_area_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAreaAlign(__IntPtr @base, __IntPtr to_align, byte align, int ofs_x, int ofs_y);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_point_transform", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvPointTransform(__IntPtr point, int angle, int scale_x, int scale_y, __IntPtr pivot, bool zoom_first);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_point_array_transform", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvPointArrayTransform(__IntPtr points, ulong count, int angle, int scale_x, int scale_y, __IntPtr pivot, bool zoom_first);
        }

        /// <summary>Initialize an area</summary>
        /// <param name="area_p">pointer to an area</param>
        /// <param name="x1">left coordinate of the area</param>
        /// <param name="y1">top coordinate of the area</param>
        /// <param name="x2">right coordinate of the area</param>
        /// <param name="y2">bottom coordinate of the area</param>
        public static void LvAreaSet(global::lvgl.LvAreaT area_p, int x1, int y1, int x2, int y2)
        {
            var __arg0 = area_p is null ? __IntPtr.Zero : area_p.__Instance;
            __Internal.LvAreaSet(__arg0, x1, y1, x2, y2);
        }

        /// <summary>Set the width of an area</summary>
        /// <param name="area_p">pointer to an area</param>
        /// <param name="w">the new width of the area (w == 1 makes x1 == x2)</param>
        public static void LvAreaSetWidth(global::lvgl.LvAreaT area_p, int w)
        {
            var __arg0 = area_p is null ? __IntPtr.Zero : area_p.__Instance;
            __Internal.LvAreaSetWidth(__arg0, w);
        }

        /// <summary>Set the height of an area</summary>
        /// <param name="area_p">pointer to an area</param>
        /// <param name="h">the new height of the area (h == 1 makes y1 == y2)</param>
        public static void LvAreaSetHeight(global::lvgl.LvAreaT area_p, int h)
        {
            var __arg0 = area_p is null ? __IntPtr.Zero : area_p.__Instance;
            __Internal.LvAreaSetHeight(__arg0, h);
        }

        /// <summary>Set the position of an area (width and height will be kept)</summary>
        /// <param name="area_p">pointer to an area</param>
        /// <param name="x">the new x coordinate of the area</param>
        /// <param name="y">the new y coordinate of the area</param>
        public static void LvAreaSetPos(global::lvgl.LvAreaT area_p, int x, int y)
        {
            var __arg0 = area_p is null ? __IntPtr.Zero : area_p.__Instance;
            __Internal.LvAreaSetPos(__arg0, x, y);
        }

        /// <summary>Return with area of an area (x * y)</summary>
        /// <param name="area_p">pointer to an area</param>
        /// <returns>size of area</returns>
        public static uint LvAreaGetSize(global::lvgl.LvAreaT area_p)
        {
            var __arg0 = area_p is null ? __IntPtr.Zero : area_p.__Instance;
            var ___ret = __Internal.LvAreaGetSize(__arg0);
            return ___ret;
        }

        public static void LvAreaIncrease(global::lvgl.LvAreaT area, int w_extra, int h_extra)
        {
            var __arg0 = area is null ? __IntPtr.Zero : area.__Instance;
            __Internal.LvAreaIncrease(__arg0, w_extra, h_extra);
        }

        public static void LvAreaMove(global::lvgl.LvAreaT area, int x_ofs, int y_ofs)
        {
            var __arg0 = area is null ? __IntPtr.Zero : area.__Instance;
            __Internal.LvAreaMove(__arg0, x_ofs, y_ofs);
        }

        /// <summary>Get the common parts of two areas</summary>
        /// <param name="res_p">pointer to an area, the result will be stored her</param>
        /// <param name="a1_p">pointer to the first area</param>
        /// <param name="a2_p">pointer to the second area</param>
        /// <returns>false: the two area has NO common parts, res_p is invalid</returns>
        public static bool LvAreaIntersect(global::lvgl.LvAreaT res_p, global::lvgl.LvAreaT a1_p, global::lvgl.LvAreaT a2_p)
        {
            var __arg0 = res_p is null ? __IntPtr.Zero : res_p.__Instance;
            var __arg1 = a1_p is null ? __IntPtr.Zero : a1_p.__Instance;
            var __arg2 = a2_p is null ? __IntPtr.Zero : a2_p.__Instance;
            var ___ret = __Internal.LvAreaIntersect(__arg0, __arg1, __arg2);
            return ___ret;
        }

        /// <summary>Get resulting sub areas after removing the common parts of two areas from the first area</summary>
        /// <param name="res_p">pointer to an array of areas with a count of 4, the resulting areas will be stored here</param>
        /// <param name="a1_p">pointer to the first area</param>
        /// <param name="a2_p">pointer to the second area</param>
        /// <returns>number of results (max 4) or -1 if no intersect</returns>
        public static sbyte LvAreaDiff(global::lvgl.LvAreaT[] res_p, global::lvgl.LvAreaT a1_p, global::lvgl.LvAreaT a2_p)
        {
            global::lvgl.LvAreaT.__Internal[] __res_p;
            if (res_p == null)
                __res_p = null;
            else
            {
                __res_p = new global::lvgl.LvAreaT.__Internal[res_p.Length];
                for (int i = 0; i < __res_p.Length; i++)
                {
                    var __element = res_p[i];
                    __res_p[i] = __element is null ? new global::lvgl.LvAreaT.__Internal() : *(global::lvgl.LvAreaT.__Internal*) __element.__Instance;
                }
            }
            var __arg0 = __res_p;
            var __arg1 = a1_p is null ? __IntPtr.Zero : a1_p.__Instance;
            var __arg2 = a2_p is null ? __IntPtr.Zero : a2_p.__Instance;
            var ___ret = __Internal.LvAreaDiff(__arg0, __arg1, __arg2);
            return ___ret;
        }

        /// <summary>Join two areas into a third which involves the other two</summary>
        /// <param name="a_res_p">pointer to an area, the result will be stored here</param>
        /// <param name="a1_p">pointer to the first area</param>
        /// <param name="a2_p">pointer to the second area</param>
        public static void LvAreaJoin(global::lvgl.LvAreaT a_res_p, global::lvgl.LvAreaT a1_p, global::lvgl.LvAreaT a2_p)
        {
            var __arg0 = a_res_p is null ? __IntPtr.Zero : a_res_p.__Instance;
            var __arg1 = a1_p is null ? __IntPtr.Zero : a1_p.__Instance;
            var __arg2 = a2_p is null ? __IntPtr.Zero : a2_p.__Instance;
            __Internal.LvAreaJoin(__arg0, __arg1, __arg2);
        }

        /// <summary>Check if a point is on an area</summary>
        /// <param name="a_p">pointer to an area</param>
        /// <param name="p_p">pointer to a point</param>
        /// <param name="radius">radius of area (e.g. for rounded rectangle)</param>
        /// <returns>false:the point is out of the area</returns>
        public static bool LvAreaIsPointOn(global::lvgl.LvAreaT a_p, global::lvgl.LvPointT p_p, int radius)
        {
            var __arg0 = a_p is null ? __IntPtr.Zero : a_p.__Instance;
            var __arg1 = p_p is null ? __IntPtr.Zero : p_p.__Instance;
            var ___ret = __Internal.LvAreaIsPointOn(__arg0, __arg1, radius);
            return ___ret;
        }

        /// <summary>Check if two area has common parts</summary>
        /// <param name="a1_p">pointer to an area.</param>
        /// <param name="a2_p">pointer to an other area</param>
        /// <returns>false: a1_p and a2_p has no common parts</returns>
        public static bool LvAreaIsOn(global::lvgl.LvAreaT a1_p, global::lvgl.LvAreaT a2_p)
        {
            var __arg0 = a1_p is null ? __IntPtr.Zero : a1_p.__Instance;
            var __arg1 = a2_p is null ? __IntPtr.Zero : a2_p.__Instance;
            var ___ret = __Internal.LvAreaIsOn(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Check if an area is fully on an other</summary>
        /// <param name="ain_p">pointer to an area which could be in 'aholder_p'</param>
        /// <param name="aholder_p">pointer to an area which could involve 'ain_p'</param>
        /// <param name="radius">radius of `aholder_p` (e.g. for rounded rectangle)</param>
        /// <returns>true: `ain_p` is fully inside `aholder_p`</returns>
        public static bool LvAreaIsIn(global::lvgl.LvAreaT ain_p, global::lvgl.LvAreaT aholder_p, int radius)
        {
            var __arg0 = ain_p is null ? __IntPtr.Zero : ain_p.__Instance;
            var __arg1 = aholder_p is null ? __IntPtr.Zero : aholder_p.__Instance;
            var ___ret = __Internal.LvAreaIsIn(__arg0, __arg1, radius);
            return ___ret;
        }

        /// <summary>Check if an area is fully out of an other</summary>
        /// <param name="aout_p">pointer to an area which could be in 'aholder_p'</param>
        /// <param name="aholder_p">pointer to an area which could involve 'ain_p'</param>
        /// <param name="radius">radius of `aholder_p` (e.g. for rounded rectangle)</param>
        /// <returns>true: `aout_p` is fully outside `aholder_p`</returns>
        public static bool LvAreaIsOut(global::lvgl.LvAreaT aout_p, global::lvgl.LvAreaT aholder_p, int radius)
        {
            var __arg0 = aout_p is null ? __IntPtr.Zero : aout_p.__Instance;
            var __arg1 = aholder_p is null ? __IntPtr.Zero : aholder_p.__Instance;
            var ___ret = __Internal.LvAreaIsOut(__arg0, __arg1, radius);
            return ___ret;
        }

        /// <summary>Check if 2 area is the same</summary>
        /// <param name="a">pointer to an area</param>
        /// <param name="b">pointer to another area</param>
        public static bool LvAreaIsEqual(global::lvgl.LvAreaT a, global::lvgl.LvAreaT b)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var __arg1 = b is null ? __IntPtr.Zero : b.__Instance;
            var ___ret = __Internal.LvAreaIsEqual(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Align an area to an other</summary>
        /// <param name="base">an area where the other will be aligned</param>
        /// <param name="to_align">the area to align</param>
        /// <param name="align">`LV_ALIGN_...`</param>
        /// <param name="ofs_x">X offset</param>
        /// <param name="ofs_y">Y offset</param>
        public static void LvAreaAlign(global::lvgl.LvAreaT @base, global::lvgl.LvAreaT to_align, byte align, int ofs_x, int ofs_y)
        {
            var __arg0 = @base is null ? __IntPtr.Zero : @base.__Instance;
            var __arg1 = to_align is null ? __IntPtr.Zero : to_align.__Instance;
            __Internal.LvAreaAlign(__arg0, __arg1, align, ofs_x, ofs_y);
        }

        /// <summary>Transform a point</summary>
        /// <param name="point">pointer to a point</param>
        /// <param name="angle">angle with 0.1 resolutions (123 means 12.3&#176;)</param>
        /// <param name="scale_x">horizontal zoom, 256 means 100%</param>
        /// <param name="scale_y">vertical zoom, 256 means 100%</param>
        /// <param name="pivot">pointer to the pivot point of the transformation</param>
        /// <param name="zoom_first">true: zoom first and rotate after that; else: opssoite order</param>
        public static void LvPointTransform(global::lvgl.LvPointT point, int angle, int scale_x, int scale_y, global::lvgl.LvPointT pivot, bool zoom_first)
        {
            var __arg0 = point is null ? __IntPtr.Zero : point.__Instance;
            var __arg4 = pivot is null ? __IntPtr.Zero : pivot.__Instance;
            __Internal.LvPointTransform(__arg0, angle, scale_x, scale_y, __arg4, zoom_first);
        }

        /// <summary>Transform an array of points</summary>
        /// <param name="points">pointer to an array of points</param>
        /// <param name="count">number of points in the array</param>
        /// <param name="angle">angle with 0.1 resolutions (123 means 12.3&#176;)</param>
        /// <param name="scale_x">horizontal zoom, 256 means 100%</param>
        /// <param name="scale_y">vertical zoom, 256 means 100%</param>
        /// <param name="pivot">pointer to the pivot point of the transformation</param>
        /// <param name="zoom_first">true: zoom first and rotate after that; else: opssoite order</param>
        public static void LvPointArrayTransform(global::lvgl.LvPointT points, ulong count, int angle, int scale_x, int scale_y, global::lvgl.LvPointT pivot, bool zoom_first)
        {
            var __arg0 = points is null ? __IntPtr.Zero : points.__Instance;
            var __arg5 = pivot is null ? __IntPtr.Zero : pivot.__Instance;
            __Internal.LvPointArrayTransform(__arg0, count, angle, scale_x, scale_y, __arg5, zoom_first);
        }
    }

    /// <summary>Opacity percentages.</summary>
    public enum LvOpaT
    {
        LV_OPA_TRANSP = 0,
        LV_OPA_0 = 0,
        LV_OPA_10 = 25,
        LV_OPA_20 = 51,
        LV_OPA_30 = 76,
        LV_OPA_40 = 102,
        LV_OPA_50 = 127,
        LV_OPA_60 = 153,
        LV_OPA_70 = 178,
        LV_OPA_80 = 204,
        LV_OPA_90 = 229,
        LV_OPA_100 = 255,
        LV_OPA_COVER = 255
    }

    public enum LvColorFormatT
    {
        LV_COLOR_FORMAT_UNKNOWN = 0,
        LV_COLOR_FORMAT_RAW = 1,
        LV_COLOR_FORMAT_RAW_ALPHA = 2,
        LV_COLOR_FORMAT_L8 = 6,
        LV_COLOR_FORMAT_I1 = 7,
        LV_COLOR_FORMAT_I2 = 8,
        LV_COLOR_FORMAT_I4 = 9,
        LV_COLOR_FORMAT_I8 = 10,
        LV_COLOR_FORMAT_A8 = 14,
        LV_COLOR_FORMAT_RGB565 = 18,
        /// <summary>Not supported by sw renderer yet.</summary>
        LV_COLOR_FORMAT_ARGB8565 = 19,
        /// <summary>Color array followed by Alpha array</summary>
        LV_COLOR_FORMAT_RGB565A8 = 20,
        /// <summary>L8 with alpha &gt;</summary>
        LV_COLOR_FORMAT_AL88 = 21,
        LV_COLOR_FORMAT_RGB888 = 15,
        LV_COLOR_FORMAT_ARGB8888 = 16,
        LV_COLOR_FORMAT_XRGB8888 = 17,
        LV_COLOR_FORMAT_A1 = 11,
        LV_COLOR_FORMAT_A2 = 12,
        LV_COLOR_FORMAT_A4 = 13,
        LV_COLOR_FORMAT_YUV_START = 32,
        LV_COLOR_FORMAT_I420 = 32,
        LV_COLOR_FORMAT_I422 = 33,
        LV_COLOR_FORMAT_I444 = 34,
        LV_COLOR_FORMAT_I400 = 35,
        LV_COLOR_FORMAT_NV21 = 36,
        LV_COLOR_FORMAT_NV12 = 37,
        LV_COLOR_FORMAT_YUY2 = 38,
        LV_COLOR_FORMAT_UYVY = 39,
        LV_COLOR_FORMAT_YUV_END = 39,
        LV_COLOR_FORMAT_NATIVE = 17,
        LV_COLOR_FORMAT_NATIVE_WITH_ALPHA = 16
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvColorT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 3)]
        public partial struct __Internal
        {
            internal byte blue;
            internal byte green;
            internal byte red;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_color_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvColorT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvColorT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvColorT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvColorT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvColorT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvColorT(native.ToPointer(), skipVTables);
        }

        internal static LvColorT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvColorT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvColorT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvColorT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvColorT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvColorT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvColorT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvColorT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvColorT(global::lvgl.LvColorT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvColorT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvColorT.__Internal*) __Instance) = *((global::lvgl.LvColorT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte Blue
        {
            get
            {
                return ((__Internal*)__Instance)->blue;
            }

            set
            {
                ((__Internal*)__Instance)->blue = value;
            }
        }

        public byte Green
        {
            get
            {
                return ((__Internal*)__Instance)->green;
            }

            set
            {
                ((__Internal*)__Instance)->green = value;
            }
        }

        public byte Red
        {
            get
            {
                return ((__Internal*)__Instance)->red;
            }

            set
            {
                ((__Internal*)__Instance)->red = value;
            }
        }
    }

    public unsafe partial class LvColor16T : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 2)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ushort blue;

            [FieldOffset(0)]
            internal ushort green;

            [FieldOffset(1)]
            internal ushort red;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_color16_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvColor16T> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvColor16T>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvColor16T managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvColor16T managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvColor16T __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvColor16T(native.ToPointer(), skipVTables);
        }

        internal static LvColor16T __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvColor16T)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvColor16T __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvColor16T(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvColor16T(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvColor16T(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvColor16T()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvColor16T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvColor16T(global::lvgl.LvColor16T _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvColor16T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvColor16T.__Internal*) __Instance) = *((global::lvgl.LvColor16T.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Blue
        {
            get
            {
                return ((__Internal*)__Instance)->blue;
            }

            set
            {
                ((__Internal*)__Instance)->blue = value;
            }
        }

        public ushort Green
        {
            get
            {
                return ((__Internal*)__Instance)->green;
            }

            set
            {
                ((__Internal*)__Instance)->green = value;
            }
        }

        public ushort Red
        {
            get
            {
                return ((__Internal*)__Instance)->red;
            }

            set
            {
                ((__Internal*)__Instance)->red = value;
            }
        }
    }

    public unsafe partial class LvColor32T : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal byte blue;
            internal byte green;
            internal byte red;
            internal byte alpha;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_color32_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvColor32T> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvColor32T>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvColor32T managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvColor32T managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvColor32T __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvColor32T(native.ToPointer(), skipVTables);
        }

        internal static LvColor32T __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvColor32T)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvColor32T __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvColor32T(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvColor32T(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvColor32T(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvColor32T()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvColor32T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvColor32T(global::lvgl.LvColor32T _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvColor32T.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvColor32T.__Internal*) __Instance) = *((global::lvgl.LvColor32T.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte Blue
        {
            get
            {
                return ((__Internal*)__Instance)->blue;
            }

            set
            {
                ((__Internal*)__Instance)->blue = value;
            }
        }

        public byte Green
        {
            get
            {
                return ((__Internal*)__Instance)->green;
            }

            set
            {
                ((__Internal*)__Instance)->green = value;
            }
        }

        public byte Red
        {
            get
            {
                return ((__Internal*)__Instance)->red;
            }

            set
            {
                ((__Internal*)__Instance)->red = value;
            }
        }

        public byte Alpha
        {
            get
            {
                return ((__Internal*)__Instance)->alpha;
            }

            set
            {
                ((__Internal*)__Instance)->alpha = value;
            }
        }
    }

    public unsafe partial class LvColorHsvT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal ushort h;
            internal byte s;
            internal byte v;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_color_hsv_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvColorHsvT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvColorHsvT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvColorHsvT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvColorHsvT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvColorHsvT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvColorHsvT(native.ToPointer(), skipVTables);
        }

        internal static LvColorHsvT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvColorHsvT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvColorHsvT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvColorHsvT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvColorHsvT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvColorHsvT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvColorHsvT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvColorHsvT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvColorHsvT(global::lvgl.LvColorHsvT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvColorHsvT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvColorHsvT.__Internal*) __Instance) = *((global::lvgl.LvColorHsvT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort H
        {
            get
            {
                return ((__Internal*)__Instance)->h;
            }

            set
            {
                ((__Internal*)__Instance)->h = value;
            }
        }

        public byte S
        {
            get
            {
                return ((__Internal*)__Instance)->s;
            }

            set
            {
                ((__Internal*)__Instance)->s = value;
            }
        }

        public byte V
        {
            get
            {
                return ((__Internal*)__Instance)->v;
            }

            set
            {
                ((__Internal*)__Instance)->v = value;
            }
        }
    }

    public unsafe partial class LvColor16aT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2)]
        public partial struct __Internal
        {
            internal byte lumi;
            internal byte alpha;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_color16a_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvColor16aT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvColor16aT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvColor16aT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvColor16aT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvColor16aT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvColor16aT(native.ToPointer(), skipVTables);
        }

        internal static LvColor16aT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvColor16aT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvColor16aT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvColor16aT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvColor16aT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvColor16aT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvColor16aT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvColor16aT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvColor16aT(global::lvgl.LvColor16aT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvColor16aT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvColor16aT.__Internal*) __Instance) = *((global::lvgl.LvColor16aT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte Lumi
        {
            get
            {
                return ((__Internal*)__Instance)->lumi;
            }

            set
            {
                ((__Internal*)__Instance)->lumi = value;
            }
        }

        public byte Alpha
        {
            get
            {
                return ((__Internal*)__Instance)->alpha;
            }

            set
            {
                ((__Internal*)__Instance)->alpha = value;
            }
        }
    }

    public unsafe partial class lv_color
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_color_format_get_bpp", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvColorFormatGetBpp(byte cf);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_color_format_has_alpha", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvColorFormatHasAlpha(byte src_cf);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_color_to_32", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::lvgl.LvColor32T.__Internal LvColorTo32(__IntPtr color, byte opa);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_color_to_u16", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort LvColorToU16(__IntPtr color);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_color_to_u32", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvColorToU32(__IntPtr color);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_color_lighten", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvColorLighten(__IntPtr @return, __IntPtr c, byte lvl);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_color_darken", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvColorDarken(__IntPtr @return, __IntPtr c, byte lvl);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_color_hsv_to_rgb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvColorHsvToRgb(__IntPtr @return, ushort h, byte s, byte v);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_color_rgb_to_hsv", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::lvgl.LvColorHsvT.__Internal LvColorRgbToHsv(byte r8, byte g8, byte b8);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_color_to_hsv", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::lvgl.LvColorHsvT.__Internal LvColorToHsv(__IntPtr color);
        }

        /// <summary>Get the pixel size of a color format in bits, bpp</summary>
        /// <param name="src_cf">a color format (`LV_COLOR_FORMAT_...`)</param>
        /// <returns>the pixel size in bits</returns>
        public static byte LvColorFormatGetBpp(byte cf)
        {
            var ___ret = __Internal.LvColorFormatGetBpp(cf);
            return ___ret;
        }

        /// <summary>Check if a color format has alpha channel or not</summary>
        /// <param name="src_cf">a color format (`LV_COLOR_FORMAT_...`)</param>
        /// <returns>true: has alpha channel; false: doesn't have alpha channel</returns>
        public static bool LvColorFormatHasAlpha(byte src_cf)
        {
            var ___ret = __Internal.LvColorFormatHasAlpha(src_cf);
            return ___ret;
        }

        /// <summary>Create an ARGB8888 color from RGB888 + alpha</summary>
        /// <param name="color">an RGB888 color</param>
        /// <param name="opa">the alpha value</param>
        /// <returns>the ARGB8888 color</returns>
        public static global::lvgl.LvColor32T LvColorTo32(global::lvgl.LvColorT color, byte opa)
        {
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg0 = color.__Instance;
            var ___ret = __Internal.LvColorTo32(__arg0, opa);
            return global::lvgl.LvColor32T.__CreateInstance(___ret);
        }

        /// <summary>Convert am RGB888 color to RGB565 stored in `uint16_t`</summary>
        /// <param name="color">and RGB888 color</param>
        /// <returns>`color` as RGB565 on `uin16_t`</returns>
        public static ushort LvColorToU16(global::lvgl.LvColorT color)
        {
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg0 = color.__Instance;
            var ___ret = __Internal.LvColorToU16(__arg0);
            return ___ret;
        }

        /// <summary>Convert am RGB888 color to XRGB8888 stored in `uint32_t`</summary>
        /// <param name="color">and RGB888 color</param>
        /// <returns>`color` as XRGB8888 on `uin32_t` (the alpha channel is always set to 0xFF)</returns>
        public static uint LvColorToU32(global::lvgl.LvColorT color)
        {
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg0 = color.__Instance;
            var ___ret = __Internal.LvColorToU32(__arg0);
            return ___ret;
        }

        /// <summary>Mix white to a color</summary>
        /// <param name="c">the base color</param>
        /// <param name="lvl">the intensity of white (0: no change, 255: fully white)</param>
        /// <returns>the mixed color</returns>
        public static global::lvgl.LvColorT LvColorLighten(global::lvgl.LvColorT c, byte lvl)
        {
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg0 = c.__Instance;
            var ___ret = new global::lvgl.LvColorT.__Internal();
            __Internal.LvColorLighten(new IntPtr(&___ret), __arg0, lvl);
            return global::lvgl.LvColorT.__CreateInstance(___ret);
        }

        /// <summary>Mix black to a color</summary>
        /// <param name="c">the base color</param>
        /// <param name="lvl">the intensity of black (0: no change, 255: fully black)</param>
        /// <returns>the mixed color</returns>
        public static global::lvgl.LvColorT LvColorDarken(global::lvgl.LvColorT c, byte lvl)
        {
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg0 = c.__Instance;
            var ___ret = new global::lvgl.LvColorT.__Internal();
            __Internal.LvColorDarken(new IntPtr(&___ret), __arg0, lvl);
            return global::lvgl.LvColorT.__CreateInstance(___ret);
        }

        /// <summary>Convert a HSV color to RGB</summary>
        /// <param name="h">hue [0..359]</param>
        /// <param name="s">saturation [0..100]</param>
        /// <param name="v">value [0..100]</param>
        /// <returns>the given RGB color in RGB (with LV_COLOR_DEPTH depth)</returns>
        public static global::lvgl.LvColorT LvColorHsvToRgb(ushort h, byte s, byte v)
        {
            var ___ret = new global::lvgl.LvColorT.__Internal();
            __Internal.LvColorHsvToRgb(new IntPtr(&___ret), h, s, v);
            return global::lvgl.LvColorT.__CreateInstance(___ret);
        }

        /// <summary>Convert a 32-bit RGB color to HSV</summary>
        /// <param name="r8">8-bit red</param>
        /// <param name="g8">8-bit green</param>
        /// <param name="b8">8-bit blue</param>
        /// <returns>the given RGB color in HSV</returns>
        public static global::lvgl.LvColorHsvT LvColorRgbToHsv(byte r8, byte g8, byte b8)
        {
            var ___ret = __Internal.LvColorRgbToHsv(r8, g8, b8);
            return global::lvgl.LvColorHsvT.__CreateInstance(___ret);
        }

        /// <summary>Convert a color to HSV</summary>
        /// <param name="color">color</param>
        /// <returns>the given color in HSV</returns>
        public static global::lvgl.LvColorHsvT LvColorToHsv(global::lvgl.LvColorT color)
        {
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg0 = color.__Instance;
            var ___ret = __Internal.LvColorToHsv(__arg0);
            return global::lvgl.LvColorHsvT.__CreateInstance(___ret);
        }

        public static global::lvgl.LvColorFilterDscT LvColorFilterShade
        {
            get
            {
                var __ptr = (global::lvgl.LvColorFilterDscT.__Internal*)global::lvgl.__Symbols.lvgl._lv_color_filter_shade;
                return global::lvgl.LvColorFilterDscT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public enum LvPaletteT
    {
        LV_PALETTE_RED = 0,
        LV_PALETTE_PINK = 1,
        LV_PALETTE_PURPLE = 2,
        LV_PALETTE_DEEP_PURPLE = 3,
        LV_PALETTE_INDIGO = 4,
        LV_PALETTE_BLUE = 5,
        LV_PALETTE_LIGHT_BLUE = 6,
        LV_PALETTE_CYAN = 7,
        LV_PALETTE_TEAL = 8,
        LV_PALETTE_GREEN = 9,
        LV_PALETTE_LIGHT_GREEN = 10,
        LV_PALETTE_LIME = 11,
        LV_PALETTE_YELLOW = 12,
        LV_PALETTE_AMBER = 13,
        LV_PALETTE_ORANGE = 14,
        LV_PALETTE_DEEP_ORANGE = 15,
        LV_PALETTE_BROWN = 16,
        LV_PALETTE_BLUE_GREY = 17,
        LV_PALETTE_GREY = 18,
        LV_PALETTE_LAST = 19,
        LV_PALETTE_NONE = 255
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class lv_palette
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_palette_main", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvPaletteMain(__IntPtr @return, global::lvgl.LvPaletteT p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_palette_lighten", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvPaletteLighten(__IntPtr @return, global::lvgl.LvPaletteT p, byte lvl);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_palette_darken", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvPaletteDarken(__IntPtr @return, global::lvgl.LvPaletteT p, byte lvl);
        }

        public static global::lvgl.LvColorT LvPaletteMain(global::lvgl.LvPaletteT p)
        {
            var ___ret = new global::lvgl.LvColorT.__Internal();
            __Internal.LvPaletteMain(new IntPtr(&___ret), p);
            return global::lvgl.LvColorT.__CreateInstance(___ret);
        }

        public static global::lvgl.LvColorT LvPaletteLighten(global::lvgl.LvPaletteT p, byte lvl)
        {
            var ___ret = new global::lvgl.LvColorT.__Internal();
            __Internal.LvPaletteLighten(new IntPtr(&___ret), p, lvl);
            return global::lvgl.LvColorT.__CreateInstance(___ret);
        }

        public static global::lvgl.LvColorT LvPaletteDarken(global::lvgl.LvPaletteT p, byte lvl)
        {
            var ___ret = new global::lvgl.LvColorT.__Internal();
            __Internal.LvPaletteDarken(new IntPtr(&___ret), p, lvl);
            return global::lvgl.LvColorT.__CreateInstance(___ret);
        }
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::lvgl.LvColorT.__Internal LvColorFilterCbT(__IntPtr __0, global::lvgl.LvColorT.__Internal __1, byte __2);

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvColorFilterDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr filter_cb;
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_color_filter_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvColorFilterDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvColorFilterDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvColorFilterDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvColorFilterDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvColorFilterDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvColorFilterDscT(native.ToPointer(), skipVTables);
        }

        internal static LvColorFilterDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvColorFilterDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvColorFilterDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvColorFilterDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvColorFilterDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvColorFilterDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvColorFilterDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvColorFilterDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvColorFilterDscT(global::lvgl.LvColorFilterDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvColorFilterDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvColorFilterDscT.__Internal*) __Instance) = *((global::lvgl.LvColorFilterDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvColorFilterCbT FilterCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->filter_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvColorFilterCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvColorFilterCbT));
            }

            set
            {
                ((__Internal*)__Instance)->filter_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    [Flags]
    public enum LvImageFlagsT
    {
        /// <summary>
        /// <para>For RGB map of the image data, mark if it's pre-multiplied with alpha.</para>
        /// <para>For indexed image, this bit indicated palette data is pre-multiplied with alpha.</para>
        /// </summary>
        LV_IMAGE_FLAGS_PREMULTIPLIED = 1,
        /// <summary>
        /// <para>The image data is compressed, so decoder needs to decode image firstly.</para>
        /// <para>If this flag is set, the whole image will be decompressed upon decode, and</para>
        /// <para>`get_area_cb` won't be necessary.</para>
        /// </summary>
        LV_IMAGE_FLAGS_COMPRESSED = 8,
        /// <summary>The image is allocated from heap, thus should be freed after use.</summary>
        LV_IMAGE_FLAGS_ALLOCATED = 16,
        /// <summary>
        /// <para>If the image data is malloced and can be processed in place.</para>
        /// <para>In image decoder post processing, this flag means we modify it in-place.</para>
        /// </summary>
        LV_IMAGE_FLAGS_MODIFIABLE = 32,
        /// <summary>Flags reserved for user, lvgl won't use these bits.</summary>
        LV_IMAGE_FLAGS_USER1 = 256,
        /// <summary>Flags reserved for user, lvgl won't use these bits.</summary>
        LV_IMAGE_FLAGS_USER2 = 512,
        /// <summary>Flags reserved for user, lvgl won't use these bits.</summary>
        LV_IMAGE_FLAGS_USER3 = 1024,
        /// <summary>Flags reserved for user, lvgl won't use these bits.</summary>
        LV_IMAGE_FLAGS_USER4 = 2048,
        /// <summary>Flags reserved for user, lvgl won't use these bits.</summary>
        LV_IMAGE_FLAGS_USER5 = 4096,
        /// <summary>Flags reserved for user, lvgl won't use these bits.</summary>
        LV_IMAGE_FLAGS_USER6 = 8192,
        /// <summary>Flags reserved for user, lvgl won't use these bits.</summary>
        LV_IMAGE_FLAGS_USER7 = 16384,
        /// <summary>Flags reserved for user, lvgl won't use these bits.</summary>
        LV_IMAGE_FLAGS_USER8 = 32768
    }

    public enum LvImageCompressT
    {
        LV_IMAGE_COMPRESS_NONE = 0,
        LV_IMAGE_COMPRESS_RLE = 1,
        LV_IMAGE_COMPRESS_LZ4 = 2
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>Struct to describe a constant image resource.</para>
    /// <para>It's similar to lv_draw_buf_t, but the data is constant.</para>
    /// </summary>
    public unsafe partial class LvImageHeaderT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal uint magic;
            internal uint cf;
            internal uint flags;
            internal uint w;
            internal uint h;
            internal uint stride;
            internal uint reserved_2;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_image_header_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImageHeaderT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImageHeaderT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvImageHeaderT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvImageHeaderT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvImageHeaderT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvImageHeaderT(native.ToPointer(), skipVTables);
        }

        internal static LvImageHeaderT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvImageHeaderT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvImageHeaderT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvImageHeaderT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvImageHeaderT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvImageHeaderT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvImageHeaderT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImageHeaderT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvImageHeaderT(global::lvgl.LvImageHeaderT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImageHeaderT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvImageHeaderT.__Internal*) __Instance) = *((global::lvgl.LvImageHeaderT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Magic
        {
            get
            {
                return ((__Internal*)__Instance)->magic;
            }

            set
            {
                ((__Internal*)__Instance)->magic = value;
            }
        }

        public uint Cf
        {
            get
            {
                return ((__Internal*)__Instance)->cf;
            }

            set
            {
                ((__Internal*)__Instance)->cf = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public uint W
        {
            get
            {
                return ((__Internal*)__Instance)->w;
            }

            set
            {
                ((__Internal*)__Instance)->w = value;
            }
        }

        public uint H
        {
            get
            {
                return ((__Internal*)__Instance)->h;
            }

            set
            {
                ((__Internal*)__Instance)->h = value;
            }
        }

        public uint Stride
        {
            get
            {
                return ((__Internal*)__Instance)->stride;
            }

            set
            {
                ((__Internal*)__Instance)->stride = value;
            }
        }

        public uint Reserved2
        {
            get
            {
                return ((__Internal*)__Instance)->reserved_2;
            }

            set
            {
                ((__Internal*)__Instance)->reserved_2 = value;
            }
        }
    }

    public unsafe partial class LvYuvPlaneT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr buf;
            internal uint stride;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_yuv_plane_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvYuvPlaneT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvYuvPlaneT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvYuvPlaneT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvYuvPlaneT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvYuvPlaneT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvYuvPlaneT(native.ToPointer(), skipVTables);
        }

        internal static LvYuvPlaneT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvYuvPlaneT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvYuvPlaneT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvYuvPlaneT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvYuvPlaneT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvYuvPlaneT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvYuvPlaneT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvYuvPlaneT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvYuvPlaneT(global::lvgl.LvYuvPlaneT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvYuvPlaneT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvYuvPlaneT.__Internal*) __Instance) = *((global::lvgl.LvYuvPlaneT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Buf
        {
            get
            {
                return ((__Internal*)__Instance)->buf;
            }

            set
            {
                ((__Internal*)__Instance)->buf = (__IntPtr) value;
            }
        }

        public uint Stride
        {
            get
            {
                return ((__Internal*)__Instance)->stride;
            }

            set
            {
                ((__Internal*)__Instance)->stride = value;
            }
        }
    }

    public unsafe partial struct LvYuvBufT
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvYuvPlaneT.__Internal yuv;

            [FieldOffset(0)]
            internal global::lvgl.LvYuvBufT.Planar.__Internal planar;

            [FieldOffset(0)]
            internal global::lvgl.LvYuvBufT.SemiPlanar.__Internal semi_planar;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_yuv_buf_t@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial class Planar : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 48)]
            public partial struct __Internal
            {
                internal global::lvgl.LvYuvPlaneT.__Internal y;
                internal global::lvgl.LvYuvPlaneT.__Internal u;
                internal global::lvgl.LvYuvPlaneT.__Internal v;

                [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0<unnamed-type-planar>@lv_yuv_buf_t@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvYuvBufT.Planar> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvYuvBufT.Planar>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvYuvBufT.Planar managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvYuvBufT.Planar managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Planar __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Planar(native.ToPointer(), skipVTables);
            }

            internal static Planar __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Planar)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Planar __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Planar(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Planar(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Planar(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Planar()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvYuvBufT.Planar.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public Planar(global::lvgl.LvYuvBufT.Planar _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvYuvBufT.Planar.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::lvgl.LvYuvBufT.Planar.__Internal*) __Instance) = *((global::lvgl.LvYuvBufT.Planar.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::lvgl.LvYuvPlaneT Y
            {
                get
                {
                    return global::lvgl.LvYuvPlaneT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->y));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->y = *(global::lvgl.LvYuvPlaneT.__Internal*) value.__Instance;
                }
            }

            public global::lvgl.LvYuvPlaneT U
            {
                get
                {
                    return global::lvgl.LvYuvPlaneT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->u));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->u = *(global::lvgl.LvYuvPlaneT.__Internal*) value.__Instance;
                }
            }

            public global::lvgl.LvYuvPlaneT V
            {
                get
                {
                    return global::lvgl.LvYuvPlaneT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->v));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->v = *(global::lvgl.LvYuvPlaneT.__Internal*) value.__Instance;
                }
            }
        }

        public unsafe partial class SemiPlanar : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 32)]
            public partial struct __Internal
            {
                internal global::lvgl.LvYuvPlaneT.__Internal y;
                internal global::lvgl.LvYuvPlaneT.__Internal uv;

                [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0<unnamed-type-semi_planar>@lv_yuv_buf_t@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvYuvBufT.SemiPlanar> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvYuvBufT.SemiPlanar>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvYuvBufT.SemiPlanar managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvYuvBufT.SemiPlanar managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static SemiPlanar __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new SemiPlanar(native.ToPointer(), skipVTables);
            }

            internal static SemiPlanar __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (SemiPlanar)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static SemiPlanar __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new SemiPlanar(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private SemiPlanar(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected SemiPlanar(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public SemiPlanar()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvYuvBufT.SemiPlanar.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public SemiPlanar(global::lvgl.LvYuvBufT.SemiPlanar _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvYuvBufT.SemiPlanar.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::lvgl.LvYuvBufT.SemiPlanar.__Internal*) __Instance) = *((global::lvgl.LvYuvBufT.SemiPlanar.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::lvgl.LvYuvPlaneT Y
            {
                get
                {
                    return global::lvgl.LvYuvPlaneT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->y));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->y = *(global::lvgl.LvYuvPlaneT.__Internal*) value.__Instance;
                }
            }

            public global::lvgl.LvYuvPlaneT Uv
            {
                get
                {
                    return global::lvgl.LvYuvPlaneT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uv));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->uv = *(global::lvgl.LvYuvPlaneT.__Internal*) value.__Instance;
                }
            }
        }

        private LvYuvBufT.__Internal __instance;
        internal ref LvYuvBufT.__Internal __Instance => ref __instance;

        internal static LvYuvBufT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new LvYuvBufT(native.ToPointer(), skipVTables);
        }

        internal static LvYuvBufT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvYuvBufT(native, skipVTables);
        }

        private LvYuvBufT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private LvYuvBufT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::lvgl.LvYuvBufT.__Internal*) native;
        }

        public LvYuvBufT(global::lvgl.LvYuvBufT _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        public global::lvgl.LvYuvPlaneT Yuv
        {
            get
            {
                return global::lvgl.LvYuvPlaneT.__CreateInstance(__instance.yuv);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.yuv = *(global::lvgl.LvYuvPlaneT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvYuvBufT.Planar planar
        {
            get
            {
                return global::lvgl.LvYuvBufT.Planar.__CreateInstance(__instance.planar);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.planar = *(global::lvgl.LvYuvBufT.Planar.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvYuvBufT.SemiPlanar semi_planar
        {
            get
            {
                return global::lvgl.LvYuvBufT.SemiPlanar.__CreateInstance(__instance.semi_planar);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.semi_planar = *(global::lvgl.LvYuvBufT.SemiPlanar.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>
    /// <para>Struct to describe a constant image resource.</para>
    /// <para>It's similar to lv_draw_buf_t, but the data is constant.</para>
    /// </summary>
    public unsafe partial class LvImageDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal global::lvgl.LvImageHeaderT.__Internal header;
            internal uint data_size;
            internal __IntPtr data;
            internal __IntPtr reserved;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_image_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImageDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImageDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvImageDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvImageDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvImageDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvImageDscT(native.ToPointer(), skipVTables);
        }

        internal static LvImageDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvImageDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvImageDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvImageDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvImageDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvImageDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvImageDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImageDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvImageDscT(global::lvgl.LvImageDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImageDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvImageDscT.__Internal*) __Instance) = *((global::lvgl.LvImageDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>A header describing the basics of the image</summary>
        public global::lvgl.LvImageHeaderT Header
        {
            get
            {
                return global::lvgl.LvImageHeaderT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->header));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->header = *(global::lvgl.LvImageHeaderT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Size of the image in bytes</summary>
        public uint DataSize
        {
            get
            {
                return ((__Internal*)__Instance)->data_size;
            }

            set
            {
                ((__Internal*)__Instance)->data_size = value;
            }
        }

        /// <summary>Pointer to the data of the image</summary>
        public byte* Data
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->data;
            }
        }

        /// <summary>A reserved field to make it has same size as lv_draw_buf_t</summary>
        public __IntPtr Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }
        }
    }

    public unsafe partial class lv_cache
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCacheCreate(__IntPtr cache_class, ulong node_size, ulong max_size, __IntPtr ops);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_destroy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCacheDestroy(__IntPtr cache, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_acquire", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCacheAcquire(__IntPtr cache, __IntPtr key, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_acquire_or_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCacheAcquireOrCreate(__IntPtr cache, __IntPtr key, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_add", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCacheAdd(__IntPtr cache, __IntPtr key, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCacheRelease(__IntPtr cache, __IntPtr entry, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_reserve", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCacheReserve(__IntPtr cache, uint reserved_size, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_drop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCacheDrop(__IntPtr cache, __IntPtr key, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_drop_all", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCacheDropAll(__IntPtr cache, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_evict_one", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvCacheEvictOne(__IntPtr cache, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_set_max_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCacheSetMaxSize(__IntPtr cache, ulong max_size, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_get_max_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong LvCacheGetMaxSize(__IntPtr cache, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_get_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong LvCacheGetSize(__IntPtr cache, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_get_free_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong LvCacheGetFreeSize(__IntPtr cache, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_is_enabled", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvCacheIsEnabled(__IntPtr cache);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_set_compare_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCacheSetCompareCb(__IntPtr cache, __IntPtr compare_cb, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_set_create_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCacheSetCreateCb(__IntPtr cache, __IntPtr alloc_cb, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_set_free_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCacheSetFreeCb(__IntPtr cache, __IntPtr free_cb, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_set_name", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCacheSetName(__IntPtr cache, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_get_name", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCacheGetName(__IntPtr cache);
        }

        /// <summary>Create a cache object with the given parameters.</summary>
        /// <param name="cache_class">The class of the cache. Currently only support one two builtin classes:</param>
        /// <param name="node_size">The node size is the size of the data stored in the cache..</param>
        /// <param name="max_size">The max size is the maximum amount of memory or count that the cache can hold.</param>
        /// <param name="ops">A set of operations that can be performed on the cache. See</param>
        /// <returns>Returns a pointer to the created cache object on success,on error.</returns>
        /// <remarks>
        /// <para>_cache_class_lru_rb_count for LRU-based cache with count-based eviction policy.</para>
        /// <para>_cache_class_lru_rb_size for LRU-based cache with size-based eviction policy.</para>
        /// <para>_cache_class_lru_rb_count: max_size is the maximum count of nodes in the cache.</para>
        /// <para>_cache_class_lru_rb_size: max_size is the maximum size of the cache in bytes.</para>
        /// <para>_cache_ops_t for details.</para>
        /// </remarks>
        public static global::lvgl.LvCacheT LvCacheCreate(global::lvgl.LvCacheClassT cache_class, ulong node_size, ulong max_size, global::lvgl.LvCacheOpsT ops)
        {
            var __arg0 = cache_class is null ? __IntPtr.Zero : cache_class.__Instance;
            if (ReferenceEquals(ops, null))
                throw new global::System.ArgumentNullException("ops", "Cannot be null because it is passed by value.");
            var __arg3 = ops.__Instance;
            var ___ret = __Internal.LvCacheCreate(__arg0, node_size, max_size, __arg3);
            var __result0 = global::lvgl.LvCacheT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Destroy a cache object.</summary>
        /// <param name="cache">The cache object pointer to destroy.</param>
        /// <param name="user_data">A user data pointer that will be passed to the free callback.</param>
        public static void LvCacheDestroy(global::lvgl.LvCacheT cache, __IntPtr user_data)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            __Internal.LvCacheDestroy(__arg0, user_data);
        }

        /// <summary>
        /// <para>Acquire a cache entry with the given key. If the entry is not in the cache, it will returnas it is not found.</para>
        /// <para>If the entry is found, it's priority will be changed by the cache's policy. And the</para>
        /// </summary>
        /// <param name="cache">The cache object pointer to acquire the entry.</param>
        /// <param name="key">The key of the entry to acquire.</param>
        /// <param name="user_data">A user data pointer that will be passed to the create callback.</param>
        /// <returns>Returns a pointer to the acquired cache entry on success with</returns>
        /// <remarks>
        /// <para>_entry_t::ref count will be incremented.</para>
        /// <para>_entry_t::ref count incremented,on error.</para>
        /// </remarks>
        public static global::lvgl.LvCacheEntryT LvCacheAcquire(global::lvgl.LvCacheT cache, __IntPtr key, __IntPtr user_data)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            var ___ret = __Internal.LvCacheAcquire(__arg0, key, user_data);
            var __result0 = global::lvgl.LvCacheEntryT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Acquire a cache entry with the given key. If the entry is not in the cache, it will create a new entry with the given key.</para>
        /// <para>If the entry is found, it's priority will be changed by the cache's policy. And the</para>
        /// </summary>
        /// <param name="cache">The cache object pointer to acquire the entry.</param>
        /// <param name="key">The key of the entry to acquire or create.</param>
        /// <param name="user_data">A user data pointer that will be passed to the create callback.</param>
        /// <returns>Returns a pointer to the acquired or created cache entry on success with</returns>
        /// <remarks>
        /// <para>_entry_t::ref count will be incremented.</para>
        /// <para>If you want to use this API to simplify the code, you should provide a</para>
        /// <para>_cache_ops_t::create_cb that creates a new entry with the given key.</para>
        /// <para>This API is a combination of</para>
        /// <para>_cache_acquire and</para>
        /// <para>_cache_add. The effect is the same as calling</para>
        /// <para>_cache_acquire and</para>
        /// <para>_cache_add separately.</para>
        /// <para>And the internal impact on cache is also consistent with these two APIs.</para>
        /// <para>_entry_t::ref count incremented,on error.</para>
        /// </remarks>
        public static global::lvgl.LvCacheEntryT LvCacheAcquireOrCreate(global::lvgl.LvCacheT cache, __IntPtr key, __IntPtr user_data)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            var ___ret = __Internal.LvCacheAcquireOrCreate(__arg0, key, user_data);
            var __result0 = global::lvgl.LvCacheEntryT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Add a new cache entry with the given key and data. If the cache is full, the cache's policy will be used to evict an entry.</summary>
        /// <param name="cache">The cache object pointer to add the entry.</param>
        /// <param name="key">The key of the entry to add.</param>
        /// <param name="user_data">A user data pointer that will be passed to the create callback.</param>
        /// <returns>Returns a pointer to the added cache entry on success with</returns>
        /// <remarks>_entry_t::ref count incremented,on error.</remarks>
        public static global::lvgl.LvCacheEntryT LvCacheAdd(global::lvgl.LvCacheT cache, __IntPtr key, __IntPtr user_data)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            var ___ret = __Internal.LvCacheAdd(__arg0, key, user_data);
            var __result0 = global::lvgl.LvCacheEntryT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Release a cache entry. The</summary>
        /// <param name="cache">The cache object pointer to release the entry.</param>
        /// <param name="entry">The cache entry pointer to release.</param>
        /// <param name="user_data">A user data pointer that will be passed to the free callback.</param>
        /// <remarks>
        /// <para>_entry_t::ref count will be decremented. If the</para>
        /// <para>_entry_t::ref count is zero, it will issue an error.</para>
        /// <para>If the entry passed to this function is the last reference to the data and the entry is marked as invalid, the cache's policy will be used to evict the entry.</para>
        /// </remarks>
        public static void LvCacheRelease(global::lvgl.LvCacheT cache, global::lvgl.LvCacheEntryT entry, __IntPtr user_data)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            var __arg1 = entry is null ? __IntPtr.Zero : entry.__Instance;
            __Internal.LvCacheRelease(__arg0, __arg1, user_data);
        }

        /// <summary>
        /// <para>Reserve a certain amount of memory/count in the cache. This function is useful when you want to reserve a certain amount of memory/count in advance,</para>
        /// <para>for example, when you know that you will need it later.</para>
        /// <para>When the current cache size is max than the reserved size, the function will evict entries until the reserved size is reached.</para>
        /// </summary>
        /// <param name="cache">The cache object pointer to reserve.</param>
        /// <param name="reserved_size">The amount of memory/count to reserve.</param>
        /// <param name="user_data">A user data pointer that will be passed to the free callback.</param>
        public static void LvCacheReserve(global::lvgl.LvCacheT cache, uint reserved_size, __IntPtr user_data)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            __Internal.LvCacheReserve(__arg0, reserved_size, user_data);
        }

        /// <summary>
        /// <para>Drop a cache entry with the given key. If the entry is not in the cache, nothing will happen to it.</para>
        /// <para>If the entry is found, it will be removed from the cache and its data will be freed when the last reference to it is released.</para>
        /// </summary>
        /// <param name="cache">The cache object pointer to drop the entry.</param>
        /// <param name="key">The key of the entry to drop.</param>
        /// <param name="user_data">A user data pointer that will be passed to the free callback.</param>
        /// <remarks>
        /// <para>The data will not be freed immediately but when the last reference to it is released. But this entry will not be found by</para>
        /// <para>_cache_acquire.</para>
        /// <para>If you want cache a same key again, you should use</para>
        /// <para>_cache_add or</para>
        /// <para>_cache_acquire_or_create.</para>
        /// </remarks>
        public static void LvCacheDrop(global::lvgl.LvCacheT cache, __IntPtr key, __IntPtr user_data)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            __Internal.LvCacheDrop(__arg0, key, user_data);
        }

        /// <summary>Drop all cache entries. All entries will be removed from the cache and their data will be freed when the last reference to them is released.</summary>
        /// <param name="cache">The cache object pointer to drop all entries.</param>
        /// <param name="user_data">A user data pointer that will be passed to the free callback.</param>
        /// <remarks>If some entries are still referenced by other objects, it will issue an error. And this case shouldn't happen in normal cases..</remarks>
        public static void LvCacheDropAll(global::lvgl.LvCacheT cache, __IntPtr user_data)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            __Internal.LvCacheDropAll(__arg0, user_data);
        }

        /// <summary>Evict one entry from the cache. The eviction policy will be used to select the entry to evict.</summary>
        /// <param name="cache">The cache object pointer to evict an entry.</param>
        /// <param name="user_data">A user data pointer that will be passed to the free callback.</param>
        /// <returns>Returns true if an entry is evicted, false if no entry is evicted.</returns>
        public static bool LvCacheEvictOne(global::lvgl.LvCacheT cache, __IntPtr user_data)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            var ___ret = __Internal.LvCacheEvictOne(__arg0, user_data);
            return ___ret;
        }

        /// <summary>
        /// <para>Set the maximum size of the cache.</para>
        /// <para>If the current cache size is greater than the new maximum size, the cache's policy will be used to evict entries until the new maximum size is reached.</para>
        /// <para>If set to 0, the cache will be disabled.</para>
        /// </summary>
        /// <param name="cache">The cache object pointer to set the maximum size.</param>
        /// <param name="max_size">The new maximum size of the cache.</param>
        /// <param name="user_data">A user data pointer that will be passed to the free callback.</param>
        /// <remarks>But this behavior will happen only new entries are added to the cache.</remarks>
        public static void LvCacheSetMaxSize(global::lvgl.LvCacheT cache, ulong max_size, __IntPtr user_data)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            __Internal.LvCacheSetMaxSize(__arg0, max_size, user_data);
        }

        /// <summary>Get the maximum size of the cache.</summary>
        /// <param name="cache">The cache object pointer to get the maximum size.</param>
        /// <param name="user_data">A user data pointer that will be passed to the free callback.</param>
        /// <returns>Returns the maximum size of the cache.</returns>
        public static ulong LvCacheGetMaxSize(global::lvgl.LvCacheT cache, __IntPtr user_data)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            var ___ret = __Internal.LvCacheGetMaxSize(__arg0, user_data);
            return ___ret;
        }

        /// <summary>Get the current size of the cache.</summary>
        /// <param name="cache">The cache object pointer to get the current size.</param>
        /// <param name="user_data">A user data pointer that will be passed to the free callback.</param>
        /// <returns>Returns the current size of the cache.</returns>
        public static ulong LvCacheGetSize(global::lvgl.LvCacheT cache, __IntPtr user_data)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            var ___ret = __Internal.LvCacheGetSize(__arg0, user_data);
            return ___ret;
        }

        /// <summary>Get the free size of the cache.</summary>
        /// <param name="cache">The cache object pointer to get the free size.</param>
        /// <param name="user_data">A user data pointer that will be passed to the free callback.</param>
        /// <returns>Returns the free size of the cache.</returns>
        public static ulong LvCacheGetFreeSize(global::lvgl.LvCacheT cache, __IntPtr user_data)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            var ___ret = __Internal.LvCacheGetFreeSize(__arg0, user_data);
            return ___ret;
        }

        /// <summary>
        /// <para>Return true if the cache is enabled.</para>
        /// <para>Disabled cache means that when the max_size of the cache is 0. In this case, all cache operations will be no-op.</para>
        /// </summary>
        /// <param name="cache">The cache object pointer to check if it's disabled.</param>
        /// <returns>Returns true if the cache is enabled, false otherwise.</returns>
        public static bool LvCacheIsEnabled(global::lvgl.LvCacheT cache)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            var ___ret = __Internal.LvCacheIsEnabled(__arg0);
            return ___ret;
        }

        /// <summary>Set the compare callback of the cache.</summary>
        /// <param name="cache">The cache object pointer to set the compare callback.</param>
        /// <param name="compare_cb">The compare callback to set.</param>
        /// <param name="user_data">A user data pointer.</param>
        public static void LvCacheSetCompareCb(global::lvgl.LvCacheT cache, global::lvgl.LvCacheCompareCbT compare_cb, __IntPtr user_data)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            var __arg1 = compare_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(compare_cb);
            __Internal.LvCacheSetCompareCb(__arg0, __arg1, user_data);
        }

        /// <summary>Set the create callback of the cache.</summary>
        /// <param name="cache">The cache object pointer to set the create callback.</param>
        /// <param name="alloc_cb">The create callback to set.</param>
        /// <param name="user_data">A user data pointer.</param>
        public static void LvCacheSetCreateCb(global::lvgl.LvCacheT cache, global::lvgl.LvCacheCreateCbT alloc_cb, __IntPtr user_data)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            var __arg1 = alloc_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(alloc_cb);
            __Internal.LvCacheSetCreateCb(__arg0, __arg1, user_data);
        }

        /// <summary>Set the free callback of the cache.</summary>
        /// <param name="cache">The cache object pointer to set the free callback.</param>
        /// <param name="free_cb">The free callback to set.</param>
        /// <param name="user_data">A user data pointer.</param>
        public static void LvCacheSetFreeCb(global::lvgl.LvCacheT cache, global::lvgl.LvCacheFreeCbT free_cb, __IntPtr user_data)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            var __arg1 = free_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(free_cb);
            __Internal.LvCacheSetFreeCb(__arg0, __arg1, user_data);
        }

        /// <summary>Give a name for a cache object. Only the pointer of the string is saved.</summary>
        /// <param name="cache">The cache object pointer to set the name.</param>
        /// <param name="name">The name of the cache.</param>
        public static void LvCacheSetName(global::lvgl.LvCacheT cache, string name)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            __Internal.LvCacheSetName(__arg0, name);
        }

        /// <summary>Get the name of a cache object.</summary>
        /// <param name="cache">The cache object pointer to get the name.</param>
        /// <returns>Returns the name of the cache.</returns>
        public static string LvCacheGetName(global::lvgl.LvCacheT cache)
        {
            var __arg0 = cache is null ? __IntPtr.Zero : cache.__Instance;
            var ___ret = __Internal.LvCacheGetName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }
    }

    public unsafe partial class lv_cache_entry
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_entry_get_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvCacheEntryGetSize(uint node_size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_entry_get_ref", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvCacheEntryGetRef(__IntPtr entry);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_entry_get_node_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvCacheEntryGetNodeSize(__IntPtr entry);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_entry_is_invalid", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvCacheEntryIsInvalid(__IntPtr entry);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_entry_get_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCacheEntryGetData(__IntPtr entry);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_entry_get_cache", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCacheEntryGetCache(__IntPtr entry);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_entry_get_entry", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCacheEntryGetEntry(__IntPtr data, uint node_size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_entry_alloc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCacheEntryAlloc(uint node_size, __IntPtr cache);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_entry_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCacheEntryInit(__IntPtr entry, __IntPtr cache, uint node_size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_cache_entry_delete", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCacheEntryDelete(__IntPtr entry);
        }

        /// <summary>Get the size of a cache entry.</summary>
        /// <param name="node_size">The size of the node in the cache.</param>
        /// <returns>The size of the cache entry.</returns>
        public static uint LvCacheEntryGetSize(uint node_size)
        {
            var ___ret = __Internal.LvCacheEntryGetSize(node_size);
            return ___ret;
        }

        /// <summary>Get the reference count of a cache entry.</summary>
        /// <param name="entry">The cache entry to get the reference count of.</param>
        /// <returns>The reference count of the cache entry.</returns>
        public static int LvCacheEntryGetRef(global::lvgl.LvCacheEntryT entry)
        {
            var __arg0 = entry is null ? __IntPtr.Zero : entry.__Instance;
            var ___ret = __Internal.LvCacheEntryGetRef(__arg0);
            return ___ret;
        }

        /// <summary>Get the node size of a cache entry. Which is the same size with</summary>
        /// <param name="entry">The cache entry to get the node size of.</param>
        /// <returns>The node size of the cache entry.</returns>
        /// <remarks>_cache_entry_get_size's node_size parameter.</remarks>
        public static uint LvCacheEntryGetNodeSize(global::lvgl.LvCacheEntryT entry)
        {
            var __arg0 = entry is null ? __IntPtr.Zero : entry.__Instance;
            var ___ret = __Internal.LvCacheEntryGetNodeSize(__arg0);
            return ___ret;
        }

        /// <summary>Check if a cache entry is invalid.</summary>
        /// <param name="entry">The cache entry to check.</param>
        /// <returns>True: the cache entry is invalid. False: the cache entry is valid.</returns>
        public static bool LvCacheEntryIsInvalid(global::lvgl.LvCacheEntryT entry)
        {
            var __arg0 = entry is null ? __IntPtr.Zero : entry.__Instance;
            var ___ret = __Internal.LvCacheEntryIsInvalid(__arg0);
            return ___ret;
        }

        /// <summary>Get the data of a cache entry.</summary>
        /// <param name="entry">The cache entry to get the data of.</param>
        /// <returns>The pointer to the data of the cache entry.</returns>
        public static __IntPtr LvCacheEntryGetData(global::lvgl.LvCacheEntryT entry)
        {
            var __arg0 = entry is null ? __IntPtr.Zero : entry.__Instance;
            var ___ret = __Internal.LvCacheEntryGetData(__arg0);
            return ___ret;
        }

        /// <summary>Get the cache instance of a cache entry.</summary>
        /// <param name="entry">The cache entry to get the cache instance of.</param>
        /// <returns>The pointer to the cache instance of the cache entry.</returns>
        public static global::lvgl.LvCacheT LvCacheEntryGetCache(global::lvgl.LvCacheEntryT entry)
        {
            var __arg0 = entry is null ? __IntPtr.Zero : entry.__Instance;
            var ___ret = __Internal.LvCacheEntryGetCache(__arg0);
            var __result0 = global::lvgl.LvCacheT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the cache entry of a data. The data should be allocated by the cache instance.</summary>
        /// <param name="data">The data to get the cache entry of.</param>
        /// <param name="node_size">The size of the node in the cache.</param>
        /// <returns>The pointer to the cache entry of the data.</returns>
        public static global::lvgl.LvCacheEntryT LvCacheEntryGetEntry(__IntPtr data, uint node_size)
        {
            var ___ret = __Internal.LvCacheEntryGetEntry(data, node_size);
            var __result0 = global::lvgl.LvCacheEntryT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Allocate a cache entry.</summary>
        /// <param name="node_size">The size of the node in the cache.</param>
        /// <param name="cache">The cache instance to allocate the cache entry from.</param>
        /// <returns>The pointer to the allocated cache entry.</returns>
        public static global::lvgl.LvCacheEntryT LvCacheEntryAlloc(uint node_size, global::lvgl.LvCacheT cache)
        {
            var __arg1 = cache is null ? __IntPtr.Zero : cache.__Instance;
            var ___ret = __Internal.LvCacheEntryAlloc(node_size, __arg1);
            var __result0 = global::lvgl.LvCacheEntryT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Initialize a cache entry.</summary>
        /// <param name="entry">The cache entry to initialize.</param>
        /// <param name="cache">The cache instance to allocate the cache entry from.</param>
        /// <param name="node_size">The size of the node in the cache.</param>
        public static void LvCacheEntryInit(global::lvgl.LvCacheEntryT entry, global::lvgl.LvCacheT cache, uint node_size)
        {
            var __arg0 = entry is null ? __IntPtr.Zero : entry.__Instance;
            var __arg1 = cache is null ? __IntPtr.Zero : cache.__Instance;
            __Internal.LvCacheEntryInit(__arg0, __arg1, node_size);
        }

        /// <summary>Deallocate a cache entry. And the data of the cache entry will be freed.</summary>
        /// <param name="entry">The cache entry to deallocate.</param>
        public static void LvCacheEntryDelete(global::lvgl.LvCacheEntryT entry)
        {
            var __arg0 = entry is null ? __IntPtr.Zero : entry.__Instance;
            __Internal.LvCacheEntryDelete(__arg0);
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public enum LvThreadPrioT
    {
        LV_THREAD_PRIO_LOWEST = 0,
        LV_THREAD_PRIO_LOW = 1,
        LV_THREAD_PRIO_MID = 2,
        LV_THREAD_PRIO_HIGH = 3,
        LV_THREAD_PRIO_HIGHEST = 4
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class lv_os
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_thread_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvThreadInit(__IntPtr* thread, global::lvgl.LvThreadPrioT prio, __IntPtr callback, ulong stack_size, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_thread_delete", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvThreadDelete(__IntPtr* thread);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_thread_sync_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvThreadSyncInit(__IntPtr sync);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_thread_sync_wait", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvThreadSyncWait(__IntPtr sync);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_thread_sync_signal", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvThreadSyncSignal(__IntPtr sync);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_thread_sync_delete", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvThreadSyncDelete(__IntPtr sync);
        }

        /// <summary>Create a new thread</summary>
        /// <param name="thread">a variable in which the thread will be stored</param>
        /// <param name="prio">priority of the thread</param>
        /// <param name="callback">function of the thread</param>
        /// <param name="stack_size">stack size in bytes</param>
        /// <param name="user_data">arbitrary data, will be available in the callback</param>
        /// <returns>LV_RESULT_OK: success; LV_RESULT_INVALID: failure</returns>
        public static byte LvThreadInit(__IntPtr* thread, global::lvgl.LvThreadPrioT prio, global::lvgl.Delegates.Action___IntPtr callback, ulong stack_size, __IntPtr user_data)
        {
            var __arg2 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var ___ret = __Internal.LvThreadInit(thread, prio, __arg2, stack_size, user_data);
            return ___ret;
        }

        /// <summary>Delete a thread</summary>
        /// <param name="thread">the thread to delete</param>
        /// <returns>LV_RESULT_OK: success; LV_RESULT_INVALID: failure</returns>
        public static byte LvThreadDelete(__IntPtr* thread)
        {
            var ___ret = __Internal.LvThreadDelete(thread);
            return ___ret;
        }

        /// <summary>Create a thread synchronization object</summary>
        /// <param name="sync">a variable in which the sync will be stored</param>
        /// <returns>LV_RESULT_OK: success; LV_RESULT_INVALID: failure</returns>
        public static byte LvThreadSyncInit(global::lvgl.LvThreadSyncT sync)
        {
            var __arg0 = sync is null ? __IntPtr.Zero : sync.__Instance;
            var ___ret = __Internal.LvThreadSyncInit(__arg0);
            return ___ret;
        }

        /// <summary>Wait for a &quot;signal&quot; on a sync object</summary>
        /// <param name="sync">a sync object</param>
        /// <returns>LV_RESULT_OK: success; LV_RESULT_INVALID: failure</returns>
        public static byte LvThreadSyncWait(global::lvgl.LvThreadSyncT sync)
        {
            var __arg0 = sync is null ? __IntPtr.Zero : sync.__Instance;
            var ___ret = __Internal.LvThreadSyncWait(__arg0);
            return ___ret;
        }

        /// <summary>Send a wake-up signal to a sync object</summary>
        /// <param name="sync">a sync object</param>
        /// <returns>LV_RESULT_OK: success; LV_RESULT_INVALID: failure</returns>
        public static byte LvThreadSyncSignal(global::lvgl.LvThreadSyncT sync)
        {
            var __arg0 = sync is null ? __IntPtr.Zero : sync.__Instance;
            var ___ret = __Internal.LvThreadSyncSignal(__arg0);
            return ___ret;
        }

        /// <summary>Delete a sync object</summary>
        /// <param name="sync">a sync object to delete</param>
        /// <returns>LV_RESULT_OK: success; LV_RESULT_INVALID: failure</returns>
        public static byte LvThreadSyncDelete(global::lvgl.LvThreadSyncT sync)
        {
            var __arg0 = sync is null ? __IntPtr.Zero : sync.__Instance;
            var ___ret = __Internal.LvThreadSyncDelete(__arg0);
            return ___ret;
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvThreadSyncT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal global::RTL_CRITICAL_SECTION.__Internal cs;
            internal global::RTL_CONDITION_VARIABLE.__Internal cv;
            internal byte v;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_thread_sync_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvThreadSyncT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvThreadSyncT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvThreadSyncT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvThreadSyncT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvThreadSyncT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvThreadSyncT(native.ToPointer(), skipVTables);
        }

        internal static LvThreadSyncT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvThreadSyncT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvThreadSyncT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvThreadSyncT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvThreadSyncT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvThreadSyncT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvThreadSyncT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvThreadSyncT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvThreadSyncT(global::lvgl.LvThreadSyncT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvThreadSyncT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvThreadSyncT.__Internal*) __Instance) = *((global::lvgl.LvThreadSyncT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool V
        {
            get
            {
                return ((__Internal*)__Instance)->v != 0;
            }

            set
            {
                ((__Internal*)__Instance)->v = (byte) (value ? 1 : 0);
            }
        }
    }

    /// <summary>The result of the cache reserve condition callback</summary>
    public enum LvCacheReserveCondResT
    {
        /// <summary>The condition is met and no entries need to be evicted</summary>
        LV_CACHE_RESERVE_COND_OK = 0,
        /// <summary>The condition is not met and the reserve size is too large</summary>
        LV_CACHE_RESERVE_COND_TOO_LARGE = 1,
        /// <summary>The condition is not met and a victim is needed to be evicted</summary>
        LV_CACHE_RESERVE_COND_NEED_VICTIM = 2,
        /// <summary>An error occurred while checking the condition</summary>
        LV_CACHE_RESERVE_COND_ERROR = 3
    }

    /// <summary>The cache instance allocation function, used by the cache class to allocate memory for cache instances.</summary>
    /// <returns>It should return a pointer to the allocated instance.</returns>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate __IntPtr LvCacheAllocCbT();

    /// <summary>The cache instance initialization function, used by the cache class to initialize the cache instance.</summary>
    /// <returns>It should return true if the initialization is successful, false otherwise.</returns>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool LvCacheInitCbT(__IntPtr cache);

    /// <summary>The cache instance destruction function, used by the cache class to destroy the cache instance.</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvCacheDestroyCbT(__IntPtr cache, __IntPtr user_data);

    /// <summary>The cache get function, used by the cache class to get a cache entry by its key.</summary>
    /// <returns>if the key is not found.</returns>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate __IntPtr LvCacheGetCbT(__IntPtr cache, __IntPtr key, __IntPtr user_data);

    /// <summary>
    /// <para>The cache add function, used by the cache class to add a cache entry with a given key.</para>
    /// <para>This function only cares about how to add the entry, it doesn't check if the entry already exists and doesn't care about is it a victim or not.</para>
    /// </summary>
    /// <returns>the added cache entry, or NULL if the entry is not added.</returns>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate __IntPtr LvCacheAddCbT(__IntPtr cache, __IntPtr key, __IntPtr user_data);

    /// <summary>
    /// <para>The cache remove function, used by the cache class to remove a cache entry from the cache but doesn't free the memory..</para>
    /// <para>This function only cares about how to remove the entry, it doesn't care about is it a victim or not.</para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvCacheRemoveCbT(__IntPtr cache, __IntPtr entry, __IntPtr user_data);

    /// <summary>The cache drop function, used by the cache class to remove a cache entry from the cache and free the memory.</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvCacheDropCbT(__IntPtr cache, __IntPtr key, __IntPtr user_data);

    /// <summary>The cache drop all function, used by the cache class to remove all cache entries from the cache and free the memory.</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvCacheDropAllCbT(__IntPtr cache, __IntPtr user_data);

    /// <summary>The cache get victim function, used by the cache class to get a victim entry to be evicted.</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate __IntPtr LvCacheGetVictimCb(__IntPtr cache, __IntPtr user_data);

    /// <summary>The result of the cache reserve condition callback</summary>
    /// <summary>
    /// <para>The cache reserve condition function, used by the cache class to check if a new entry can be added to the cache without exceeding its maximum size.</para>
    /// <para>See</para>
    /// </summary>
    /// <remarks>_cache_reserve_cond_res_t for the possible results.</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::lvgl.LvCacheReserveCondResT LvCacheReserveCondCb(__IntPtr cache, __IntPtr key, ulong size, __IntPtr user_data);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate sbyte LvCacheCompareCbT(__IntPtr a, __IntPtr b);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool LvCacheCreateCbT(__IntPtr node, __IntPtr user_data);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvCacheFreeCbT(__IntPtr node, __IntPtr user_data);

    public unsafe partial class LvCacheEntryT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvCacheEntryT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvCacheEntryT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvCacheEntryT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvCacheEntryT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvCacheEntryT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvCacheEntryT(native.ToPointer(), skipVTables);
        }

        internal static LvCacheEntryT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvCacheEntryT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvCacheEntryT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvCacheEntryT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvCacheEntryT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvCacheEntryT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>The cache operations struct</summary>
    public unsafe partial class LvCacheOpsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr compare_cb;
            internal __IntPtr create_cb;
            internal __IntPtr free_cb;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_cache_ops_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvCacheOpsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvCacheOpsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvCacheOpsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvCacheOpsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvCacheOpsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvCacheOpsT(native.ToPointer(), skipVTables);
        }

        internal static LvCacheOpsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvCacheOpsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvCacheOpsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvCacheOpsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvCacheOpsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvCacheOpsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvCacheOpsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvCacheOpsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvCacheOpsT(global::lvgl.LvCacheOpsT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvCacheOpsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvCacheOpsT.__Internal*) __Instance) = *((global::lvgl.LvCacheOpsT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Compare function for keys</summary>
        public global::lvgl.LvCacheCompareCbT CompareCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->compare_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvCacheCompareCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvCacheCompareCbT));
            }

            set
            {
                ((__Internal*)__Instance)->compare_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Create function for nodes</summary>
        public global::lvgl.LvCacheCreateCbT CreateCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->create_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvCacheCreateCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvCacheCreateCbT));
            }

            set
            {
                ((__Internal*)__Instance)->create_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Free function for nodes</summary>
        public global::lvgl.LvCacheFreeCbT FreeCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->free_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvCacheFreeCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvCacheFreeCbT));
            }

            set
            {
                ((__Internal*)__Instance)->free_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    /// <summary>The cache entry struct</summary>
    public unsafe partial class LvCacheT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 96)]
        public partial struct __Internal
        {
            internal __IntPtr clz;
            internal uint node_size;
            internal uint max_size;
            internal uint size;
            internal global::lvgl.LvCacheOpsT.__Internal ops;
            internal global::RTL_CRITICAL_SECTION.__Internal @lock;
            internal __IntPtr name;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_cache_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvCacheT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvCacheT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvCacheT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvCacheT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __name_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static LvCacheT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvCacheT(native.ToPointer(), skipVTables);
        }

        internal static LvCacheT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvCacheT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvCacheT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvCacheT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvCacheT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvCacheT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvCacheT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvCacheT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvCacheT(global::lvgl.LvCacheT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvCacheT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvCacheT.__Internal*) __Instance) = *((global::lvgl.LvCacheT.__Internal*) _0.__Instance);
            if (_0.__name_OwnsNativeMemory)
                this.Name = _0.Name;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The cache class. There are two built-in classes:</summary>
        /// <remarks>
        /// <para>_cache_class_lru_rb_count for LRU-based cache with count-based eviction policy.</para>
        /// <para>_cache_class_lru_rb_size for LRU-based cache with size-based eviction policy.</para>
        /// </remarks>
        public global::lvgl.LvCacheClassT Clz
        {
            get
            {
                var __result0 = global::lvgl.LvCacheClassT.__GetOrCreateInstance(((__Internal*)__Instance)->clz, false);
                return __result0;
            }
        }

        /// <summary>The size of a node</summary>
        public uint NodeSize
        {
            get
            {
                return ((__Internal*)__Instance)->node_size;
            }

            set
            {
                ((__Internal*)__Instance)->node_size = value;
            }
        }

        /// <summary>The maximum size of the cache</summary>
        public uint MaxSize
        {
            get
            {
                return ((__Internal*)__Instance)->max_size;
            }

            set
            {
                ((__Internal*)__Instance)->max_size = value;
            }
        }

        /// <summary>The current size of the cache</summary>
        public uint Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }

        /// <summary>The cache operations struct</summary>
        /// <remarks>_cache_ops_t</remarks>
        public global::lvgl.LvCacheOpsT Ops
        {
            get
            {
                return global::lvgl.LvCacheOpsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ops));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ops = *(global::lvgl.LvCacheOpsT.__Internal*) value.__Instance;
            }
        }

        /// <summary>The name of the cache</summary>
        public string Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->name);
            }

            set
            {
                if (__name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                __name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->name = (__IntPtr) __bytePtr0;
            }
        }
    }

    /// <summary>The cache class struct for building custom cache classes, and there are two built-in classes for examples:</summary>
    /// <remarks>
    /// <para>_cache_class_lru_rb_count for LRU-based cache with count-based eviction policy.</para>
    /// <para>_cache_class_lru_rb_size for LRU-based cache with size-based eviction policy.</para>
    /// </remarks>
    public unsafe partial class LvCacheClassT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 80)]
        public partial struct __Internal
        {
            internal __IntPtr alloc_cb;
            internal __IntPtr init_cb;
            internal __IntPtr destroy_cb;
            internal __IntPtr get_cb;
            internal __IntPtr add_cb;
            internal __IntPtr remove_cb;
            internal __IntPtr drop_cb;
            internal __IntPtr drop_all_cb;
            internal __IntPtr get_victim_cb;
            internal __IntPtr reserve_cond_cb;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_cache_class_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvCacheClassT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvCacheClassT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvCacheClassT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvCacheClassT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvCacheClassT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvCacheClassT(native.ToPointer(), skipVTables);
        }

        internal static LvCacheClassT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvCacheClassT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvCacheClassT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvCacheClassT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvCacheClassT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvCacheClassT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvCacheClassT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvCacheClassT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvCacheClassT(global::lvgl.LvCacheClassT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvCacheClassT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvCacheClassT.__Internal*) __Instance) = *((global::lvgl.LvCacheClassT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The allocation function for cache entries</summary>
        public global::lvgl.LvCacheAllocCbT AllocCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->alloc_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvCacheAllocCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvCacheAllocCbT));
            }

            set
            {
                ((__Internal*)__Instance)->alloc_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>The initialization function for cache entries</summary>
        public global::lvgl.LvCacheInitCbT InitCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->init_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvCacheInitCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvCacheInitCbT));
            }

            set
            {
                ((__Internal*)__Instance)->init_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>The destruction function for cache entries</summary>
        public global::lvgl.LvCacheDestroyCbT DestroyCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->destroy_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvCacheDestroyCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvCacheDestroyCbT));
            }

            set
            {
                ((__Internal*)__Instance)->destroy_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>The get function for cache entries</summary>
        public global::lvgl.LvCacheGetCbT GetCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvCacheGetCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvCacheGetCbT));
            }

            set
            {
                ((__Internal*)__Instance)->get_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>The add function for cache entries</summary>
        public global::lvgl.LvCacheAddCbT AddCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->add_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvCacheAddCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvCacheAddCbT));
            }

            set
            {
                ((__Internal*)__Instance)->add_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>The remove function for cache entries</summary>
        public global::lvgl.LvCacheRemoveCbT RemoveCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->remove_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvCacheRemoveCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvCacheRemoveCbT));
            }

            set
            {
                ((__Internal*)__Instance)->remove_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>The drop function for cache entries</summary>
        public global::lvgl.LvCacheDropCbT DropCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->drop_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvCacheDropCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvCacheDropCbT));
            }

            set
            {
                ((__Internal*)__Instance)->drop_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>The drop all function for cache entries</summary>
        public global::lvgl.LvCacheDropAllCbT DropAllCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->drop_all_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvCacheDropAllCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvCacheDropAllCbT));
            }

            set
            {
                ((__Internal*)__Instance)->drop_all_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>The get victim function for cache entries</summary>
        public global::lvgl.LvCacheGetVictimCb GetVictimCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_victim_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvCacheGetVictimCb) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvCacheGetVictimCb));
            }

            set
            {
                ((__Internal*)__Instance)->get_victim_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>The reserve condition function for cache entries</summary>
        public global::lvgl.LvCacheReserveCondCb ReserveCondCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->reserve_cond_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvCacheReserveCondCb) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvCacheReserveCondCb));
            }

            set
            {
                ((__Internal*)__Instance)->reserve_cond_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    /// <summary>
    /// <para>The cache entry slot struct</para>
    /// <para>To add new fields to the cache entry, add them to a new struct and add it to the first field of the cache data struct.</para>
    /// <para>And this one is a size slot for the cache entry.</para>
    /// </summary>
    public unsafe partial class LvCacheSlotSizeT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal ulong size;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_cache_slot_size_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvCacheSlotSizeT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvCacheSlotSizeT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvCacheSlotSizeT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvCacheSlotSizeT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvCacheSlotSizeT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvCacheSlotSizeT(native.ToPointer(), skipVTables);
        }

        internal static LvCacheSlotSizeT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvCacheSlotSizeT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvCacheSlotSizeT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvCacheSlotSizeT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvCacheSlotSizeT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvCacheSlotSizeT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvCacheSlotSizeT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvCacheSlotSizeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvCacheSlotSizeT(global::lvgl.LvCacheSlotSizeT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvCacheSlotSizeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvCacheSlotSizeT.__Internal*) __Instance) = *((global::lvgl.LvCacheSlotSizeT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }
    }

    public unsafe partial class lv_image_cache
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_cache_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvImageCacheInit(uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_cache_resize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageCacheResize(uint new_size, bool evict_now);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_cache_drop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageCacheDrop(__IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_cache_is_enabled", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvImageCacheIsEnabled();
        }

        /// <summary>Initialize image cache.</summary>
        /// <param name="size">size of the cache in bytes.</param>
        /// <returns>LV_RESULT_OK: initialization succeeded, LV_RESULT_INVALID: failed.</returns>
        public static byte LvImageCacheInit(uint size)
        {
            var ___ret = __Internal.LvImageCacheInit(size);
            return ___ret;
        }

        /// <summary>
        /// <para>Resize image cache.</para>
        /// <para>If set to 0, the cache will be disabled.</para>
        /// </summary>
        /// <param name="new_size">new size of the cache in bytes.</param>
        /// <param name="evict_now">true: evict the images should be removed by the eviction policy, false: wait for the next cache cleanup.</param>
        public static void LvImageCacheResize(uint new_size, bool evict_now)
        {
            __Internal.LvImageCacheResize(new_size, evict_now);
        }

        /// <summary>Invalidate image cache. Use NULL to invalidate all images.</summary>
        /// <param name="src">pointer to an image source.</param>
        public static void LvImageCacheDrop(__IntPtr src)
        {
            __Internal.LvImageCacheDrop(src);
        }

        /// <summary>Return true if the image cache is enabled.</summary>
        /// <returns>true: enabled, false: disabled.</returns>
        public static bool LvImageCacheIsEnabled()
        {
            var ___ret = __Internal.LvImageCacheIsEnabled();
            return ___ret;
        }
    }

    public unsafe partial class lv_image_header_cache
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_header_cache_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvImageHeaderCacheInit(uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_header_cache_resize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageHeaderCacheResize(uint count, bool evict_now);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_header_cache_drop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageHeaderCacheDrop(__IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_header_cache_is_enabled", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvImageHeaderCacheIsEnabled();
        }

        /// <summary>Initialize image header cache.</summary>
        /// <param name="count">initial size of the cache in count of image headers.</param>
        /// <returns>LV_RESULT_OK: initialization succeeded, LV_RESULT_INVALID: failed.</returns>
        public static byte LvImageHeaderCacheInit(uint count)
        {
            var ___ret = __Internal.LvImageHeaderCacheInit(count);
            return ___ret;
        }

        /// <summary>
        /// <para>Resize image header cache.</para>
        /// <para>If set to 0, the cache is disabled.</para>
        /// </summary>
        /// <param name="count">new max count of cached image headers.</param>
        /// <param name="evict_now">true: evict the image headers should be removed by the eviction policy, false: wait for the next cache cleanup.</param>
        public static void LvImageHeaderCacheResize(uint count, bool evict_now)
        {
            __Internal.LvImageHeaderCacheResize(count, evict_now);
        }

        /// <summary>
        /// <para>Invalidate image header cache. Use NULL to invalidate all image headers.</para>
        /// <para>It's also automatically called when an image is invalidated.</para>
        /// </summary>
        /// <param name="src">pointer to an image source.</param>
        public static void LvImageHeaderCacheDrop(__IntPtr src)
        {
            __Internal.LvImageHeaderCacheDrop(src);
        }

        /// <summary>Return true if the image header cache is enabled.</summary>
        /// <returns>true: enabled, false: disabled.</returns>
        public static bool LvImageHeaderCacheIsEnabled()
        {
            var ___ret = __Internal.LvImageHeaderCacheIsEnabled();
            return ___ret;
        }
    }

    /// <summary>Options for text rendering.</summary>
    public enum LvTextFlagT
    {
        LV_TEXT_FLAG_NONE = 0,
        /// <summary>Ignore max-width to avoid automatic word wrapping</summary>
        LV_TEXT_FLAG_EXPAND = 1,
        /// <summary>Max-width is already equal to the longest line. (Used to skip some calculation)</summary>
        LV_TEXT_FLAG_FIT = 2
    }

    /// <summary>Label align policy</summary>
    public enum LvTextAlignT
    {
        /// <summary>Align text auto</summary>
        LV_TEXT_ALIGN_AUTO = 0,
        /// <summary>Align text to left</summary>
        LV_TEXT_ALIGN_LEFT = 1,
        /// <summary>Align text to center</summary>
        LV_TEXT_ALIGN_CENTER = 2,
        /// <summary>Align text to right</summary>
        LV_TEXT_ALIGN_RIGHT = 3
    }

    public unsafe partial class lv_text
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_text_get_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextGetSize(__IntPtr size_res, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, __IntPtr font, int letter_space, int line_space, int max_width, byte flag);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_text_get_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvTextGetWidth([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string txt, uint length, __IntPtr font, int letter_space);
        }

        /// <summary>Get size of a text</summary>
        /// <param name="size_res">pointer to a 'point_t' variable to store the result</param>
        /// <param name="text">pointer to a text</param>
        /// <param name="font">pointer to font of the text</param>
        /// <param name="letter_space">letter space of the text</param>
        /// <param name="line_space">line space of the text</param>
        /// <param name="max_width">max width of the text (break the lines to fit this size). Set COORD_MAX to avoid</param>
        /// <param name="flag">settings for the text from ::lv_text_flag_t</param>
        /// <remarks>line breaks</remarks>
        public static void LvTextGetSize(global::lvgl.LvPointT size_res, string text, global::lvgl.LvFontT font, int letter_space, int line_space, int max_width, byte flag)
        {
            var __arg0 = size_res is null ? __IntPtr.Zero : size_res.__Instance;
            var __arg2 = font is null ? __IntPtr.Zero : font.__Instance;
            __Internal.LvTextGetSize(__arg0, text, __arg2, letter_space, line_space, max_width, flag);
        }

        /// <summary>Give the length of a text with a given font</summary>
        /// <param name="txt">a '\0' terminate string</param>
        /// <param name="length">
        /// <para>length of 'txt' in byte count and not characters (&#193; is 1 character but 2 bytes in</para>
        /// <para>UTF-8)</para>
        /// </param>
        /// <param name="font">pointer to a font</param>
        /// <param name="letter_space">letter space</param>
        /// <returns>length of a char_num long text</returns>
        public static int LvTextGetWidth(string txt, uint length, global::lvgl.LvFontT font, int letter_space)
        {
            var __arg2 = font is null ? __IntPtr.Zero : font.__Instance;
            var ___ret = __Internal.LvTextGetWidth(txt, length, __arg2, letter_space);
            return ___ret;
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public enum LvBaseDirT
    {
        LV_BASE_DIR_LTR = 0,
        LV_BASE_DIR_RTL = 1,
        LV_BASE_DIR_AUTO = 2,
        LV_BASE_DIR_NEUTRAL = 32,
        LV_BASE_DIR_WEAK = 33
    }

    public enum LvLayoutT
    {
        LV_LAYOUT_NONE = 0,
        LV_LAYOUT_FLEX = 1,
        LV_LAYOUT_GRID = 2,
        LV_LAYOUT_LAST = 3
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvLayoutUpdateCbT(__IntPtr __0, __IntPtr user_data);

    public unsafe partial class LvLayoutDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr cb;
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_layout_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvLayoutDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvLayoutDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvLayoutDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvLayoutDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvLayoutDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvLayoutDscT(native.ToPointer(), skipVTables);
        }

        internal static LvLayoutDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvLayoutDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvLayoutDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvLayoutDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvLayoutDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvLayoutDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvLayoutDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvLayoutDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvLayoutDscT(global::lvgl.LvLayoutDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvLayoutDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvLayoutDscT.__Internal*) __Instance) = *((global::lvgl.LvLayoutDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvLayoutUpdateCbT Cb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvLayoutUpdateCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvLayoutUpdateCbT));
            }

            set
            {
                ((__Internal*)__Instance)->cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class lv_layout
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_layout_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLayoutInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_layout_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLayoutDeinit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_layout_register", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvLayoutRegister(__IntPtr cb, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_layout_apply", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLayoutApply(__IntPtr obj);
        }

        /// <summary>
        /// <para>********************</para>
        /// <para>GLOBAL PROTOTYPES</para>
        /// <para>********************</para>
        /// </summary>
        public static void LvLayoutInit()
        {
            __Internal.LvLayoutInit();
        }

        public static void LvLayoutDeinit()
        {
            __Internal.LvLayoutDeinit();
        }

        /// <summary>Register a new layout</summary>
        /// <param name="cb">the layout update callback</param>
        /// <param name="user_data">custom data that will be passed to `cb`</param>
        /// <returns>the ID of the new layout</returns>
        public static uint LvLayoutRegister(global::lvgl.LvLayoutUpdateCbT cb, __IntPtr user_data)
        {
            var __arg0 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            var ___ret = __Internal.LvLayoutRegister(__arg0, user_data);
            return ___ret;
        }

        /// <summary>Update the layout of a widget</summary>
        /// <param name="obj">pointer to a widget</param>
        public static void LvLayoutApply(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvLayoutApply(__arg0);
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public enum LvFlexAlignT
    {
        LV_FLEX_ALIGN_START = 0,
        LV_FLEX_ALIGN_END = 1,
        LV_FLEX_ALIGN_CENTER = 2,
        LV_FLEX_ALIGN_SPACE_EVENLY = 3,
        LV_FLEX_ALIGN_SPACE_AROUND = 4,
        LV_FLEX_ALIGN_SPACE_BETWEEN = 5
    }

    public enum LvFlexFlowT
    {
        LV_FLEX_FLOW_ROW = 0,
        LV_FLEX_FLOW_COLUMN = 1,
        LV_FLEX_FLOW_ROW_WRAP = 4,
        LV_FLEX_FLOW_ROW_REVERSE = 8,
        LV_FLEX_FLOW_ROW_WRAP_REVERSE = 12,
        LV_FLEX_FLOW_COLUMN_WRAP = 5,
        LV_FLEX_FLOW_COLUMN_REVERSE = 9,
        LV_FLEX_FLOW_COLUMN_WRAP_REVERSE = 13
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class lv_flex
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_flex_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvFlexInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_flex_flow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetFlexFlow(__IntPtr obj, global::lvgl.LvFlexFlowT flow);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_flex_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetFlexAlign(__IntPtr obj, global::lvgl.LvFlexAlignT main_place, global::lvgl.LvFlexAlignT cross_place, global::lvgl.LvFlexAlignT track_cross_place);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_flex_grow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetFlexGrow(__IntPtr obj, byte grow);
        }

        /// <summary>Initialize a flex layout the default values</summary>
        /// <param name="flex">pointer to a flex layout descriptor</param>
        public static void LvFlexInit()
        {
            __Internal.LvFlexInit();
        }

        /// <summary>Set how the item should flow</summary>
        /// <param name="obj">pointer to an object. The parent must have flex layout else nothing will happen.</param>
        /// <param name="flow">an element of `lv_flex_flow_t`.</param>
        public static void LvObjSetFlexFlow(global::lvgl.LvObjT obj, global::lvgl.LvFlexFlowT flow)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetFlexFlow(__arg0, flow);
        }

        /// <summary>Set how to place (where to align) the items and tracks</summary>
        /// <param name="obj">pointer to an object. The parent must have flex layout else nothing will happen.</param>
        /// <param name="main_place">where to place the items on main axis (in their track). Any value of `lv_flex_align_t`.</param>
        /// <param name="cross_place">where to place the item in their track on the cross axis. `LV_FLEX_ALIGN_START/END/CENTER`</param>
        /// <param name="track_cross_place">where to place the tracks in the cross direction. Any value of `lv_flex_align_t`.</param>
        public static void LvObjSetFlexAlign(global::lvgl.LvObjT obj, global::lvgl.LvFlexAlignT main_place, global::lvgl.LvFlexAlignT cross_place, global::lvgl.LvFlexAlignT track_cross_place)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetFlexAlign(__arg0, main_place, cross_place, track_cross_place);
        }

        /// <summary>Sets the width or height (on main axis) to grow the object in order fill the free space</summary>
        /// <param name="obj">pointer to an object. The parent must have flex layout else nothing will happen.</param>
        /// <param name="grow">a value to set how much free space to take proportionally to other growing items.</param>
        public static void LvObjSetFlexGrow(global::lvgl.LvObjT obj, byte grow)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetFlexGrow(__arg0, grow);
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public enum LvGridAlignT
    {
        LV_GRID_ALIGN_START = 0,
        LV_GRID_ALIGN_CENTER = 1,
        LV_GRID_ALIGN_END = 2,
        LV_GRID_ALIGN_STRETCH = 3,
        LV_GRID_ALIGN_SPACE_EVENLY = 4,
        LV_GRID_ALIGN_SPACE_AROUND = 5,
        LV_GRID_ALIGN_SPACE_BETWEEN = 6
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class lv_grid
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_grid_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGridInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_grid_dsc_array", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetGridDscArray(__IntPtr obj, int[] col_dsc, int[] row_dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_grid_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetGridAlign(__IntPtr obj, global::lvgl.LvGridAlignT column_align, global::lvgl.LvGridAlignT row_align);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_grid_cell", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetGridCell(__IntPtr obj, global::lvgl.LvGridAlignT column_align, int col_pos, int col_span, global::lvgl.LvGridAlignT row_align, int row_pos, int row_span);
        }

        /// <summary>
        /// <para>********************</para>
        /// <para>GLOBAL PROTOTYPES</para>
        /// <para>********************</para>
        /// </summary>
        public static void LvGridInit()
        {
            __Internal.LvGridInit();
        }

        public static void LvObjSetGridDscArray(global::lvgl.LvObjT obj, int[] col_dsc, int[] row_dsc)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetGridDscArray(__arg0, col_dsc, row_dsc);
        }

        public static void LvObjSetGridAlign(global::lvgl.LvObjT obj, global::lvgl.LvGridAlignT column_align, global::lvgl.LvGridAlignT row_align)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetGridAlign(__arg0, column_align, row_align);
        }

        /// <summary>Set the cell of an object. The object's parent needs to have grid layout, else nothing will happen</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="column_align">the vertical alignment in the cell. `LV_GRID_START/END/CENTER/STRETCH`</param>
        /// <param name="col_pos">column ID</param>
        /// <param name="col_span">number of columns to take (&gt;= 1)</param>
        /// <param name="row_align">the horizontal alignment in the cell. `LV_GRID_START/END/CENTER/STRETCH`</param>
        /// <param name="row_pos">row ID</param>
        /// <param name="row_span">number of rows to take (&gt;= 1)</param>
        public static void LvObjSetGridCell(global::lvgl.LvObjT obj, global::lvgl.LvGridAlignT column_align, int col_pos, int col_span, global::lvgl.LvGridAlignT row_align, int row_pos, int row_span)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetGridCell(__arg0, column_align, col_pos, col_span, row_align, row_pos, row_span);
        }
    }

    public unsafe partial class lv_style_gen
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetWidth(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_min_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetMinWidth(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_max_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetMaxWidth(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetHeight(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_min_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetMinHeight(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_max_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetMaxHeight(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_length", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetLength(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetX(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetY(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetAlign(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_transform_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTransformWidth(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_transform_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTransformHeight(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_translate_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTranslateX(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_translate_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTranslateY(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_transform_scale_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTransformScaleX(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_transform_scale_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTransformScaleY(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_transform_rotation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTransformRotation(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_transform_pivot_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTransformPivotX(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_transform_pivot_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTransformPivotY(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_transform_skew_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTransformSkewX(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_transform_skew_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTransformSkewY(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_pad_top", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetPadTop(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_pad_bottom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetPadBottom(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_pad_left", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetPadLeft(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_pad_right", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetPadRight(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_pad_row", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetPadRow(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_pad_column", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetPadColumn(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_margin_top", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetMarginTop(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_margin_bottom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetMarginBottom(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_margin_left", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetMarginLeft(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_margin_right", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetMarginRight(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_bg_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBgColor(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_bg_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBgOpa(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_bg_grad_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBgGradColor(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_bg_grad_dir", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBgGradDir(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_bg_main_stop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBgMainStop(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_bg_grad_stop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBgGradStop(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_bg_main_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBgMainOpa(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_bg_grad_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBgGradOpa(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_bg_grad", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBgGrad(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_bg_image_src", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBgImageSrc(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_bg_image_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBgImageOpa(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_bg_image_recolor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBgImageRecolor(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_bg_image_recolor_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBgImageRecolorOpa(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_bg_image_tiled", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBgImageTiled(__IntPtr style, bool value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_border_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBorderColor(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_border_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBorderOpa(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_border_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBorderWidth(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_border_side", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBorderSide(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_border_post", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBorderPost(__IntPtr style, bool value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_outline_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetOutlineWidth(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_outline_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetOutlineColor(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_outline_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetOutlineOpa(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_outline_pad", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetOutlinePad(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_shadow_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetShadowWidth(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_shadow_offset_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetShadowOffsetX(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_shadow_offset_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetShadowOffsetY(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_shadow_spread", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetShadowSpread(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_shadow_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetShadowColor(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_shadow_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetShadowOpa(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_image_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetImageOpa(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_image_recolor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetImageRecolor(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_image_recolor_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetImageRecolorOpa(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_line_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetLineWidth(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_line_dash_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetLineDashWidth(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_line_dash_gap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetLineDashGap(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_line_rounded", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetLineRounded(__IntPtr style, bool value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_line_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetLineColor(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_line_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetLineOpa(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_arc_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetArcWidth(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_arc_rounded", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetArcRounded(__IntPtr style, bool value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_arc_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetArcColor(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_arc_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetArcOpa(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_arc_image_src", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetArcImageSrc(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_text_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTextColor(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_text_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTextOpa(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_text_font", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTextFont(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_text_letter_space", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTextLetterSpace(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_text_line_space", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTextLineSpace(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_text_decor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTextDecor(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_text_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTextAlign(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_radius", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetRadius(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_clip_corner", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetClipCorner(__IntPtr style, bool value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetOpa(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_opa_layered", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetOpaLayered(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_color_filter_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetColorFilterDsc(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_color_filter_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetColorFilterOpa(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_anim", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetAnim(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_anim_duration", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetAnimDuration(__IntPtr style, uint value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_transition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetTransition(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_blend_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBlendMode(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_layout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetLayout(__IntPtr style, ushort value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_base_dir", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBaseDir(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_bitmap_mask_src", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetBitmapMaskSrc(__IntPtr style, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_rotary_sensitivity", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetRotarySensitivity(__IntPtr style, uint value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_flex_flow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetFlexFlow(__IntPtr style, global::lvgl.LvFlexFlowT value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_flex_main_place", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetFlexMainPlace(__IntPtr style, global::lvgl.LvFlexAlignT value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_flex_cross_place", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetFlexCrossPlace(__IntPtr style, global::lvgl.LvFlexAlignT value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_flex_track_place", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetFlexTrackPlace(__IntPtr style, global::lvgl.LvFlexAlignT value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_flex_grow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetFlexGrow(__IntPtr style, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_grid_column_dsc_array", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetGridColumnDscArray(__IntPtr style, int* value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_grid_column_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetGridColumnAlign(__IntPtr style, global::lvgl.LvGridAlignT value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_grid_row_dsc_array", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetGridRowDscArray(__IntPtr style, int* value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_grid_row_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetGridRowAlign(__IntPtr style, global::lvgl.LvGridAlignT value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_grid_cell_column_pos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetGridCellColumnPos(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_grid_cell_x_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetGridCellXAlign(__IntPtr style, global::lvgl.LvGridAlignT value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_grid_cell_column_span", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetGridCellColumnSpan(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_grid_cell_row_pos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetGridCellRowPos(__IntPtr style, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_grid_cell_y_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetGridCellYAlign(__IntPtr style, global::lvgl.LvGridAlignT value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_style_set_grid_cell_row_span", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvStyleSetGridCellRowSpan(__IntPtr style, int value);
        }

        public static void LvStyleSetWidth(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetWidth(__arg0, value);
        }

        public static void LvStyleSetMinWidth(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetMinWidth(__arg0, value);
        }

        public static void LvStyleSetMaxWidth(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetMaxWidth(__arg0, value);
        }

        public static void LvStyleSetHeight(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetHeight(__arg0, value);
        }

        public static void LvStyleSetMinHeight(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetMinHeight(__arg0, value);
        }

        public static void LvStyleSetMaxHeight(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetMaxHeight(__arg0, value);
        }

        public static void LvStyleSetLength(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetLength(__arg0, value);
        }

        public static void LvStyleSetX(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetX(__arg0, value);
        }

        public static void LvStyleSetY(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetY(__arg0, value);
        }

        public static void LvStyleSetAlign(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetAlign(__arg0, value);
        }

        public static void LvStyleSetTransformWidth(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetTransformWidth(__arg0, value);
        }

        public static void LvStyleSetTransformHeight(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetTransformHeight(__arg0, value);
        }

        public static void LvStyleSetTranslateX(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetTranslateX(__arg0, value);
        }

        public static void LvStyleSetTranslateY(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetTranslateY(__arg0, value);
        }

        public static void LvStyleSetTransformScaleX(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetTransformScaleX(__arg0, value);
        }

        public static void LvStyleSetTransformScaleY(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetTransformScaleY(__arg0, value);
        }

        public static void LvStyleSetTransformRotation(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetTransformRotation(__arg0, value);
        }

        public static void LvStyleSetTransformPivotX(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetTransformPivotX(__arg0, value);
        }

        public static void LvStyleSetTransformPivotY(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetTransformPivotY(__arg0, value);
        }

        public static void LvStyleSetTransformSkewX(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetTransformSkewX(__arg0, value);
        }

        public static void LvStyleSetTransformSkewY(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetTransformSkewY(__arg0, value);
        }

        public static void LvStyleSetPadTop(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetPadTop(__arg0, value);
        }

        public static void LvStyleSetPadBottom(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetPadBottom(__arg0, value);
        }

        public static void LvStyleSetPadLeft(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetPadLeft(__arg0, value);
        }

        public static void LvStyleSetPadRight(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetPadRight(__arg0, value);
        }

        public static void LvStyleSetPadRow(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetPadRow(__arg0, value);
        }

        public static void LvStyleSetPadColumn(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetPadColumn(__arg0, value);
        }

        public static void LvStyleSetMarginTop(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetMarginTop(__arg0, value);
        }

        public static void LvStyleSetMarginBottom(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetMarginBottom(__arg0, value);
        }

        public static void LvStyleSetMarginLeft(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetMarginLeft(__arg0, value);
        }

        public static void LvStyleSetMarginRight(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetMarginRight(__arg0, value);
        }

        public static void LvStyleSetBgColor(global::lvgl.LvStyleT style, global::lvgl.LvColorT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvStyleSetBgColor(__arg0, __arg1);
        }

        public static void LvStyleSetBgOpa(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetBgOpa(__arg0, value);
        }

        public static void LvStyleSetBgGradColor(global::lvgl.LvStyleT style, global::lvgl.LvColorT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvStyleSetBgGradColor(__arg0, __arg1);
        }

        public static void LvStyleSetBgGradDir(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetBgGradDir(__arg0, value);
        }

        public static void LvStyleSetBgMainStop(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetBgMainStop(__arg0, value);
        }

        public static void LvStyleSetBgGradStop(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetBgGradStop(__arg0, value);
        }

        public static void LvStyleSetBgMainOpa(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetBgMainOpa(__arg0, value);
        }

        public static void LvStyleSetBgGradOpa(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetBgGradOpa(__arg0, value);
        }

        public static void LvStyleSetBgGrad(global::lvgl.LvStyleT style, global::lvgl.LvGradDscT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            var __arg1 = value is null ? __IntPtr.Zero : value.__Instance;
            __Internal.LvStyleSetBgGrad(__arg0, __arg1);
        }

        public static void LvStyleSetBgImageSrc(global::lvgl.LvStyleT style, __IntPtr value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetBgImageSrc(__arg0, value);
        }

        public static void LvStyleSetBgImageOpa(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetBgImageOpa(__arg0, value);
        }

        public static void LvStyleSetBgImageRecolor(global::lvgl.LvStyleT style, global::lvgl.LvColorT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvStyleSetBgImageRecolor(__arg0, __arg1);
        }

        public static void LvStyleSetBgImageRecolorOpa(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetBgImageRecolorOpa(__arg0, value);
        }

        public static void LvStyleSetBgImageTiled(global::lvgl.LvStyleT style, bool value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetBgImageTiled(__arg0, value);
        }

        public static void LvStyleSetBorderColor(global::lvgl.LvStyleT style, global::lvgl.LvColorT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvStyleSetBorderColor(__arg0, __arg1);
        }

        public static void LvStyleSetBorderOpa(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetBorderOpa(__arg0, value);
        }

        public static void LvStyleSetBorderWidth(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetBorderWidth(__arg0, value);
        }

        public static void LvStyleSetBorderSide(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetBorderSide(__arg0, value);
        }

        public static void LvStyleSetBorderPost(global::lvgl.LvStyleT style, bool value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetBorderPost(__arg0, value);
        }

        public static void LvStyleSetOutlineWidth(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetOutlineWidth(__arg0, value);
        }

        public static void LvStyleSetOutlineColor(global::lvgl.LvStyleT style, global::lvgl.LvColorT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvStyleSetOutlineColor(__arg0, __arg1);
        }

        public static void LvStyleSetOutlineOpa(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetOutlineOpa(__arg0, value);
        }

        public static void LvStyleSetOutlinePad(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetOutlinePad(__arg0, value);
        }

        public static void LvStyleSetShadowWidth(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetShadowWidth(__arg0, value);
        }

        public static void LvStyleSetShadowOffsetX(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetShadowOffsetX(__arg0, value);
        }

        public static void LvStyleSetShadowOffsetY(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetShadowOffsetY(__arg0, value);
        }

        public static void LvStyleSetShadowSpread(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetShadowSpread(__arg0, value);
        }

        public static void LvStyleSetShadowColor(global::lvgl.LvStyleT style, global::lvgl.LvColorT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvStyleSetShadowColor(__arg0, __arg1);
        }

        public static void LvStyleSetShadowOpa(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetShadowOpa(__arg0, value);
        }

        public static void LvStyleSetImageOpa(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetImageOpa(__arg0, value);
        }

        public static void LvStyleSetImageRecolor(global::lvgl.LvStyleT style, global::lvgl.LvColorT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvStyleSetImageRecolor(__arg0, __arg1);
        }

        public static void LvStyleSetImageRecolorOpa(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetImageRecolorOpa(__arg0, value);
        }

        public static void LvStyleSetLineWidth(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetLineWidth(__arg0, value);
        }

        public static void LvStyleSetLineDashWidth(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetLineDashWidth(__arg0, value);
        }

        public static void LvStyleSetLineDashGap(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetLineDashGap(__arg0, value);
        }

        public static void LvStyleSetLineRounded(global::lvgl.LvStyleT style, bool value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetLineRounded(__arg0, value);
        }

        public static void LvStyleSetLineColor(global::lvgl.LvStyleT style, global::lvgl.LvColorT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvStyleSetLineColor(__arg0, __arg1);
        }

        public static void LvStyleSetLineOpa(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetLineOpa(__arg0, value);
        }

        public static void LvStyleSetArcWidth(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetArcWidth(__arg0, value);
        }

        public static void LvStyleSetArcRounded(global::lvgl.LvStyleT style, bool value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetArcRounded(__arg0, value);
        }

        public static void LvStyleSetArcColor(global::lvgl.LvStyleT style, global::lvgl.LvColorT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvStyleSetArcColor(__arg0, __arg1);
        }

        public static void LvStyleSetArcOpa(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetArcOpa(__arg0, value);
        }

        public static void LvStyleSetArcImageSrc(global::lvgl.LvStyleT style, __IntPtr value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetArcImageSrc(__arg0, value);
        }

        public static void LvStyleSetTextColor(global::lvgl.LvStyleT style, global::lvgl.LvColorT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvStyleSetTextColor(__arg0, __arg1);
        }

        public static void LvStyleSetTextOpa(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetTextOpa(__arg0, value);
        }

        public static void LvStyleSetTextFont(global::lvgl.LvStyleT style, global::lvgl.LvFontT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            var __arg1 = value is null ? __IntPtr.Zero : value.__Instance;
            __Internal.LvStyleSetTextFont(__arg0, __arg1);
        }

        public static void LvStyleSetTextLetterSpace(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetTextLetterSpace(__arg0, value);
        }

        public static void LvStyleSetTextLineSpace(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetTextLineSpace(__arg0, value);
        }

        public static void LvStyleSetTextDecor(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetTextDecor(__arg0, value);
        }

        public static void LvStyleSetTextAlign(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetTextAlign(__arg0, value);
        }

        public static void LvStyleSetRadius(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetRadius(__arg0, value);
        }

        public static void LvStyleSetClipCorner(global::lvgl.LvStyleT style, bool value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetClipCorner(__arg0, value);
        }

        public static void LvStyleSetOpa(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetOpa(__arg0, value);
        }

        public static void LvStyleSetOpaLayered(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetOpaLayered(__arg0, value);
        }

        public static void LvStyleSetColorFilterDsc(global::lvgl.LvStyleT style, global::lvgl.LvColorFilterDscT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            var __arg1 = value is null ? __IntPtr.Zero : value.__Instance;
            __Internal.LvStyleSetColorFilterDsc(__arg0, __arg1);
        }

        public static void LvStyleSetColorFilterOpa(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetColorFilterOpa(__arg0, value);
        }

        public static void LvStyleSetAnim(global::lvgl.LvStyleT style, global::lvgl.LvAnimT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            var __arg1 = value is null ? __IntPtr.Zero : value.__Instance;
            __Internal.LvStyleSetAnim(__arg0, __arg1);
        }

        public static void LvStyleSetAnimDuration(global::lvgl.LvStyleT style, uint value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetAnimDuration(__arg0, value);
        }

        public static void LvStyleSetTransition(global::lvgl.LvStyleT style, global::lvgl.LvStyleTransitionDscT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            var __arg1 = value is null ? __IntPtr.Zero : value.__Instance;
            __Internal.LvStyleSetTransition(__arg0, __arg1);
        }

        public static void LvStyleSetBlendMode(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetBlendMode(__arg0, value);
        }

        public static void LvStyleSetLayout(global::lvgl.LvStyleT style, ushort value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetLayout(__arg0, value);
        }

        public static void LvStyleSetBaseDir(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetBaseDir(__arg0, value);
        }

        public static void LvStyleSetBitmapMaskSrc(global::lvgl.LvStyleT style, __IntPtr value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetBitmapMaskSrc(__arg0, value);
        }

        public static void LvStyleSetRotarySensitivity(global::lvgl.LvStyleT style, uint value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetRotarySensitivity(__arg0, value);
        }

        public static void LvStyleSetFlexFlow(global::lvgl.LvStyleT style, global::lvgl.LvFlexFlowT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetFlexFlow(__arg0, value);
        }

        public static void LvStyleSetFlexMainPlace(global::lvgl.LvStyleT style, global::lvgl.LvFlexAlignT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetFlexMainPlace(__arg0, value);
        }

        public static void LvStyleSetFlexCrossPlace(global::lvgl.LvStyleT style, global::lvgl.LvFlexAlignT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetFlexCrossPlace(__arg0, value);
        }

        public static void LvStyleSetFlexTrackPlace(global::lvgl.LvStyleT style, global::lvgl.LvFlexAlignT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetFlexTrackPlace(__arg0, value);
        }

        public static void LvStyleSetFlexGrow(global::lvgl.LvStyleT style, byte value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetFlexGrow(__arg0, value);
        }

        public static void LvStyleSetGridColumnDscArray(global::lvgl.LvStyleT style, ref int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            fixed (int* __value1 = &value)
            {
                var __arg1 = __value1;
                __Internal.LvStyleSetGridColumnDscArray(__arg0, __arg1);
            }
        }

        public static void LvStyleSetGridColumnAlign(global::lvgl.LvStyleT style, global::lvgl.LvGridAlignT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetGridColumnAlign(__arg0, value);
        }

        public static void LvStyleSetGridRowDscArray(global::lvgl.LvStyleT style, ref int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            fixed (int* __value1 = &value)
            {
                var __arg1 = __value1;
                __Internal.LvStyleSetGridRowDscArray(__arg0, __arg1);
            }
        }

        public static void LvStyleSetGridRowAlign(global::lvgl.LvStyleT style, global::lvgl.LvGridAlignT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetGridRowAlign(__arg0, value);
        }

        public static void LvStyleSetGridCellColumnPos(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetGridCellColumnPos(__arg0, value);
        }

        public static void LvStyleSetGridCellXAlign(global::lvgl.LvStyleT style, global::lvgl.LvGridAlignT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetGridCellXAlign(__arg0, value);
        }

        public static void LvStyleSetGridCellColumnSpan(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetGridCellColumnSpan(__arg0, value);
        }

        public static void LvStyleSetGridCellRowPos(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetGridCellRowPos(__arg0, value);
        }

        public static void LvStyleSetGridCellYAlign(global::lvgl.LvStyleT style, global::lvgl.LvGridAlignT value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetGridCellYAlign(__arg0, value);
        }

        public static void LvStyleSetGridCellRowSpan(global::lvgl.LvStyleT style, int value)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvStyleSetGridCellRowSpan(__arg0, value);
        }

        public static byte LvStyleConstPropIdWIDTH
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_WIDTH;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdMIN_WIDTH
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_MIN_WIDTH;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdMAX_WIDTH
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_MAX_WIDTH;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdHEIGHT
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_HEIGHT;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdMIN_HEIGHT
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_MIN_HEIGHT;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdMAX_HEIGHT
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_MAX_HEIGHT;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdLENGTH
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_LENGTH;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdX
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_X;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdY
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_Y;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdALIGN
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_ALIGN;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTRANSFORM_WIDTH
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TRANSFORM_WIDTH;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTRANSFORM_HEIGHT
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TRANSFORM_HEIGHT;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTRANSLATE_X
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TRANSLATE_X;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTRANSLATE_Y
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TRANSLATE_Y;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTRANSFORM_SCALE_X
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TRANSFORM_SCALE_X;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTRANSFORM_SCALE_Y
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TRANSFORM_SCALE_Y;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTRANSFORM_ROTATION
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TRANSFORM_ROTATION;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTRANSFORM_PIVOT_X
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TRANSFORM_PIVOT_X;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTRANSFORM_PIVOT_Y
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TRANSFORM_PIVOT_Y;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTRANSFORM_SKEW_X
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TRANSFORM_SKEW_X;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTRANSFORM_SKEW_Y
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TRANSFORM_SKEW_Y;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdPAD_TOP
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_PAD_TOP;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdPAD_BOTTOM
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_PAD_BOTTOM;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdPAD_LEFT
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_PAD_LEFT;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdPAD_RIGHT
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_PAD_RIGHT;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdPAD_ROW
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_PAD_ROW;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdPAD_COLUMN
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_PAD_COLUMN;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdMARGIN_TOP
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_MARGIN_TOP;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdMARGIN_BOTTOM
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_MARGIN_BOTTOM;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdMARGIN_LEFT
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_MARGIN_LEFT;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdMARGIN_RIGHT
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_MARGIN_RIGHT;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBG_COLOR
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BG_COLOR;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBG_OPA
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BG_OPA;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBG_GRAD_COLOR
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BG_GRAD_COLOR;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBG_GRAD_DIR
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BG_GRAD_DIR;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBG_MAIN_STOP
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BG_MAIN_STOP;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBG_GRAD_STOP
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BG_GRAD_STOP;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBG_MAIN_OPA
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BG_MAIN_OPA;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBG_GRAD_OPA
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BG_GRAD_OPA;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBG_GRAD
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BG_GRAD;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBG_IMAGE_SRC
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BG_IMAGE_SRC;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBG_IMAGE_OPA
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BG_IMAGE_OPA;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBG_IMAGE_RECOLOR
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BG_IMAGE_RECOLOR;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBG_IMAGE_RECOLOR_OPA
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BG_IMAGE_RECOLOR_OPA;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBG_IMAGE_TILED
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BG_IMAGE_TILED;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBORDER_COLOR
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BORDER_COLOR;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBORDER_OPA
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BORDER_OPA;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBORDER_WIDTH
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BORDER_WIDTH;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBORDER_SIDE
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BORDER_SIDE;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBORDER_POST
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BORDER_POST;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdOUTLINE_WIDTH
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_OUTLINE_WIDTH;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdOUTLINE_COLOR
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_OUTLINE_COLOR;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdOUTLINE_OPA
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_OUTLINE_OPA;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdOUTLINE_PAD
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_OUTLINE_PAD;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdSHADOW_WIDTH
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_SHADOW_WIDTH;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdSHADOW_OFFSET_X
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_SHADOW_OFFSET_X;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdSHADOW_OFFSET_Y
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_SHADOW_OFFSET_Y;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdSHADOW_SPREAD
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_SHADOW_SPREAD;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdSHADOW_COLOR
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_SHADOW_COLOR;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdSHADOW_OPA
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_SHADOW_OPA;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdIMAGE_OPA
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_IMAGE_OPA;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdIMAGE_RECOLOR
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_IMAGE_RECOLOR;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdIMAGE_RECOLOR_OPA
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_IMAGE_RECOLOR_OPA;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdLINE_WIDTH
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_LINE_WIDTH;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdLINE_DASH_WIDTH
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_LINE_DASH_WIDTH;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdLINE_DASH_GAP
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_LINE_DASH_GAP;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdLINE_ROUNDED
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_LINE_ROUNDED;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdLINE_COLOR
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_LINE_COLOR;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdLINE_OPA
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_LINE_OPA;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdARC_WIDTH
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_ARC_WIDTH;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdARC_ROUNDED
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_ARC_ROUNDED;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdARC_COLOR
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_ARC_COLOR;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdARC_OPA
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_ARC_OPA;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdARC_IMAGE_SRC
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_ARC_IMAGE_SRC;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTEXT_COLOR
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TEXT_COLOR;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTEXT_OPA
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TEXT_OPA;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTEXT_FONT
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TEXT_FONT;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTEXT_LETTER_SPACE
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TEXT_LETTER_SPACE;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTEXT_LINE_SPACE
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TEXT_LINE_SPACE;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTEXT_DECOR
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TEXT_DECOR;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTEXT_ALIGN
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TEXT_ALIGN;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdRADIUS
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_RADIUS;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdCLIP_CORNER
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_CLIP_CORNER;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdOPA
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_OPA;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdOPA_LAYERED
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_OPA_LAYERED;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdCOLOR_FILTER_DSC
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_COLOR_FILTER_DSC;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdCOLOR_FILTER_OPA
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_COLOR_FILTER_OPA;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdANIM
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_ANIM;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdANIM_DURATION
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_ANIM_DURATION;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdTRANSITION
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_TRANSITION;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBLEND_MODE
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BLEND_MODE;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdLAYOUT
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_LAYOUT;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBASE_DIR
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BASE_DIR;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdBITMAP_MASK_SRC
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_BITMAP_MASK_SRC;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdROTARY_SENSITIVITY
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_ROTARY_SENSITIVITY;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdFLEX_FLOW
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_FLEX_FLOW;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdFLEX_MAIN_PLACE
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_FLEX_MAIN_PLACE;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdFLEX_CROSS_PLACE
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_FLEX_CROSS_PLACE;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdFLEX_TRACK_PLACE
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_FLEX_TRACK_PLACE;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdFLEX_GROW
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_FLEX_GROW;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdGRID_COLUMN_DSC_ARRAY
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_GRID_COLUMN_DSC_ARRAY;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdGRID_COLUMN_ALIGN
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_GRID_COLUMN_ALIGN;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdGRID_ROW_DSC_ARRAY
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_GRID_ROW_DSC_ARRAY;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdGRID_ROW_ALIGN
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_GRID_ROW_ALIGN;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdGRID_CELL_COLUMN_POS
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_GRID_CELL_COLUMN_POS;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdGRID_CELL_X_ALIGN
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_GRID_CELL_X_ALIGN;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdGRID_CELL_COLUMN_SPAN
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_GRID_CELL_COLUMN_SPAN;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdGRID_CELL_ROW_POS
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_GRID_CELL_ROW_POS;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdGRID_CELL_Y_ALIGN
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_GRID_CELL_Y_ALIGN;
                return *__ptr;
            }
        }

        public static byte LvStyleConstPropIdGRID_CELL_ROW_SPAN
        {
            get
            {
                var __ptr = (byte*)global::lvgl.__Symbols.lvgl._lv_style_const_prop_id_GRID_CELL_ROW_SPAN;
                return *__ptr;
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public enum LvObjTreeWalkResT
    {
        LV_OBJ_TREE_WALK_NEXT = 0,
        LV_OBJ_TREE_WALK_SKIP_CHILDREN = 1,
        LV_OBJ_TREE_WALK_END = 2
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::lvgl.LvObjTreeWalkResT LvObjTreeWalkCbT(__IntPtr __0, __IntPtr __1);

    public unsafe partial class lv_obj_tree
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_delete", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjDelete(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_clean", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjClean(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_delete_delayed", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjDeleteDelayed(__IntPtr obj, uint delay_ms);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_delete_anim_completed_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjDeleteAnimCompletedCb(__IntPtr a);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_delete_async", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjDeleteAsync(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_parent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetParent(__IntPtr obj, __IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_swap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSwap(__IntPtr obj1, __IntPtr obj2);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_move_to_index", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjMoveToIndex(__IntPtr obj, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_screen", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjGetScreen(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_display", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjGetDisplay(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_parent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjGetParent(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_child", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjGetChild(__IntPtr obj, int idx);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_child_by_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjGetChildByType(__IntPtr obj, int idx, __IntPtr class_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_sibling", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjGetSibling(__IntPtr obj, int idx);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_sibling_by_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjGetSiblingByType(__IntPtr obj, int idx, __IntPtr class_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_child_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvObjGetChildCount(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_child_count_by_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvObjGetChildCountByType(__IntPtr obj, __IntPtr class_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_index", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetIndex(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_index_by_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetIndexByType(__IntPtr obj, __IntPtr class_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_tree_walk", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjTreeWalk(__IntPtr start_obj, __IntPtr cb, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_dump_tree", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjDumpTree(__IntPtr start_ob);
        }

        /// <summary>
        /// <para>Delete an object and all of its children.</para>
        /// <para>Also remove the objects from their group and remove all animations (if any).</para>
        /// <para>Send `LV_EVENT_DELETED` to deleted objects.</para>
        /// </summary>
        /// <param name="obj">pointer to an object</param>
        public static void LvObjDelete(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjDelete(__arg0);
        }

        /// <summary>
        /// <para>Delete all children of an object.</para>
        /// <para>Also remove the objects from their group and remove all animations (if any).</para>
        /// <para>Send `LV_EVENT_DELETED` to deleted objects.</para>
        /// </summary>
        /// <param name="obj">pointer to an object</param>
        public static void LvObjClean(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjClean(__arg0);
        }

        /// <summary>Delete an object after some delay</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="delay_ms">time to wait before delete in milliseconds</param>
        public static void LvObjDeleteDelayed(global::lvgl.LvObjT obj, uint delay_ms)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjDeleteDelayed(__arg0, delay_ms);
        }

        /// <summary>A function to be easily used in animation ready callback to delete an object when the animation is ready</summary>
        /// <param name="a">pointer to the animation</param>
        public static void LvObjDeleteAnimCompletedCb(global::lvgl.LvAnimT a)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            __Internal.LvObjDeleteAnimCompletedCb(__arg0);
        }

        /// <summary>
        /// <para>Helper function for asynchronously deleting objects.</para>
        /// <para>Useful for cases where you can't delete an object directly in an `LV_EVENT_DELETE` handler (i.e. parent).</para>
        /// </summary>
        /// <param name="obj">object to delete</param>
        /// <remarks>lv_async_call</remarks>
        public static void LvObjDeleteAsync(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjDeleteAsync(__arg0);
        }

        /// <summary>Move the parent of an object. The relative coordinates will be kept.</summary>
        /// <param name="obj">pointer to an object whose parent needs to be changed</param>
        /// <param name="parent">pointer to the new parent</param>
        public static void LvObjSetParent(global::lvgl.LvObjT obj, global::lvgl.LvObjT parent)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = parent is null ? __IntPtr.Zero : parent.__Instance;
            __Internal.LvObjSetParent(__arg0, __arg1);
        }

        /// <summary>
        /// <para>Swap the positions of two objects.</para>
        /// <para>When used in listboxes, it can be used to sort the listbox items.</para>
        /// </summary>
        /// <param name="obj1">pointer to the first object</param>
        /// <param name="obj2">pointer to the second object</param>
        public static void LvObjSwap(global::lvgl.LvObjT obj1, global::lvgl.LvObjT obj2)
        {
            var __arg0 = obj1 is null ? __IntPtr.Zero : obj1.__Instance;
            var __arg1 = obj2 is null ? __IntPtr.Zero : obj2.__Instance;
            __Internal.LvObjSwap(__arg0, __arg1);
        }

        /// <summary>
        /// <para>moves the object to the given index in its parent.</para>
        /// <para>When used in listboxes, it can be used to sort the listbox items.</para>
        /// </summary>
        /// <param name="obj">pointer to the object to be moved.</param>
        /// <param name="index">new index in parent. -1 to count from the back</param>
        /// <remarks>
        /// <para>to move to the background: lv_obj_move_to_index(obj, 0)</para>
        /// <para>to move forward (up): lv_obj_move_to_index(obj, lv_obj_get_index(obj) - 1)</para>
        /// </remarks>
        public static void LvObjMoveToIndex(global::lvgl.LvObjT obj, int index)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjMoveToIndex(__arg0, index);
        }

        /// <summary>Get the screen of an object</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>pointer to the object's screen</returns>
        public static global::lvgl.LvObjT LvObjGetScreen(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetScreen(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the display of the object</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>pointer to the object's display</returns>
        public static global::lvgl.LvDisplayT LvObjGetDisplay(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetDisplay(__arg0);
            var __result0 = global::lvgl.LvDisplayT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the parent of an object</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the parent of the object. (NULL if `obj` was a screen)</returns>
        public static global::lvgl.LvObjT LvObjGetParent(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetParent(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the child of an object by the child's index.</summary>
        /// <param name="obj">pointer to an object whose child should be get</param>
        /// <param name="idx">
        /// <para>the index of the child.</para>
        /// <para>0: the oldest (firstly created) child</para>
        /// <para>1: the second oldest</para>
        /// <para>child count-1: the youngest</para>
        /// <para>-1: the youngest</para>
        /// <para>-2: the second youngest</para>
        /// </param>
        /// <returns>pointer to the child or NULL if the index was invalid</returns>
        public static global::lvgl.LvObjT LvObjGetChild(global::lvgl.LvObjT obj, int idx)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetChild(__arg0, idx);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the child of an object by the child's index. Consider the children only with a given type.</summary>
        /// <param name="obj">pointer to an object whose child should be get</param>
        /// <param name="idx">
        /// <para>the index of the child.</para>
        /// <para>0: the oldest (firstly created) child</para>
        /// <para>1: the second oldest</para>
        /// <para>child count-1: the youngest</para>
        /// <para>-1: the youngest</para>
        /// <para>-2: the second youngest</para>
        /// </param>
        /// <param name="class_p">the type of the children to check</param>
        /// <returns>pointer to the child or NULL if the index was invalid</returns>
        public static global::lvgl.LvObjT LvObjGetChildByType(global::lvgl.LvObjT obj, int idx, global::lvgl.LvObjClassT class_p)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg2 = class_p is null ? __IntPtr.Zero : class_p.__Instance;
            var ___ret = __Internal.LvObjGetChildByType(__arg0, idx, __arg2);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Return a sibling of an object</summary>
        /// <param name="obj">pointer to an object whose sibling should be get</param>
        /// <param name="idx">
        /// <para>0: `obj` itself</para>
        /// <para>-1: the first older sibling</para>
        /// <para>-2: the next older sibling</para>
        /// <para>1: the first younger sibling</para>
        /// <para>2: the next younger sibling</para>
        /// <para>etc</para>
        /// </param>
        /// <returns>pointer to the requested sibling  or NULL if there is no such sibling</returns>
        public static global::lvgl.LvObjT LvObjGetSibling(global::lvgl.LvObjT obj, int idx)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetSibling(__arg0, idx);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Return a sibling of an object. Consider the siblings only with a given type.</summary>
        /// <param name="obj">pointer to an object whose sibling should be get</param>
        /// <param name="idx">
        /// <para>0: `obj` itself</para>
        /// <para>-1: the first older sibling</para>
        /// <para>-2: the next older sibling</para>
        /// <para>1: the first younger sibling</para>
        /// <para>2: the next younger sibling</para>
        /// <para>etc</para>
        /// </param>
        /// <param name="class_p">the type of the children to check</param>
        /// <returns>pointer to the requested sibling  or NULL if there is no such sibling</returns>
        public static global::lvgl.LvObjT LvObjGetSiblingByType(global::lvgl.LvObjT obj, int idx, global::lvgl.LvObjClassT class_p)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg2 = class_p is null ? __IntPtr.Zero : class_p.__Instance;
            var ___ret = __Internal.LvObjGetSiblingByType(__arg0, idx, __arg2);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the number of children</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the number of children</returns>
        public static uint LvObjGetChildCount(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetChildCount(__arg0);
            return ___ret;
        }

        /// <summary>Get the number of children having a given type.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="class_p">the type of the children to check</param>
        /// <returns>the number of children</returns>
        public static uint LvObjGetChildCountByType(global::lvgl.LvObjT obj, global::lvgl.LvObjClassT class_p)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = class_p is null ? __IntPtr.Zero : class_p.__Instance;
            var ___ret = __Internal.LvObjGetChildCountByType(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Get the index of a child.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>
        /// <para>the child index of the object.</para>
        /// <para>E.g. 0: the oldest (firstly created child).</para>
        /// <para>(-1 if child could not be found or no parent exists)</para>
        /// </returns>
        public static int LvObjGetIndex(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetIndex(__arg0);
            return ___ret;
        }

        /// <summary>Get the index of a child. Consider the children only with a given type.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="class_p">the type of the children to check</param>
        /// <returns>
        /// <para>the child index of the object.</para>
        /// <para>E.g. 0: the oldest (firstly created child with the given class).</para>
        /// <para>(-1 if child could not be found or no parent exists)</para>
        /// </returns>
        public static int LvObjGetIndexByType(global::lvgl.LvObjT obj, global::lvgl.LvObjClassT class_p)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = class_p is null ? __IntPtr.Zero : class_p.__Instance;
            var ___ret = __Internal.LvObjGetIndexByType(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Iterate through all children of any object.</summary>
        /// <param name="start_obj">start integrating from this object</param>
        /// <param name="cb">call this callback on the objects</param>
        /// <param name="user_data">pointer to any user related data (will be passed to `cb`)</param>
        public static void LvObjTreeWalk(global::lvgl.LvObjT start_obj, global::lvgl.LvObjTreeWalkCbT cb, __IntPtr user_data)
        {
            var __arg0 = start_obj is null ? __IntPtr.Zero : start_obj.__Instance;
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.LvObjTreeWalk(__arg0, __arg1, user_data);
        }

        /// <summary>Iterate through all children of any object and print their ID.</summary>
        /// <param name="start_obj">start integrating from this object</param>
        public static void LvObjDumpTree(global::lvgl.LvObjT start_ob)
        {
            var __arg0 = start_ob is null ? __IntPtr.Zero : start_ob.__Instance;
            __Internal.LvObjDumpTree(__arg0);
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public enum LvDisplayRotationT
    {
        LV_DISPLAY_ROTATION_0 = 0,
        LV_DISPLAY_ROTATION_90 = 1,
        LV_DISPLAY_ROTATION_180 = 2,
        LV_DISPLAY_ROTATION_270 = 3
    }

    public enum LvDisplayRenderModeT
    {
        /// <summary>
        /// <para>Use the buffer(s) to render the screen is smaller parts.</para>
        /// <para>This way the buffers can be smaller then the display to save RAM. At least 1/10 screen size buffer(s) are recommended.</para>
        /// </summary>
        LV_DISPLAY_RENDER_MODE_PARTIAL = 0,
        /// <summary>
        /// <para>The buffer(s) has to be screen sized and LVGL will render into the correct location of the buffer.</para>
        /// <para>This way the buffer always contain the whole image. Only the changed ares will be updated.</para>
        /// <para>With 2 buffers the buffers' content are kept in sync automatically and in flush_cb only address change is required.</para>
        /// </summary>
        LV_DISPLAY_RENDER_MODE_DIRECT = 1,
        /// <summary>
        /// <para>Always redraw the whole screen even if only one pixel has been changed.</para>
        /// <para>With 2 buffers in flush_cb only and address change is required.</para>
        /// </summary>
        LV_DISPLAY_RENDER_MODE_FULL = 2
    }

    public enum LvScreenLoadAnimT
    {
        LV_SCR_LOAD_ANIM_NONE = 0,
        LV_SCR_LOAD_ANIM_OVER_LEFT = 1,
        LV_SCR_LOAD_ANIM_OVER_RIGHT = 2,
        LV_SCR_LOAD_ANIM_OVER_TOP = 3,
        LV_SCR_LOAD_ANIM_OVER_BOTTOM = 4,
        LV_SCR_LOAD_ANIM_MOVE_LEFT = 5,
        LV_SCR_LOAD_ANIM_MOVE_RIGHT = 6,
        LV_SCR_LOAD_ANIM_MOVE_TOP = 7,
        LV_SCR_LOAD_ANIM_MOVE_BOTTOM = 8,
        LV_SCR_LOAD_ANIM_FADE_IN = 9,
        LV_SCR_LOAD_ANIM_FADE_ON = 9,
        LV_SCR_LOAD_ANIM_FADE_OUT = 10,
        LV_SCR_LOAD_ANIM_OUT_LEFT = 11,
        LV_SCR_LOAD_ANIM_OUT_RIGHT = 12,
        LV_SCR_LOAD_ANIM_OUT_TOP = 13,
        LV_SCR_LOAD_ANIM_OUT_BOTTOM = 14
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvDisplayFlushCbT(__IntPtr disp, __IntPtr area, byte* px_map);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvDisplayFlushWaitCbT(__IntPtr disp);

    public unsafe partial class lv_display
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDisplayCreate(int hor_res, int ver_res);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_delete", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplayDelete(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_set_default", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplaySetDefault(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_default", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDisplayGetDefault();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_next", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDisplayGetNext(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_set_resolution", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplaySetResolution(__IntPtr disp, int hor_res, int ver_res);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_set_physical_resolution", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplaySetPhysicalResolution(__IntPtr disp, int hor_res, int ver_res);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_set_offset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplaySetOffset(__IntPtr disp, int x, int y);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_set_rotation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplaySetRotation(__IntPtr disp, global::lvgl.LvDisplayRotationT rotation);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_set_dpi", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplaySetDpi(__IntPtr disp, int dpi);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_horizontal_resolution", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvDisplayGetHorizontalResolution(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_vertical_resolution", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvDisplayGetVerticalResolution(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_physical_horizontal_resolution", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvDisplayGetPhysicalHorizontalResolution(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_physical_vertical_resolution", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvDisplayGetPhysicalVerticalResolution(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_offset_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvDisplayGetOffsetX(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_offset_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvDisplayGetOffsetY(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_rotation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::lvgl.LvDisplayRotationT LvDisplayGetRotation(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_dpi", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvDisplayGetDpi(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_set_buffers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplaySetBuffers(__IntPtr disp, __IntPtr buf1, __IntPtr buf2, uint buf_size, global::lvgl.LvDisplayRenderModeT render_mode);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_set_draw_buffers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplaySetDrawBuffers(__IntPtr disp, __IntPtr buf1, __IntPtr buf2);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_set_render_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplaySetRenderMode(__IntPtr disp, global::lvgl.LvDisplayRenderModeT render_mode);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_set_flush_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplaySetFlushCb(__IntPtr disp, __IntPtr flush_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_set_flush_wait_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplaySetFlushWaitCb(__IntPtr disp, __IntPtr wait_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_set_color_format", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplaySetColorFormat(__IntPtr disp, byte color_format);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_color_format", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvDisplayGetColorFormat(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_set_antialiasing", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplaySetAntialiasing(__IntPtr disp, bool en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_antialiasing", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvDisplayGetAntialiasing(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_flush_ready", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplayFlushReady(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_flush_is_last", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvDisplayFlushIsLast(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_is_double_buffered", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvDisplayIsDoubleBuffered(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_screen_active", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDisplayGetScreenActive(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_screen_prev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDisplayGetScreenPrev(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_layer_top", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDisplayGetLayerTop(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_layer_sys", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDisplayGetLayerSys(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_layer_bottom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDisplayGetLayerBottom(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_screen_load", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvScreenLoad(__IntPtr scr);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_screen_load_anim", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvScreenLoadAnim(__IntPtr scr, global::lvgl.LvScreenLoadAnimT anim_type, uint time, uint delay, bool auto_del);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_add_event_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplayAddEventCb(__IntPtr disp, __IntPtr event_cb, global::lvgl.LvEventCodeT filter, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_event_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvDisplayGetEventCount(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_event_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDisplayGetEventDsc(__IntPtr disp, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_delete_event", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvDisplayDeleteEvent(__IntPtr disp, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_remove_event_cb_with_user_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvDisplayRemoveEventCbWithUserData(__IntPtr disp, __IntPtr event_cb, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_send_event", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvDisplaySendEvent(__IntPtr disp, global::lvgl.LvEventCodeT code, __IntPtr param);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_set_theme", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplaySetTheme(__IntPtr disp, __IntPtr th);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_theme", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDisplayGetTheme(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_inactive_time", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvDisplayGetInactiveTime(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_trigger_activity", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplayTriggerActivity(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_enable_invalidation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplayEnableInvalidation(__IntPtr disp, bool en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_is_invalidation_enabled", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvDisplayIsInvalidationEnabled(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_refr_timer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDisplayGetRefrTimer(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_delete_refr_timer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplayDeleteRefrTimer(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_set_user_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplaySetUserData(__IntPtr disp, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_set_driver_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplaySetDriverData(__IntPtr disp, __IntPtr driver_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_user_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDisplayGetUserData(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_driver_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDisplayGetDriverData(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_get_buf_active", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDisplayGetBufActive(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_display_rotate_area", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplayRotateArea(__IntPtr disp, __IntPtr area);
        }

        /// <summary>Create a new display with the given resolution</summary>
        /// <param name="hor_res">horizontal resolution in pixels</param>
        /// <param name="ver_res">vertical resolution in pixels</param>
        /// <returns>pointer to a display object or `NULL` on error</returns>
        public static global::lvgl.LvDisplayT LvDisplayCreate(int hor_res, int ver_res)
        {
            var ___ret = __Internal.LvDisplayCreate(hor_res, ver_res);
            var __result0 = global::lvgl.LvDisplayT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Remove a display</summary>
        /// <param name="disp">pointer to display</param>
        public static void LvDisplayDelete(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvDisplayDelete(__arg0);
        }

        /// <summary>Set a default display. The new screens will be created on it by default.</summary>
        /// <param name="disp">pointer to a display</param>
        public static void LvDisplaySetDefault(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvDisplaySetDefault(__arg0);
        }

        /// <summary>Get the default display</summary>
        /// <returns>pointer to the default display</returns>
        public static global::lvgl.LvDisplayT LvDisplayGetDefault()
        {
            var ___ret = __Internal.LvDisplayGetDefault();
            var __result0 = global::lvgl.LvDisplayT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the next display.</summary>
        /// <param name="disp">pointer to the current display. NULL to initialize.</param>
        /// <returns>the next display or NULL if no more. Gives the first display when the parameter is NULL.</returns>
        public static global::lvgl.LvDisplayT LvDisplayGetNext(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetNext(__arg0);
            var __result0 = global::lvgl.LvDisplayT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Sets the resolution of a display. `LV_EVENT_RESOLUTION_CHANGED` event will be sent.</para>
        /// <para>Here the native resolution of the device should be set. If the display will be rotated later with</para>
        /// <para>`lv_display_set_rotation` LVGL will swap the hor. and ver. resolution automatically.</para>
        /// </summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="hor_res">the new horizontal resolution</param>
        /// <param name="ver_res">the new vertical resolution</param>
        public static void LvDisplaySetResolution(global::lvgl.LvDisplayT disp, int hor_res, int ver_res)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvDisplaySetResolution(__arg0, hor_res, ver_res);
        }

        /// <summary>
        /// <para>It's not mandatory to use the whole display for LVGL, however in some cases physical resolution is important.</para>
        /// <para>For example the touchpad still sees whole resolution and the values needs to be converted</para>
        /// <para>to the active LVGL display area.</para>
        /// </summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="hor_res">the new physical horizontal resolution, or -1 to assume it's the same as the normal hor. res.</param>
        /// <param name="ver_res">the new physical vertical resolution, or -1 to assume it's the same as the normal hor. res.</param>
        public static void LvDisplaySetPhysicalResolution(global::lvgl.LvDisplayT disp, int hor_res, int ver_res)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvDisplaySetPhysicalResolution(__arg0, hor_res, ver_res);
        }

        /// <summary>
        /// <para>If physical resolution is not the same as the normal resolution</para>
        /// <para>the offset of the active display area can be set here.</para>
        /// </summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="x">X offset</param>
        /// <param name="y">Y offset</param>
        public static void LvDisplaySetOffset(global::lvgl.LvDisplayT disp, int x, int y)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvDisplaySetOffset(__arg0, x, y);
        }

        /// <summary>Set the rotation of this display. LVGL will swap the horizontal and vertical resolutions internally.</summary>
        /// <param name="disp">pointer to a display (NULL to use the default display)</param>
        /// <param name="rotation">`LV_DISPLAY_ROTATION_0/90/180/270`</param>
        public static void LvDisplaySetRotation(global::lvgl.LvDisplayT disp, global::lvgl.LvDisplayRotationT rotation)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvDisplaySetRotation(__arg0, rotation);
        }

        /// <summary>
        /// <para>Set the DPI (dot per inch) of the display.</para>
        /// <para>dpi = sqrt(hor_res^2 + ver_res^2) / diagonal&quot;</para>
        /// </summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="dpi">the new DPI</param>
        public static void LvDisplaySetDpi(global::lvgl.LvDisplayT disp, int dpi)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvDisplaySetDpi(__arg0, dpi);
        }

        /// <summary>Get the horizontal resolution of a display.</summary>
        /// <param name="disp">pointer to a display (NULL to use the default display)</param>
        /// <returns>the horizontal resolution of the display.</returns>
        public static int LvDisplayGetHorizontalResolution(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetHorizontalResolution(__arg0);
            return ___ret;
        }

        /// <summary>Get the vertical resolution of a display</summary>
        /// <param name="disp">pointer to a display (NULL to use the default display)</param>
        /// <returns>the vertical resolution of the display</returns>
        public static int LvDisplayGetVerticalResolution(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetVerticalResolution(__arg0);
            return ___ret;
        }

        /// <summary>Get the physical horizontal resolution of a display</summary>
        /// <param name="disp">pointer to a display (NULL to use the default display)</param>
        /// <returns>the      physical horizontal resolution of the display</returns>
        public static int LvDisplayGetPhysicalHorizontalResolution(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetPhysicalHorizontalResolution(__arg0);
            return ___ret;
        }

        /// <summary>Get the physical vertical resolution of a display</summary>
        /// <param name="disp">pointer to a display (NULL to use the default display)</param>
        /// <returns>the physical vertical resolution of the display</returns>
        public static int LvDisplayGetPhysicalVerticalResolution(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetPhysicalVerticalResolution(__arg0);
            return ___ret;
        }

        /// <summary>Get the horizontal offset from the full / physical display</summary>
        /// <param name="disp">pointer to a display (NULL to use the default display)</param>
        /// <returns>the horizontal offset from the physical display</returns>
        public static int LvDisplayGetOffsetX(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetOffsetX(__arg0);
            return ___ret;
        }

        /// <summary>Get the vertical offset from the full / physical display</summary>
        /// <param name="disp">pointer to a display (NULL to use the default display)</param>
        /// <returns>the horizontal offset from the physical display</returns>
        public static int LvDisplayGetOffsetY(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetOffsetY(__arg0);
            return ___ret;
        }

        /// <summary>Get the current rotation of this display.</summary>
        /// <param name="disp">pointer to a display (NULL to use the default display)</param>
        /// <returns>the current rotation</returns>
        public static global::lvgl.LvDisplayRotationT LvDisplayGetRotation(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetRotation(__arg0);
            return ___ret;
        }

        /// <summary>Get the DPI of the display</summary>
        /// <param name="disp">pointer to a display (NULL to use the default display)</param>
        /// <returns>dpi of the display</returns>
        public static int LvDisplayGetDpi(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetDpi(__arg0);
            return ___ret;
        }

        /// <summary>Set the buffers for a display, similarly to `lv_display_set_draw_buffers`, but accept the raw buffer pointers.</summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="buf1">first buffer</param>
        /// <param name="buf2">second buffer (can be `NULL`)</param>
        /// <param name="buf_size">buffer size in byte</param>
        /// <param name="render_mode">LV_DISPLAY_RENDER_MODE_PARTIAL/DIRECT/FULL</param>
        public static void LvDisplaySetBuffers(global::lvgl.LvDisplayT disp, __IntPtr buf1, __IntPtr buf2, uint buf_size, global::lvgl.LvDisplayRenderModeT render_mode)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvDisplaySetBuffers(__arg0, buf1, buf2, buf_size, render_mode);
        }

        /// <summary>
        /// <para>Set the buffers for a display, accept a draw buffer pointer.</para>
        /// <para>Normally use `lv_display_set_buffers` is enough for most cases.</para>
        /// <para>Use this function when an existing lv_draw_buf_t is available.</para>
        /// </summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="buf1">first buffer</param>
        /// <param name="buf2">second buffer (can be `NULL`)</param>
        public static void LvDisplaySetDrawBuffers(global::lvgl.LvDisplayT disp, global::lvgl.LvDrawBufT buf1, global::lvgl.LvDrawBufT buf2)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var __arg1 = buf1 is null ? __IntPtr.Zero : buf1.__Instance;
            var __arg2 = buf2 is null ? __IntPtr.Zero : buf2.__Instance;
            __Internal.LvDisplaySetDrawBuffers(__arg0, __arg1, __arg2);
        }

        /// <summary>Set display render mode</summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="render_mode">LV_DISPLAY_RENDER_MODE_PARTIAL/DIRECT/FULL</param>
        public static void LvDisplaySetRenderMode(global::lvgl.LvDisplayT disp, global::lvgl.LvDisplayRenderModeT render_mode)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvDisplaySetRenderMode(__arg0, render_mode);
        }

        /// <summary>Set the flush callback which will be called to copy the rendered image to the display.</summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="flush_cb">the flush callback (`px_map` contains the rendered image as raw pixel map and it should be copied to `area` on the display)</param>
        public static void LvDisplaySetFlushCb(global::lvgl.LvDisplayT disp, global::lvgl.LvDisplayFlushCbT flush_cb)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var __arg1 = flush_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(flush_cb);
            __Internal.LvDisplaySetFlushCb(__arg0, __arg1);
        }

        /// <summary>
        /// <para>Set a callback to be used while LVGL is waiting flushing to be finished.</para>
        /// <para>It can do any complex logic to wait, including semaphores, mutexes, polling flags, etc.</para>
        /// <para>If not set the `disp-&gt;flushing` flag is used which can be cleared with `lv_display_flush_ready()`</para>
        /// </summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="wait_cb">
        /// <para>a callback to call while LVGL is waiting for flush ready.</para>
        /// <para>If NULL `lv_display_flush_ready()` can be used to signal that flushing is ready.</para>
        /// </param>
        public static void LvDisplaySetFlushWaitCb(global::lvgl.LvDisplayT disp, global::lvgl.LvDisplayFlushWaitCbT wait_cb)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var __arg1 = wait_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(wait_cb);
            __Internal.LvDisplaySetFlushWaitCb(__arg0, __arg1);
        }

        /// <summary>Set the color format of the display.</summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="color_format">
        /// <para>Possible values are</para>
        /// <para>- LV_COLOR_FORMAT_RGB565</para>
        /// <para>- LV_COLOR_FORMAT_RGB888</para>
        /// <para>- LV_COLOR_FORMAT_XRGB888</para>
        /// <para>- LV_COLOR_FORMAT_ARGB888</para>
        /// </param>
        /// <remarks>
        /// <para>To change the endianness of the rendered image in case of RGB565 format</para>
        /// <para>(i.e. swap the 2 bytes) call `lv_draw_sw_rgb565_swap` in the flush_cb</para>
        /// </remarks>
        public static void LvDisplaySetColorFormat(global::lvgl.LvDisplayT disp, byte color_format)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvDisplaySetColorFormat(__arg0, color_format);
        }

        /// <summary>Get the color format of the display</summary>
        /// <param name="disp">pointer to a display</param>
        /// <returns>the color format</returns>
        public static byte LvDisplayGetColorFormat(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetColorFormat(__arg0);
            return ___ret;
        }

        /// <summary>Enable anti-aliasing for the render engine</summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="en">true/false</param>
        public static void LvDisplaySetAntialiasing(global::lvgl.LvDisplayT disp, bool en)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvDisplaySetAntialiasing(__arg0, en);
        }

        /// <summary>Get if anti-aliasing is enabled for a display or not</summary>
        /// <param name="disp">pointer to a display (NULL to use the default display)</param>
        /// <returns>true/false</returns>
        public static bool LvDisplayGetAntialiasing(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetAntialiasing(__arg0);
            return ___ret;
        }

        /// <summary>Call from the display driver when the flushing is finished</summary>
        /// <param name="disp">pointer to display whose `flush_cb` was called</param>
        public static void LvDisplayFlushReady(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvDisplayFlushReady(__arg0);
        }

        /// <summary>
        /// <para>Tell if it's the last area of the refreshing process.</para>
        /// <para>Can be called from `flush_cb` to execute some special display refreshing if needed when all areas area flushed.</para>
        /// </summary>
        /// <param name="disp">pointer to display</param>
        /// <returns>
        /// <para>true: it's the last area to flush;</para>
        /// <para>false: there are other areas too which will be refreshed soon</para>
        /// </returns>
        public static bool LvDisplayFlushIsLast(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayFlushIsLast(__arg0);
            return ___ret;
        }

        public static bool LvDisplayIsDoubleBuffered(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayIsDoubleBuffered(__arg0);
            return ___ret;
        }

        /// <summary>Return a pointer to the active screen on a display</summary>
        /// <param name="disp">
        /// <para>pointer to display which active screen should be get.</para>
        /// <para>(NULL to use the default screen)</para>
        /// </param>
        /// <returns>pointer to the active screen object (loaded by 'lv_screen_load()')</returns>
        public static global::lvgl.LvObjT LvDisplayGetScreenActive(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetScreenActive(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Return with a pointer to the previous screen. Only used during screen transitions.</summary>
        /// <param name="disp">
        /// <para>pointer to display which previous screen should be get.</para>
        /// <para>(NULL to use the default screen)</para>
        /// </param>
        /// <returns>pointer to the previous screen object or NULL if not used now</returns>
        public static global::lvgl.LvObjT LvDisplayGetScreenPrev(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetScreenPrev(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Return the top layer. The top layer is the same on all screens and it is above the normal screen layer.</summary>
        /// <param name="disp">pointer to display which top layer should be get. (NULL to use the default screen)</param>
        /// <returns>pointer to the top layer object</returns>
        public static global::lvgl.LvObjT LvDisplayGetLayerTop(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetLayerTop(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Return the sys. layer. The system layer is the same on all screen and it is above the normal screen and the top layer.</summary>
        /// <param name="disp">pointer to display which sys. layer should be retrieved. (NULL to use the default screen)</param>
        /// <returns>pointer to the sys layer object</returns>
        public static global::lvgl.LvObjT LvDisplayGetLayerSys(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetLayerSys(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Return the bottom layer. The bottom layer is the same on all screen and it is under the normal screen layer.</para>
        /// <para>It's visible only if the the screen is transparent.</para>
        /// </summary>
        /// <param name="disp">pointer to display (NULL to use the default screen)</param>
        /// <returns>pointer to the bottom layer object</returns>
        public static global::lvgl.LvObjT LvDisplayGetLayerBottom(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetLayerBottom(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Load a screen on the default display</summary>
        /// <param name="scr">pointer to a screen</param>
        public static void LvScreenLoad(global::lvgl.LvObjT scr)
        {
            var __arg0 = scr is null ? __IntPtr.Zero : scr.__Instance;
            __Internal.LvScreenLoad(__arg0);
        }

        /// <summary>Switch screen with animation</summary>
        /// <param name="scr">pointer to the new screen to load</param>
        /// <param name="anim_type">type of the animation from `lv_screen_load_anim_t`, e.g. `LV_SCR_LOAD_ANIM_MOVE_LEFT`</param>
        /// <param name="time">time of the animation</param>
        /// <param name="delay">delay before the transition</param>
        /// <param name="auto_del">true: automatically delete the old screen</param>
        public static void LvScreenLoadAnim(global::lvgl.LvObjT scr, global::lvgl.LvScreenLoadAnimT anim_type, uint time, uint delay, bool auto_del)
        {
            var __arg0 = scr is null ? __IntPtr.Zero : scr.__Instance;
            __Internal.LvScreenLoadAnim(__arg0, anim_type, time, delay, auto_del);
        }

        /// <summary>Add an event handler to the display</summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="event_cb">an event callback</param>
        /// <param name="filter">event code to react or `LV_EVENT_ALL`</param>
        /// <param name="user_data">optional user_data</param>
        public static void LvDisplayAddEventCb(global::lvgl.LvDisplayT disp, global::lvgl.LvEventCbT event_cb, global::lvgl.LvEventCodeT filter, __IntPtr user_data)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var __arg1 = event_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(event_cb);
            __Internal.LvDisplayAddEventCb(__arg0, __arg1, filter, user_data);
        }

        /// <summary>Get the number of event attached to a display</summary>
        /// <param name="disp">pointer to a display</param>
        /// <returns>number of events</returns>
        public static uint LvDisplayGetEventCount(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetEventCount(__arg0);
            return ___ret;
        }

        /// <summary>Get an event descriptor for an event</summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="index">the index of the event</param>
        /// <returns>the event descriptor</returns>
        public static global::lvgl.LvEventDscT LvDisplayGetEventDsc(global::lvgl.LvDisplayT disp, uint index)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetEventDsc(__arg0, index);
            var __result0 = global::lvgl.LvEventDscT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Remove an event</summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="index">the index of the event to remove</param>
        /// <returns>true: and event was removed; false: no event was removed</returns>
        public static bool LvDisplayDeleteEvent(global::lvgl.LvDisplayT disp, uint index)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayDeleteEvent(__arg0, index);
            return ___ret;
        }

        /// <summary>Remove an event_cb with user_data</summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="event_cb">the event_cb of the event to remove</param>
        /// <param name="user_data">user_data</param>
        /// <returns>the count of the event removed</returns>
        public static uint LvDisplayRemoveEventCbWithUserData(global::lvgl.LvDisplayT disp, global::lvgl.LvEventCbT event_cb, __IntPtr user_data)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var __arg1 = event_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(event_cb);
            var ___ret = __Internal.LvDisplayRemoveEventCbWithUserData(__arg0, __arg1, user_data);
            return ___ret;
        }

        /// <summary>Send an event to a display</summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="code">an event code. LV_EVENT_...</param>
        /// <param name="param">optional param</param>
        /// <returns>LV_RESULT_OK: disp wasn't deleted in the event.</returns>
        public static byte LvDisplaySendEvent(global::lvgl.LvDisplayT disp, global::lvgl.LvEventCodeT code, __IntPtr param)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplaySendEvent(__arg0, code, param);
            return ___ret;
        }

        /// <summary>Set the theme of a display. If there are no user created widgets yet the screens' theme will be updated</summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="th">pointer to a theme</param>
        public static void LvDisplaySetTheme(global::lvgl.LvDisplayT disp, global::lvgl.LvThemeT th)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var __arg1 = th is null ? __IntPtr.Zero : th.__Instance;
            __Internal.LvDisplaySetTheme(__arg0, __arg1);
        }

        /// <summary>Get the theme of a display</summary>
        /// <param name="disp">pointer to a display</param>
        /// <returns>the display's theme (can be NULL)</returns>
        public static global::lvgl.LvThemeT LvDisplayGetTheme(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetTheme(__arg0);
            var __result0 = global::lvgl.LvThemeT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get elapsed time since last user activity on a display (e.g. click)</summary>
        /// <param name="disp">pointer to a display (NULL to get the overall smallest inactivity)</param>
        /// <returns>elapsed ticks (milliseconds) since the last activity</returns>
        public static uint LvDisplayGetInactiveTime(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetInactiveTime(__arg0);
            return ___ret;
        }

        /// <summary>Manually trigger an activity on a display</summary>
        /// <param name="disp">pointer to a display (NULL to use the default display)</param>
        public static void LvDisplayTriggerActivity(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvDisplayTriggerActivity(__arg0);
        }

        /// <summary>Temporarily enable and disable the invalidation of the display.</summary>
        /// <param name="disp">pointer to a display (NULL to use the default display)</param>
        /// <param name="en">true: enable invalidation; false: invalidation</param>
        public static void LvDisplayEnableInvalidation(global::lvgl.LvDisplayT disp, bool en)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvDisplayEnableInvalidation(__arg0, en);
        }

        /// <summary>Get display invalidation is enabled.</summary>
        /// <param name="disp">pointer to a display (NULL to use the default display)</param>
        /// <returns>return   true if invalidation is enabled</returns>
        public static bool LvDisplayIsInvalidationEnabled(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayIsInvalidationEnabled(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Get a pointer to the screen refresher timer to</para>
        /// <para>modify its parameters with `lv_timer_...` functions.</para>
        /// </summary>
        /// <param name="disp">pointer to a display</param>
        /// <returns>pointer to the display refresher timer. (NULL on error)</returns>
        public static global::lvgl.LvTimerT LvDisplayGetRefrTimer(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetRefrTimer(__arg0);
            var __result0 = global::lvgl.LvTimerT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Delete screen refresher timer</summary>
        /// <param name="disp">pointer to a display</param>
        public static void LvDisplayDeleteRefrTimer(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvDisplayDeleteRefrTimer(__arg0);
        }

        public static void LvDisplaySetUserData(global::lvgl.LvDisplayT disp, __IntPtr user_data)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvDisplaySetUserData(__arg0, user_data);
        }

        public static void LvDisplaySetDriverData(global::lvgl.LvDisplayT disp, __IntPtr driver_data)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvDisplaySetDriverData(__arg0, driver_data);
        }

        public static __IntPtr LvDisplayGetUserData(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetUserData(__arg0);
            return ___ret;
        }

        public static __IntPtr LvDisplayGetDriverData(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetDriverData(__arg0);
            return ___ret;
        }

        public static global::lvgl.LvDrawBufT LvDisplayGetBufActive(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvDisplayGetBufActive(__arg0);
            var __result0 = global::lvgl.LvDrawBufT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Rotate an area in-place according to the display's rotation</summary>
        /// <param name="disp">pointer to a display</param>
        /// <param name="area">pointer to an area to rotate</param>
        public static void LvDisplayRotateArea(global::lvgl.LvDisplayT disp, global::lvgl.LvAreaT area)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var __arg1 = area is null ? __IntPtr.Zero : area.__Instance;
            __Internal.LvDisplayRotateArea(__arg0, __arg1);
        }
    }

    /// <summary>Type of event being sent to the object.</summary>
    public enum LvEventCodeT
    {
        LV_EVENT_ALL = 0,
        /// <summary>The object has been pressed</summary>
        LV_EVENT_PRESSED = 1,
        /// <summary>The object is being pressed (called continuously while pressing)</summary>
        LV_EVENT_PRESSING = 2,
        /// <summary>The object is still being pressed but slid cursor/finger off of the object</summary>
        LV_EVENT_PRESS_LOST = 3,
        /// <summary>The object was pressed for a short period of time, then released it. Not called if scrolled.</summary>
        LV_EVENT_SHORT_CLICKED = 4,
        /// <summary>Object has been pressed for at least `long_press_time`.  Not called if scrolled.</summary>
        LV_EVENT_LONG_PRESSED = 5,
        /// <summary>Called after `long_press_time` in every `long_press_repeat_time` ms.  Not called if scrolled.</summary>
        LV_EVENT_LONG_PRESSED_REPEAT = 6,
        /// <summary>Called on release if not scrolled (regardless to long press)</summary>
        LV_EVENT_CLICKED = 7,
        /// <summary>Called in every cases when the object has been released</summary>
        LV_EVENT_RELEASED = 8,
        /// <summary>Scrolling begins. The event parameter is a pointer to the animation of the scroll. Can be modified</summary>
        LV_EVENT_SCROLL_BEGIN = 9,
        LV_EVENT_SCROLL_THROW_BEGIN = 10,
        /// <summary>Scrolling ends</summary>
        LV_EVENT_SCROLL_END = 11,
        /// <summary>Scrolling</summary>
        LV_EVENT_SCROLL = 12,
        /// <summary>A gesture is detected. Get the gesture with `lv_indev_get_gesture_dir(lv_indev_active());`</summary>
        LV_EVENT_GESTURE = 13,
        /// <summary>A key is sent to the object. Get the key with `lv_indev_get_key(lv_indev_active());`</summary>
        LV_EVENT_KEY = 14,
        /// <summary>An encoder or wheel was rotated. Get the rotation count with `lv_event_get_rotary_diff(e);`</summary>
        LV_EVENT_ROTARY = 15,
        /// <summary>The object is focused</summary>
        LV_EVENT_FOCUSED = 16,
        /// <summary>The object is defocused</summary>
        LV_EVENT_DEFOCUSED = 17,
        /// <summary>The object is defocused but still selected</summary>
        LV_EVENT_LEAVE = 18,
        /// <summary>Perform advanced hit-testing</summary>
        LV_EVENT_HIT_TEST = 19,
        /// <summary>Indev has been reset</summary>
        LV_EVENT_INDEV_RESET = 20,
        /// <summary>Indev hover over object</summary>
        LV_EVENT_HOVER_OVER = 21,
        /// <summary>Indev hover leave object</summary>
        LV_EVENT_HOVER_LEAVE = 22,
        /// <summary>Check if the object fully covers an area. The event parameter is `lv_cover_check_info_t *`.</summary>
        LV_EVENT_COVER_CHECK = 23,
        /// <summary>Get the required extra draw area around the object (e.g. for shadow). The event parameter is `int32_t *` to store the size.</summary>
        LV_EVENT_REFR_EXT_DRAW_SIZE = 24,
        /// <summary>Starting the main drawing phase</summary>
        LV_EVENT_DRAW_MAIN_BEGIN = 25,
        /// <summary>Perform the main drawing</summary>
        LV_EVENT_DRAW_MAIN = 26,
        /// <summary>Finishing the main drawing phase</summary>
        LV_EVENT_DRAW_MAIN_END = 27,
        /// <summary>Starting the post draw phase (when all children are drawn)</summary>
        LV_EVENT_DRAW_POST_BEGIN = 28,
        /// <summary>Perform the post draw phase (when all children are drawn)</summary>
        LV_EVENT_DRAW_POST = 29,
        /// <summary>Finishing the post draw phase (when all children are drawn)</summary>
        LV_EVENT_DRAW_POST_END = 30,
        /// <summary>Adding a draw task</summary>
        LV_EVENT_DRAW_TASK_ADDED = 31,
        /// <summary>The object's value has changed (i.e. slider moved)</summary>
        LV_EVENT_VALUE_CHANGED = 32,
        /// <summary>A text is inserted to the object. The event data is `char *` being inserted.</summary>
        LV_EVENT_INSERT = 33,
        /// <summary>Notify the object to refresh something on it (for the user)</summary>
        LV_EVENT_REFRESH = 34,
        /// <summary>A process has finished</summary>
        LV_EVENT_READY = 35,
        /// <summary>A process has been cancelled</summary>
        LV_EVENT_CANCEL = 36,
        /// <summary>Object is being created</summary>
        LV_EVENT_CREATE = 37,
        /// <summary>Object is being deleted</summary>
        LV_EVENT_DELETE = 38,
        /// <summary>Child was removed, added, or its size, position were changed</summary>
        LV_EVENT_CHILD_CHANGED = 39,
        /// <summary>Child was created, always bubbles up to all parents</summary>
        LV_EVENT_CHILD_CREATED = 40,
        /// <summary>Child was deleted, always bubbles up to all parents</summary>
        LV_EVENT_CHILD_DELETED = 41,
        /// <summary>A screen unload started, fired immediately when scr_load is called</summary>
        LV_EVENT_SCREEN_UNLOAD_START = 42,
        /// <summary>A screen load started, fired when the screen change delay is expired</summary>
        LV_EVENT_SCREEN_LOAD_START = 43,
        /// <summary>A screen was loaded</summary>
        LV_EVENT_SCREEN_LOADED = 44,
        /// <summary>A screen was unloaded</summary>
        LV_EVENT_SCREEN_UNLOADED = 45,
        /// <summary>Object coordinates/size have changed</summary>
        LV_EVENT_SIZE_CHANGED = 46,
        /// <summary>Object's style has changed</summary>
        LV_EVENT_STYLE_CHANGED = 47,
        /// <summary>The children position has changed due to a layout recalculation</summary>
        LV_EVENT_LAYOUT_CHANGED = 48,
        /// <summary>Get the internal size of a widget</summary>
        LV_EVENT_GET_SELF_SIZE = 49,
        /// <summary>Events of optional LVGL components</summary>
        LV_EVENT_INVALIDATE_AREA = 50,
        /// <summary>Events of optional LVGL components</summary>
        LV_EVENT_RESOLUTION_CHANGED = 51,
        /// <summary>Events of optional LVGL components</summary>
        LV_EVENT_COLOR_FORMAT_CHANGED = 52,
        /// <summary>Events of optional LVGL components</summary>
        LV_EVENT_REFR_REQUEST = 53,
        /// <summary>Events of optional LVGL components</summary>
        LV_EVENT_REFR_START = 54,
        /// <summary>Events of optional LVGL components</summary>
        LV_EVENT_REFR_READY = 55,
        /// <summary>Events of optional LVGL components</summary>
        LV_EVENT_RENDER_START = 56,
        /// <summary>Events of optional LVGL components</summary>
        LV_EVENT_RENDER_READY = 57,
        /// <summary>Events of optional LVGL components</summary>
        LV_EVENT_FLUSH_START = 58,
        /// <summary>Events of optional LVGL components</summary>
        LV_EVENT_FLUSH_FINISH = 59,
        /// <summary>Events of optional LVGL components</summary>
        LV_EVENT_FLUSH_WAIT_START = 60,
        /// <summary>Events of optional LVGL components</summary>
        LV_EVENT_FLUSH_WAIT_FINISH = 61,
        /// <summary>Events of optional LVGL components</summary>
        LV_EVENT_VSYNC = 62,
        /// <summary>Events of optional LVGL components</summary>
        LV_EVENT_LAST = 63,
        /// <summary>Number of default events</summary>
        LV_EVENT_PREPROCESS = 32768
    }

    /// <summary>Type of event being sent to the object.</summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvEventCbT(__IntPtr e);

    public unsafe partial class LvEventDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr cb;
            internal __IntPtr user_data;
            internal uint filter;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_event_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvEventDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvEventDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvEventDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvEventDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvEventDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvEventDscT(native.ToPointer(), skipVTables);
        }

        internal static LvEventDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvEventDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvEventDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvEventDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvEventDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvEventDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvEventDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvEventDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvEventDscT(global::lvgl.LvEventDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvEventDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvEventDscT.__Internal*) __Instance) = *((global::lvgl.LvEventDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvEventCbT Cb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvEventCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvEventCbT));
            }

            set
            {
                ((__Internal*)__Instance)->cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }

        public uint Filter
        {
            get
            {
                return ((__Internal*)__Instance)->filter;
            }

            set
            {
                ((__Internal*)__Instance)->filter = value;
            }
        }
    }

    public unsafe partial class LvEventT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr current_target;

            [FieldOffset(8)]
            internal __IntPtr original_target;

            [FieldOffset(16)]
            internal global::lvgl.LvEventCodeT code;

            [FieldOffset(24)]
            internal __IntPtr user_data;

            [FieldOffset(32)]
            internal __IntPtr param;

            [FieldOffset(40)]
            internal __IntPtr prev;

            [FieldOffset(48)]
            internal byte deleted;

            [FieldOffset(48)]
            internal byte stop_processing;

            [FieldOffset(48)]
            internal byte stop_bubbling;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_event_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvEventT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvEventT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvEventT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvEventT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvEventT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvEventT(native.ToPointer(), skipVTables);
        }

        internal static LvEventT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvEventT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvEventT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvEventT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvEventT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvEventT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvEventT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvEventT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvEventT(global::lvgl.LvEventT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvEventT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvEventT.__Internal*) __Instance) = *((global::lvgl.LvEventT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr CurrentTarget
        {
            get
            {
                return ((__Internal*)__Instance)->current_target;
            }

            set
            {
                ((__Internal*)__Instance)->current_target = (__IntPtr) value;
            }
        }

        public __IntPtr OriginalTarget
        {
            get
            {
                return ((__Internal*)__Instance)->original_target;
            }

            set
            {
                ((__Internal*)__Instance)->original_target = (__IntPtr) value;
            }
        }

        public global::lvgl.LvEventCodeT Code
        {
            get
            {
                return ((__Internal*)__Instance)->code;
            }

            set
            {
                ((__Internal*)__Instance)->code = value;
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }

        public __IntPtr Param
        {
            get
            {
                return ((__Internal*)__Instance)->param;
            }

            set
            {
                ((__Internal*)__Instance)->param = (__IntPtr) value;
            }
        }

        public global::lvgl.LvEventT Prev
        {
            get
            {
                var __result0 = global::lvgl.LvEventT.__GetOrCreateInstance(((__Internal*)__Instance)->prev, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->prev = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public byte Deleted
        {
            get
            {
                return ((__Internal*)__Instance)->deleted;
            }

            set
            {
                ((__Internal*)__Instance)->deleted = value;
            }
        }

        public byte StopProcessing
        {
            get
            {
                return ((__Internal*)__Instance)->stop_processing;
            }

            set
            {
                ((__Internal*)__Instance)->stop_processing = value;
            }
        }

        public byte StopBubbling
        {
            get
            {
                return ((__Internal*)__Instance)->stop_bubbling;
            }

            set
            {
                ((__Internal*)__Instance)->stop_bubbling = value;
            }
        }
    }

    public unsafe partial class lv_event
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_event_push", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvEventPush(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_event_pop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvEventPop(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_send", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvEventSend(__IntPtr list, __IntPtr e, bool preprocess);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_add", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventAdd(__IntPtr list, __IntPtr cb, global::lvgl.LvEventCodeT filter, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_remove_dsc", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvEventRemoveDsc(__IntPtr list, __IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvEventGetCount(__IntPtr list);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventGetDsc(__IntPtr list, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_dsc_get_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventDscGetCb(__IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_dsc_get_user_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventDscGetUserData(__IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_remove", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvEventRemove(__IntPtr list, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_remove_all", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvEventRemoveAll(__IntPtr list);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_target", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventGetTarget(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_current_target", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventGetCurrentTarget(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_code", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::lvgl.LvEventCodeT LvEventGetCode(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_param", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventGetParam(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_user_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventGetUserData(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_stop_bubbling", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvEventStopBubbling(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_stop_processing", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvEventStopProcessing(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_register_id", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvEventRegisterId();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_event_mark_deleted", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvEventMarkDeleted(__IntPtr target);
        }

        /// <summary>
        /// <para>********************</para>
        /// <para>GLOBAL PROTOTYPES</para>
        /// <para>********************</para>
        /// </summary>
        public static void LvEventPush(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            __Internal.LvEventPush(__arg0);
        }

        public static void LvEventPop(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            __Internal.LvEventPop(__arg0);
        }

        public static byte LvEventSend(global::lvgl.LvArrayT list, global::lvgl.LvEventT e, bool preprocess)
        {
            var __arg0 = list is null ? __IntPtr.Zero : list.__Instance;
            var __arg1 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventSend(__arg0, __arg1, preprocess);
            return ___ret;
        }

        public static global::lvgl.LvEventDscT LvEventAdd(global::lvgl.LvArrayT list, global::lvgl.LvEventCbT cb, global::lvgl.LvEventCodeT filter, __IntPtr user_data)
        {
            var __arg0 = list is null ? __IntPtr.Zero : list.__Instance;
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            var ___ret = __Internal.LvEventAdd(__arg0, __arg1, filter, user_data);
            var __result0 = global::lvgl.LvEventDscT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static bool LvEventRemoveDsc(global::lvgl.LvArrayT list, global::lvgl.LvEventDscT dsc)
        {
            var __arg0 = list is null ? __IntPtr.Zero : list.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var ___ret = __Internal.LvEventRemoveDsc(__arg0, __arg1);
            return ___ret;
        }

        public static uint LvEventGetCount(global::lvgl.LvArrayT list)
        {
            var __arg0 = list is null ? __IntPtr.Zero : list.__Instance;
            var ___ret = __Internal.LvEventGetCount(__arg0);
            return ___ret;
        }

        public static global::lvgl.LvEventDscT LvEventGetDsc(global::lvgl.LvArrayT list, uint index)
        {
            var __arg0 = list is null ? __IntPtr.Zero : list.__Instance;
            var ___ret = __Internal.LvEventGetDsc(__arg0, index);
            var __result0 = global::lvgl.LvEventDscT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::lvgl.LvEventCbT LvEventDscGetCb(global::lvgl.LvEventDscT dsc)
        {
            var __arg0 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var ___ret = __Internal.LvEventDscGetCb(__arg0);
            var __ptr0 = ___ret;
            return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvEventCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvEventCbT));
        }

        public static __IntPtr LvEventDscGetUserData(global::lvgl.LvEventDscT dsc)
        {
            var __arg0 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var ___ret = __Internal.LvEventDscGetUserData(__arg0);
            return ___ret;
        }

        public static bool LvEventRemove(global::lvgl.LvArrayT list, uint index)
        {
            var __arg0 = list is null ? __IntPtr.Zero : list.__Instance;
            var ___ret = __Internal.LvEventRemove(__arg0, index);
            return ___ret;
        }

        public static void LvEventRemoveAll(global::lvgl.LvArrayT list)
        {
            var __arg0 = list is null ? __IntPtr.Zero : list.__Instance;
            __Internal.LvEventRemoveAll(__arg0);
        }

        /// <summary>Get the object originally targeted by the event. It's the same even if the event is bubbled.</summary>
        /// <param name="e">pointer to the event descriptor</param>
        /// <returns>the target of the event_code</returns>
        public static __IntPtr LvEventGetTarget(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventGetTarget(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Get the current target of the event. It's the object which event handler being called.</para>
        /// <para>If the event is not bubbled it's the same as &quot;normal&quot; target.</para>
        /// </summary>
        /// <param name="e">pointer to the event descriptor</param>
        /// <returns>pointer to the current target of the event_code</returns>
        public static __IntPtr LvEventGetCurrentTarget(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventGetCurrentTarget(__arg0);
            return ___ret;
        }

        /// <summary>Get the event code of an event</summary>
        /// <param name="e">pointer to the event descriptor</param>
        /// <returns>the event code. (E.g. `LV_EVENT_CLICKED`, `LV_EVENT_FOCUSED`, etc)</returns>
        public static global::lvgl.LvEventCodeT LvEventGetCode(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventGetCode(__arg0);
            return ___ret;
        }

        /// <summary>Get the parameter passed when the event was sent</summary>
        /// <param name="e">pointer to the event descriptor</param>
        /// <returns>pointer to the parameter</returns>
        public static __IntPtr LvEventGetParam(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventGetParam(__arg0);
            return ___ret;
        }

        /// <summary>Get the user_data passed when the event was registered on the object</summary>
        /// <param name="e">pointer to the event descriptor</param>
        /// <returns>pointer to the user_data</returns>
        public static __IntPtr LvEventGetUserData(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventGetUserData(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Stop the event from bubbling.</para>
        /// <para>This is only valid when called in the middle of an event processing chain.</para>
        /// </summary>
        /// <param name="e">pointer to the event descriptor</param>
        public static void LvEventStopBubbling(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            __Internal.LvEventStopBubbling(__arg0);
        }

        /// <summary>
        /// <para>Stop processing this event.</para>
        /// <para>This is only valid when called in the middle of an event processing chain.</para>
        /// </summary>
        /// <param name="e">pointer to the event descriptor</param>
        public static void LvEventStopProcessing(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            __Internal.LvEventStopProcessing(__arg0);
        }

        /// <summary>
        /// <para>Register a new, custom event ID.</para>
        /// <para>It can be used the same way as e.g. `LV_EVENT_CLICKED` to send custom events</para>
        /// </summary>
        /// <returns>
        /// <para>the new event id</para>
        /// <para>uint32_t LV_EVENT_MINE = 0;</para>
        /// <para>...</para>
        /// <para>e = lv_event_register_id();</para>
        /// <para>...</para>
        /// <para>lv_obj_send_event(obj, LV_EVENT_MINE,&amp;some_data);</para>
        /// </returns>
        public static uint LvEventRegisterId()
        {
            var ___ret = __Internal.LvEventRegisterId();
            return ___ret;
        }

        /// <summary>
        /// <para>Nested events can be called and one of them might belong to an object that is being deleted.</para>
        /// <para>Mark this object's `event_temp_data` deleted to know that its `lv_obj_send_event` should return `LV_RESULT_INVALID`</para>
        /// </summary>
        /// <param name="target">pointer to an event target which was deleted</param>
        public static void LvEventMarkDeleted(__IntPtr target)
        {
            __Internal.LvEventMarkDeleted(target);
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public enum LvDrawTaskTypeT
    {
        LV_DRAW_TASK_TYPE_FILL = 0,
        LV_DRAW_TASK_TYPE_BORDER = 1,
        LV_DRAW_TASK_TYPE_BOX_SHADOW = 2,
        LV_DRAW_TASK_TYPE_LABEL = 3,
        LV_DRAW_TASK_TYPE_IMAGE = 4,
        LV_DRAW_TASK_TYPE_LAYER = 5,
        LV_DRAW_TASK_TYPE_LINE = 6,
        LV_DRAW_TASK_TYPE_ARC = 7,
        LV_DRAW_TASK_TYPE_TRIANGLE = 8,
        LV_DRAW_TASK_TYPE_MASK_RECTANGLE = 9,
        LV_DRAW_TASK_TYPE_MASK_BITMAP = 10,
        LV_DRAW_TASK_TYPE_VECTOR = 11
    }

    public enum LvDrawTaskStateT
    {
        LV_DRAW_TASK_STATE_WAITING = 0,
        LV_DRAW_TASK_STATE_QUEUED = 1,
        LV_DRAW_TASK_STATE_IN_PROGRESS = 2,
        LV_DRAW_TASK_STATE_READY = 3
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvDrawTaskT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 96)]
        public partial struct __Internal
        {
            internal __IntPtr next;
            internal global::lvgl.LvDrawTaskTypeT type;
            internal global::lvgl.LvAreaT.__Internal area;
            internal global::lvgl.LvAreaT.__Internal _real_area;
            internal global::lvgl.LvAreaT.__Internal clip_area_original;
            internal global::lvgl.LvAreaT.__Internal clip_area;
            internal int state;
            internal __IntPtr draw_dsc;
            internal byte preferred_draw_unit_id;
            internal byte preference_score;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_draw_task_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawTaskT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawTaskT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawTaskT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawTaskT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawTaskT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawTaskT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawTaskT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawTaskT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawTaskT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawTaskT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawTaskT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawTaskT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawTaskT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawTaskT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawTaskT(global::lvgl.LvDrawTaskT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawTaskT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawTaskT.__Internal*) __Instance) = *((global::lvgl.LvDrawTaskT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawTaskT Next
        {
            get
            {
                var __result0 = global::lvgl.LvDrawTaskT.__GetOrCreateInstance(((__Internal*)__Instance)->next, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->next = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvDrawTaskTypeT Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>The area where to draw</summary>
        public global::lvgl.LvAreaT Area
        {
            get
            {
                return global::lvgl.LvAreaT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->area));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->area = *(global::lvgl.LvAreaT.__Internal*) value.__Instance;
            }
        }

        /// <summary>The real draw area. E.g. for shadow, outline, or transformed images it's different from `area`</summary>
        public global::lvgl.LvAreaT RealArea
        {
            get
            {
                return global::lvgl.LvAreaT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_real_area));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_real_area = *(global::lvgl.LvAreaT.__Internal*) value.__Instance;
            }
        }

        /// <summary>The original area which is updated</summary>
        public global::lvgl.LvAreaT ClipAreaOriginal
        {
            get
            {
                return global::lvgl.LvAreaT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->clip_area_original));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->clip_area_original = *(global::lvgl.LvAreaT.__Internal*) value.__Instance;
            }
        }

        /// <summary>
        /// <para>The clip area of the layer is saved here when the draw task is created.</para>
        /// <para>As the clip area of the layer can be changed as new draw tasks are added its current value needs to be saved.</para>
        /// <para>Therefore during drawing the layer's clip area shouldn't be used as it might be already changed for other draw tasks.</para>
        /// </summary>
        public global::lvgl.LvAreaT ClipArea
        {
            get
            {
                return global::lvgl.LvAreaT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->clip_area));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->clip_area = *(global::lvgl.LvAreaT.__Internal*) value.__Instance;
            }
        }

        public int State
        {
            get
            {
                return ((__Internal*)__Instance)->state;
            }

            set
            {
                ((__Internal*)__Instance)->state = value;
            }
        }

        public __IntPtr DrawDsc
        {
            get
            {
                return ((__Internal*)__Instance)->draw_dsc;
            }

            set
            {
                ((__Internal*)__Instance)->draw_dsc = (__IntPtr) value;
            }
        }

        /// <summary>The ID of the draw_unit which should take this task</summary>
        public byte PreferredDrawUnitId
        {
            get
            {
                return ((__Internal*)__Instance)->preferred_draw_unit_id;
            }

            set
            {
                ((__Internal*)__Instance)->preferred_draw_unit_id = value;
            }
        }

        /// <summary>
        /// <para>Set to which extent `preferred_draw_unit_id` is good at this task.</para>
        /// <para>80: means 20% better (faster) than software rendering</para>
        /// <para>100: the default value</para>
        /// <para>110: means 10% worse (slower) than software rendering</para>
        /// </summary>
        public byte PreferenceScore
        {
            get
            {
                return ((__Internal*)__Instance)->preference_score;
            }

            set
            {
                ((__Internal*)__Instance)->preference_score = value;
            }
        }
    }

    public unsafe partial class LvDrawMaskT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_mask_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawMaskT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawMaskT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawMaskT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawMaskT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawMaskT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawMaskT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawMaskT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawMaskT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawMaskT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawMaskT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawMaskT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawMaskT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawMaskT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawMaskT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawMaskT(global::lvgl.LvDrawMaskT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawMaskT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawMaskT.__Internal*) __Instance) = *((global::lvgl.LvDrawMaskT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class LvDrawUnitT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal __IntPtr next;
            internal __IntPtr target_layer;
            internal __IntPtr clip_area;
            internal __IntPtr dispatch_cb;
            internal __IntPtr evaluate_cb;
            internal __IntPtr delete_cb;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_draw_unit_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawUnitT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawUnitT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawUnitT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawUnitT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawUnitT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawUnitT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawUnitT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawUnitT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawUnitT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawUnitT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawUnitT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawUnitT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawUnitT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawUnitT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawUnitT(global::lvgl.LvDrawUnitT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawUnitT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawUnitT.__Internal*) __Instance) = *((global::lvgl.LvDrawUnitT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawUnitT Next
        {
            get
            {
                var __result0 = global::lvgl.LvDrawUnitT.__GetOrCreateInstance(((__Internal*)__Instance)->next, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->next = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>The target_layer on which drawing should happen</summary>
        public global::lvgl.LvLayerT TargetLayer
        {
            get
            {
                var __result0 = global::lvgl.LvLayerT.__GetOrCreateInstance(((__Internal*)__Instance)->target_layer, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->target_layer = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvAreaT ClipArea
        {
            get
            {
                var __result0 = global::lvgl.LvAreaT.__GetOrCreateInstance(((__Internal*)__Instance)->clip_area, false);
                return __result0;
            }
        }

        /// <summary>
        /// <para>Called to try to assign a draw task to itself.</para>
        /// <para>`lv_draw_get_next_available_task` can be used to get an independent draw task.</para>
        /// <para>A draw task should be assign only if the draw unit can draw it too</para>
        /// </summary>
        /// <param name="draw_unit">pointer to the draw unit</param>
        /// <param name="layer">pointer to a layer on which the draw task should be drawn</param>
        /// <returns>
        /// <para>&gt;=0:    The number of taken draw task:</para>
        /// <para>0 means the task has not yet been completed.</para>
        /// <para>1 means a new task has been accepted.</para>
        /// <para>-1:     The draw unit wanted to work on a task but couldn't do that</para>
        /// <para>due to some errors (e.g. out of memory).</para>
        /// <para>It signals that LVGL should call the dispatcher later again</para>
        /// <para>to let draw unit try to start the rendering again.</para>
        /// </returns>
        public global::lvgl.Delegates.Func_int___IntPtr___IntPtr DispatchCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->dispatch_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Func_int___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Func_int___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->dispatch_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.Delegates.Func_int___IntPtr___IntPtr EvaluateCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->evaluate_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Func_int___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Func_int___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->evaluate_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Called to delete draw unit.</summary>
        public global::lvgl.Delegates.Func_int___IntPtr DeleteCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->delete_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Func_int___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Func_int___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->delete_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class LvLayerT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 88)]
        public partial struct __Internal
        {
            internal __IntPtr draw_buf;
            internal global::lvgl.LvAreaT.__Internal buf_area;
            internal byte color_format;
            internal global::lvgl.LvAreaT.__Internal _clip_area;
            internal __IntPtr draw_task_head;
            internal __IntPtr parent;
            internal __IntPtr next;
            internal byte all_tasks_added;
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_layer_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvLayerT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvLayerT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvLayerT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvLayerT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvLayerT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvLayerT(native.ToPointer(), skipVTables);
        }

        internal static LvLayerT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvLayerT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvLayerT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvLayerT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvLayerT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvLayerT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvLayerT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvLayerT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvLayerT(global::lvgl.LvLayerT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvLayerT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvLayerT.__Internal*) __Instance) = *((global::lvgl.LvLayerT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Target draw buffer of the layer</summary>
        public global::lvgl.LvDrawBufT DrawBuf
        {
            get
            {
                var __result0 = global::lvgl.LvDrawBufT.__GetOrCreateInstance(((__Internal*)__Instance)->draw_buf, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->draw_buf = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>The absolute coordinates of the buffer</summary>
        public global::lvgl.LvAreaT BufArea
        {
            get
            {
                return global::lvgl.LvAreaT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->buf_area));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->buf_area = *(global::lvgl.LvAreaT.__Internal*) value.__Instance;
            }
        }

        /// <summary>The color format of the layer. LV_COLOR_FORMAT_...</summary>
        public byte ColorFormat
        {
            get
            {
                return ((__Internal*)__Instance)->color_format;
            }

            set
            {
                ((__Internal*)__Instance)->color_format = value;
            }
        }

        /// <summary>
        /// <para>NEVER USE IT DRAW UNITS. USED INTERNALLY DURING DRAW TASK CREATION.</para>
        /// <para>The current clip area with absolute coordinates, always the same or smaller than `buf_area`</para>
        /// <para>Can be set before new draw tasks are added to indicate the clip area of the draw tasks.</para>
        /// <para>Therefore `lv_draw_add_task()` always saves it in the new draw task to know the clip area when the draw task was added.</para>
        /// <para>During drawing the draw units also sees the saved clip_area and should use it during drawing.</para>
        /// <para>During drawing the layer's clip area shouldn't be used as it might be already changed for other draw tasks.</para>
        /// </summary>
        public global::lvgl.LvAreaT ClipArea
        {
            get
            {
                return global::lvgl.LvAreaT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_clip_area));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_clip_area = *(global::lvgl.LvAreaT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Linked list of draw tasks</summary>
        public global::lvgl.LvDrawTaskT DrawTaskHead
        {
            get
            {
                var __result0 = global::lvgl.LvDrawTaskT.__GetOrCreateInstance(((__Internal*)__Instance)->draw_task_head, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->draw_task_head = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvLayerT Parent
        {
            get
            {
                var __result0 = global::lvgl.LvLayerT.__GetOrCreateInstance(((__Internal*)__Instance)->parent, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->parent = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvLayerT Next
        {
            get
            {
                var __result0 = global::lvgl.LvLayerT.__GetOrCreateInstance(((__Internal*)__Instance)->next, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->next = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public bool AllTasksAdded
        {
            get
            {
                return ((__Internal*)__Instance)->all_tasks_added != 0;
            }

            set
            {
                ((__Internal*)__Instance)->all_tasks_added = (byte) (value ? 1 : 0);
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class LvDrawDscBaseT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal __IntPtr obj;
            internal uint part;
            internal uint id1;
            internal uint id2;
            internal __IntPtr layer;
            internal ulong dsc_size;
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_dsc_base_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawDscBaseT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawDscBaseT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawDscBaseT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawDscBaseT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawDscBaseT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawDscBaseT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawDscBaseT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawDscBaseT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawDscBaseT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawDscBaseT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawDscBaseT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawDscBaseT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawDscBaseT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawDscBaseT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawDscBaseT(global::lvgl.LvDrawDscBaseT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawDscBaseT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawDscBaseT.__Internal*) __Instance) = *((global::lvgl.LvDrawDscBaseT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->obj, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->obj = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint Part
        {
            get
            {
                return ((__Internal*)__Instance)->part;
            }

            set
            {
                ((__Internal*)__Instance)->part = value;
            }
        }

        public uint Id1
        {
            get
            {
                return ((__Internal*)__Instance)->id1;
            }

            set
            {
                ((__Internal*)__Instance)->id1 = value;
            }
        }

        public uint Id2
        {
            get
            {
                return ((__Internal*)__Instance)->id2;
            }

            set
            {
                ((__Internal*)__Instance)->id2 = value;
            }
        }

        public global::lvgl.LvLayerT Layer
        {
            get
            {
                var __result0 = global::lvgl.LvLayerT.__GetOrCreateInstance(((__Internal*)__Instance)->layer, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->layer = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public ulong DscSize
        {
            get
            {
                return ((__Internal*)__Instance)->dsc_size;
            }

            set
            {
                ((__Internal*)__Instance)->dsc_size = value;
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class LvDrawGlobalInfoT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 120)]
        public partial struct __Internal
        {
            internal __IntPtr unit_head;
            internal uint used_memory_for_layers_kb;
            internal global::lvgl.LvThreadSyncT.__Internal sync;
            internal global::RTL_CRITICAL_SECTION.__Internal circle_cache_mutex;
            internal byte task_running;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_global_info_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawGlobalInfoT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawGlobalInfoT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawGlobalInfoT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawGlobalInfoT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawGlobalInfoT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawGlobalInfoT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawGlobalInfoT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawGlobalInfoT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawGlobalInfoT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawGlobalInfoT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawGlobalInfoT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawGlobalInfoT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawGlobalInfoT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawGlobalInfoT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawGlobalInfoT(global::lvgl.LvDrawGlobalInfoT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawGlobalInfoT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawGlobalInfoT.__Internal*) __Instance) = *((global::lvgl.LvDrawGlobalInfoT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawUnitT UnitHead
        {
            get
            {
                var __result0 = global::lvgl.LvDrawUnitT.__GetOrCreateInstance(((__Internal*)__Instance)->unit_head, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->unit_head = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint UsedMemoryForLayersKb
        {
            get
            {
                return ((__Internal*)__Instance)->used_memory_for_layers_kb;
            }

            set
            {
                ((__Internal*)__Instance)->used_memory_for_layers_kb = value;
            }
        }

        public global::lvgl.LvThreadSyncT Sync
        {
            get
            {
                return global::lvgl.LvThreadSyncT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sync));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sync = *(global::lvgl.LvThreadSyncT.__Internal*) value.__Instance;
            }
        }

        public bool TaskRunning
        {
            get
            {
                return ((__Internal*)__Instance)->task_running != 0;
            }

            set
            {
                ((__Internal*)__Instance)->task_running = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class lv_draw
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawDeinit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_create_unit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawCreateUnit(ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_add_task", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawAddTask(__IntPtr layer, __IntPtr coords);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_finalize_task_creation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawFinalizeTaskCreation(__IntPtr layer, __IntPtr t);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_dispatch", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawDispatch();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_dispatch_layer", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvDrawDispatchLayer(__IntPtr disp, __IntPtr layer);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_dispatch_wait_for_request", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawDispatchWaitForRequest();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_dispatch_request", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawDispatchRequest();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_get_next_available_task", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawGetNextAvailableTask(__IntPtr layer, __IntPtr t_prev, byte draw_unit_id);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_get_dependent_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvDrawGetDependentCount(__IntPtr t_check);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_layer_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawLayerCreate(__IntPtr parent_layer, byte color_format, __IntPtr area);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_layer_alloc_buf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawLayerAllocBuf(__IntPtr layer);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_layer_go_to_xy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawLayerGoToXy(__IntPtr layer, int x, int y);
        }

        /// <summary>Used internally to initialize the drawing module</summary>
        public static void LvDrawInit()
        {
            __Internal.LvDrawInit();
        }

        /// <summary>Deinitialize the drawing module</summary>
        public static void LvDrawDeinit()
        {
            __Internal.LvDrawDeinit();
        }

        /// <summary>Allocate a new draw unit with the given size and appends it to the list of draw units</summary>
        /// <param name="size">
        /// <para>the size to allocate. E.g. `sizeof(my_draw_unit_t)`,</para>
        /// <para>where the first element of `my_draw_unit_t` is `lv_draw_unit_t`.</para>
        /// </param>
        public static __IntPtr LvDrawCreateUnit(ulong size)
        {
            var ___ret = __Internal.LvDrawCreateUnit(size);
            return ___ret;
        }

        /// <summary>Add an empty draw task to the draw task list of a layer.</summary>
        /// <param name="layer">pointer to a layer</param>
        /// <param name="coords">the coordinates of the draw task</param>
        /// <returns>
        /// <para>the created draw task which needs to be</para>
        /// <para>further configured e.g. by added a draw descriptor</para>
        /// </returns>
        public static global::lvgl.LvDrawTaskT LvDrawAddTask(global::lvgl.LvLayerT layer, global::lvgl.LvAreaT coords)
        {
            var __arg0 = layer is null ? __IntPtr.Zero : layer.__Instance;
            var __arg1 = coords is null ? __IntPtr.Zero : coords.__Instance;
            var ___ret = __Internal.LvDrawAddTask(__arg0, __arg1);
            var __result0 = global::lvgl.LvDrawTaskT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Needs to be called when a draw task is created and configured.</para>
        /// <para>It will send an event about the new draw task to the widget</para>
        /// <para>and assign it to a draw unit.</para>
        /// </summary>
        /// <param name="layer">pointer to a layer</param>
        /// <param name="t">poinr to a draw task</param>
        public static void LvDrawFinalizeTaskCreation(global::lvgl.LvLayerT layer, global::lvgl.LvDrawTaskT t)
        {
            var __arg0 = layer is null ? __IntPtr.Zero : layer.__Instance;
            var __arg1 = t is null ? __IntPtr.Zero : t.__Instance;
            __Internal.LvDrawFinalizeTaskCreation(__arg0, __arg1);
        }

        /// <summary>Try dispatching draw tasks to draw units</summary>
        public static void LvDrawDispatch()
        {
            __Internal.LvDrawDispatch();
        }

        /// <summary>Used internally to try dispatching draw tasks of a specific layer</summary>
        /// <param name="disp">pointer to a display on which the dispatching was requested</param>
        /// <param name="layer">pointer to a layer</param>
        /// <returns>at least one draw task is being rendered (maybe it was taken earlier)</returns>
        public static bool LvDrawDispatchLayer(global::lvgl.LvDisplayT disp, global::lvgl.LvLayerT layer)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var __arg1 = layer is null ? __IntPtr.Zero : layer.__Instance;
            var ___ret = __Internal.LvDrawDispatchLayer(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>
        /// <para>Wait for a new dispatch request.</para>
        /// <para>It's blocking if `LV_USE_OS == 0` else it yields</para>
        /// </summary>
        public static void LvDrawDispatchWaitForRequest()
        {
            __Internal.LvDrawDispatchWaitForRequest();
        }

        /// <summary>
        /// <para>When a draw unit finished a draw task it needs to request dispatching</para>
        /// <para>to let LVGL assign a new draw task to it</para>
        /// </summary>
        public static void LvDrawDispatchRequest()
        {
            __Internal.LvDrawDispatchRequest();
        }

        /// <summary>Find and available draw task</summary>
        /// <param name="layer">the draw ctx to search in</param>
        /// <param name="t_prev">continue searching from this task</param>
        /// <param name="draw_unit_id">check the task where `preferred_draw_unit_id` equals this value or `LV_DRAW_UNIT_ID_ANY`</param>
        /// <returns>tan available draw task or NULL if there is no any</returns>
        public static global::lvgl.LvDrawTaskT LvDrawGetNextAvailableTask(global::lvgl.LvLayerT layer, global::lvgl.LvDrawTaskT t_prev, byte draw_unit_id)
        {
            var __arg0 = layer is null ? __IntPtr.Zero : layer.__Instance;
            var __arg1 = t_prev is null ? __IntPtr.Zero : t_prev.__Instance;
            var ___ret = __Internal.LvDrawGetNextAvailableTask(__arg0, __arg1, draw_unit_id);
            var __result0 = global::lvgl.LvDrawTaskT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Tell how many draw task are waiting to be drawn on the area of `t_check`.</para>
        /// <para>It can be used to determine if a GPU shall combine many draw tasks in to one or not.</para>
        /// <para>If a lot of tasks are waiting for the current ones it makes sense to draw them one-by-one</para>
        /// <para>to not block the dependent tasks' rendering</para>
        /// </summary>
        /// <param name="t_check">the task whose dependent tasks shall be counted</param>
        /// <returns>number of tasks depending on `t_check`</returns>
        public static uint LvDrawGetDependentCount(global::lvgl.LvDrawTaskT t_check)
        {
            var __arg0 = t_check is null ? __IntPtr.Zero : t_check.__Instance;
            var ___ret = __Internal.LvDrawGetDependentCount(__arg0);
            return ___ret;
        }

        /// <summary>Create a new layer on a parent layer</summary>
        /// <param name="parent_layer">the parent layer to which the layer will be merged when it's rendered</param>
        /// <param name="color_format">the color format of the layer</param>
        /// <param name="area">the areas of the layer (absolute coordinates)</param>
        /// <returns>the new target_layer or NULL on error</returns>
        public static global::lvgl.LvLayerT LvDrawLayerCreate(global::lvgl.LvLayerT parent_layer, byte color_format, global::lvgl.LvAreaT area)
        {
            var __arg0 = parent_layer is null ? __IntPtr.Zero : parent_layer.__Instance;
            var __arg2 = area is null ? __IntPtr.Zero : area.__Instance;
            var ___ret = __Internal.LvDrawLayerCreate(__arg0, color_format, __arg2);
            var __result0 = global::lvgl.LvLayerT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Try to allocate a buffer for the layer.</summary>
        /// <param name="layer">pointer to a layer</param>
        /// <returns>pointer to the allocated aligned buffer or NULL on failure</returns>
        public static __IntPtr LvDrawLayerAllocBuf(global::lvgl.LvLayerT layer)
        {
            var __arg0 = layer is null ? __IntPtr.Zero : layer.__Instance;
            var ___ret = __Internal.LvDrawLayerAllocBuf(__arg0);
            return ___ret;
        }

        /// <summary>Got to a pixel at X and Y coordinate on a layer</summary>
        /// <param name="layer">pointer to a layer</param>
        /// <param name="x">the target X coordinate</param>
        /// <param name="y">the target X coordinate</param>
        /// <returns>`buf` offset to point to the given X and Y coordinate</returns>
        public static __IntPtr LvDrawLayerGoToXy(global::lvgl.LvLayerT layer, int x, int y)
        {
            var __arg0 = layer is null ? __IntPtr.Zero : layer.__Instance;
            var ___ret = __Internal.LvDrawLayerGoToXy(__arg0, x, y);
            return ___ret;
        }
    }

    /// <summary>Source of image.</summary>
    public enum LvImageSrcT
    {
        LV_IMAGE_SRC_VARIABLE = 0,
        /// <summary>Binary/C variable</summary>
        LV_IMAGE_SRC_FILE = 1,
        /// <summary>File in filesystem</summary>
        LV_IMAGE_SRC_SYMBOL = 2,
        /// <summary>Symbol (</summary>
        LV_IMAGE_SRC_UNKNOWN = 3
    }

    /// <summary>Get info from an image and store in the `header`</summary>
    /// <param name="src">
    /// <para>the image source. Can be a pointer to a C array or a file name (Use</para>
    /// <para>`lv_image_src_get_type` to determine the type)</para>
    /// </param>
    /// <param name="header">store the info here</param>
    /// <returns>LV_RESULT_OK: info written correctly; LV_RESULT_INVALID: failed</returns>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate byte LvImageDecoderInfoFT(__IntPtr decoder, __IntPtr src, __IntPtr header);

    /// <summary>
    /// <para>Image decoder args.</para>
    /// <para>It determines how to decoder an image, e.g. whether to premultiply the alpha or not.</para>
    /// <para>It should be passed to lv_img_decoder_open() function. If NULL is provided, default</para>
    /// <para>args are used.</para>
    /// </summary>
    /// <remarks>
    /// <para>Default args:</para>
    /// <para>all field are zero or false.</para>
    /// </remarks>
    /// <summary>Open an image for decoding. Prepare it as it is required to read it later</summary>
    /// <param name="decoder">pointer to the decoder the function associated with</param>
    /// <param name="dsc">pointer to decoder descriptor. `src`, `color` are already initialized in it.</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate byte LvImageDecoderOpenFT(__IntPtr decoder, __IntPtr dsc);

    /// <summary>
    /// <para>Decode `full_area` pixels incrementally by calling in a loop. Set `decoded_area` values to `LV_COORD_MIN` on first call.</para>
    /// <para>Required only if the &quot;open&quot; function can't return with the whole decoded pixel array.</para>
    /// </summary>
    /// <param name="decoder">pointer to the decoder the function associated with</param>
    /// <param name="dsc">pointer to decoder descriptor</param>
    /// <param name="full_area">input parameter. the full area to decode after enough subsequent calls</param>
    /// <param name="decoded_area">
    /// <para>input+output parameter. set the values to `LV_COORD_MIN` for the first call and to reset decoding.</para>
    /// <para>the decoded area is stored here after each call.</para>
    /// </param>
    /// <returns>LV_RESULT_OK: ok; LV_RESULT_INVALID: failed or there is nothing left to decode</returns>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate byte LvImageDecoderGetAreaCbT(__IntPtr decoder, __IntPtr dsc, __IntPtr full_area, __IntPtr decoded_area);

    /// <summary>Close the pending decoding. Free resources etc.</summary>
    /// <param name="decoder">pointer to the decoder the function associated with</param>
    /// <param name="dsc">pointer to decoder descriptor</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvImageDecoderCloseFT(__IntPtr decoder, __IntPtr dsc);

    /// <summary>
    /// <para>Image decoder args.</para>
    /// <para>It determines how to decoder an image, e.g. whether to premultiply the alpha or not.</para>
    /// <para>It should be passed to lv_img_decoder_open() function. If NULL is provided, default</para>
    /// <para>args are used.</para>
    /// </summary>
    /// <remarks>
    /// <para>Default args:</para>
    /// <para>all field are zero or false.</para>
    /// </remarks>
    public unsafe partial class LvImageDecoderArgsT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 5)]
        public partial struct __Internal
        {
            internal byte stride_align;
            internal byte premultiply;
            internal byte no_cache;
            internal byte use_indexed;
            internal byte flush_cache;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_image_decoder_args_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImageDecoderArgsT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImageDecoderArgsT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvImageDecoderArgsT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvImageDecoderArgsT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvImageDecoderArgsT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvImageDecoderArgsT(native.ToPointer(), skipVTables);
        }

        internal static LvImageDecoderArgsT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvImageDecoderArgsT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvImageDecoderArgsT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvImageDecoderArgsT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvImageDecoderArgsT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvImageDecoderArgsT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvImageDecoderArgsT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImageDecoderArgsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvImageDecoderArgsT(global::lvgl.LvImageDecoderArgsT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImageDecoderArgsT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvImageDecoderArgsT.__Internal*) __Instance) = *((global::lvgl.LvImageDecoderArgsT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool StrideAlign
        {
            get
            {
                return ((__Internal*)__Instance)->stride_align != 0;
            }

            set
            {
                ((__Internal*)__Instance)->stride_align = (byte) (value ? 1 : 0);
            }
        }

        public bool Premultiply
        {
            get
            {
                return ((__Internal*)__Instance)->premultiply != 0;
            }

            set
            {
                ((__Internal*)__Instance)->premultiply = (byte) (value ? 1 : 0);
            }
        }

        public bool NoCache
        {
            get
            {
                return ((__Internal*)__Instance)->no_cache != 0;
            }

            set
            {
                ((__Internal*)__Instance)->no_cache = (byte) (value ? 1 : 0);
            }
        }

        public bool UseIndexed
        {
            get
            {
                return ((__Internal*)__Instance)->use_indexed != 0;
            }

            set
            {
                ((__Internal*)__Instance)->use_indexed = (byte) (value ? 1 : 0);
            }
        }

        public bool FlushCache
        {
            get
            {
                return ((__Internal*)__Instance)->flush_cache != 0;
            }

            set
            {
                ((__Internal*)__Instance)->flush_cache = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class LvImageDecoderT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal __IntPtr info_cb;
            internal __IntPtr open_cb;
            internal __IntPtr get_area_cb;
            internal __IntPtr close_cb;
            internal __IntPtr name;
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_image_decoder_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImageDecoderT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImageDecoderT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvImageDecoderT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvImageDecoderT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __name_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static LvImageDecoderT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvImageDecoderT(native.ToPointer(), skipVTables);
        }

        internal static LvImageDecoderT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvImageDecoderT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvImageDecoderT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvImageDecoderT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvImageDecoderT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvImageDecoderT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvImageDecoderT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImageDecoderT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvImageDecoderT(global::lvgl.LvImageDecoderT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImageDecoderT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvImageDecoderT.__Internal*) __Instance) = *((global::lvgl.LvImageDecoderT.__Internal*) _0.__Instance);
            if (_0.__name_OwnsNativeMemory)
                this.Name = _0.Name;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvImageDecoderInfoFT InfoCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->info_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvImageDecoderInfoFT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvImageDecoderInfoFT));
            }

            set
            {
                ((__Internal*)__Instance)->info_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.LvImageDecoderOpenFT OpenCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->open_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvImageDecoderOpenFT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvImageDecoderOpenFT));
            }

            set
            {
                ((__Internal*)__Instance)->open_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.LvImageDecoderGetAreaCbT GetAreaCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_area_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvImageDecoderGetAreaCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvImageDecoderGetAreaCbT));
            }

            set
            {
                ((__Internal*)__Instance)->get_area_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.LvImageDecoderCloseFT CloseCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->close_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvImageDecoderCloseFT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvImageDecoderCloseFT));
            }

            set
            {
                ((__Internal*)__Instance)->close_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public string Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->name);
            }

            set
            {
                if (__name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                __name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->name = (__IntPtr) __bytePtr0;
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class LvImageDecoderCacheDataT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal global::lvgl.LvCacheSlotSizeT.__Internal slot;
            internal __IntPtr src;
            internal byte src_type;
            internal __IntPtr decoded;
            internal __IntPtr decoder;
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_image_decoder_cache_data_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImageDecoderCacheDataT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImageDecoderCacheDataT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvImageDecoderCacheDataT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvImageDecoderCacheDataT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvImageDecoderCacheDataT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvImageDecoderCacheDataT(native.ToPointer(), skipVTables);
        }

        internal static LvImageDecoderCacheDataT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvImageDecoderCacheDataT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvImageDecoderCacheDataT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvImageDecoderCacheDataT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvImageDecoderCacheDataT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvImageDecoderCacheDataT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvImageDecoderCacheDataT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImageDecoderCacheDataT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvImageDecoderCacheDataT(global::lvgl.LvImageDecoderCacheDataT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImageDecoderCacheDataT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvImageDecoderCacheDataT.__Internal*) __Instance) = *((global::lvgl.LvImageDecoderCacheDataT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvCacheSlotSizeT Slot
        {
            get
            {
                return global::lvgl.LvCacheSlotSizeT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->slot));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->slot = *(global::lvgl.LvCacheSlotSizeT.__Internal*) value.__Instance;
            }
        }

        public __IntPtr Src
        {
            get
            {
                return ((__Internal*)__Instance)->src;
            }
        }

        public byte SrcType
        {
            get
            {
                return ((__Internal*)__Instance)->src_type;
            }

            set
            {
                ((__Internal*)__Instance)->src_type = value;
            }
        }

        public global::lvgl.LvDrawBufT Decoded
        {
            get
            {
                var __result0 = global::lvgl.LvDrawBufT.__GetOrCreateInstance(((__Internal*)__Instance)->decoded, false);
                return __result0;
            }
        }

        public global::lvgl.LvImageDecoderT Decoder
        {
            get
            {
                var __result0 = global::lvgl.LvImageDecoderT.__GetOrCreateInstance(((__Internal*)__Instance)->decoder, false);
                return __result0;
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class LvImageDecoderHeaderCacheDataT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr src;
            internal byte src_type;
            internal global::lvgl.LvImageHeaderT.__Internal header;
            internal __IntPtr decoder;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_image_decoder_header_cache_data_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImageDecoderHeaderCacheDataT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImageDecoderHeaderCacheDataT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvImageDecoderHeaderCacheDataT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvImageDecoderHeaderCacheDataT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvImageDecoderHeaderCacheDataT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvImageDecoderHeaderCacheDataT(native.ToPointer(), skipVTables);
        }

        internal static LvImageDecoderHeaderCacheDataT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvImageDecoderHeaderCacheDataT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvImageDecoderHeaderCacheDataT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvImageDecoderHeaderCacheDataT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvImageDecoderHeaderCacheDataT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvImageDecoderHeaderCacheDataT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvImageDecoderHeaderCacheDataT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImageDecoderHeaderCacheDataT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvImageDecoderHeaderCacheDataT(global::lvgl.LvImageDecoderHeaderCacheDataT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImageDecoderHeaderCacheDataT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvImageDecoderHeaderCacheDataT.__Internal*) __Instance) = *((global::lvgl.LvImageDecoderHeaderCacheDataT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Src
        {
            get
            {
                return ((__Internal*)__Instance)->src;
            }
        }

        public byte SrcType
        {
            get
            {
                return ((__Internal*)__Instance)->src_type;
            }

            set
            {
                ((__Internal*)__Instance)->src_type = value;
            }
        }

        public global::lvgl.LvImageHeaderT Header
        {
            get
            {
                return global::lvgl.LvImageHeaderT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->header));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->header = *(global::lvgl.LvImageHeaderT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvImageDecoderT Decoder
        {
            get
            {
                var __result0 = global::lvgl.LvImageDecoderT.__GetOrCreateInstance(((__Internal*)__Instance)->decoder, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->decoder = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Describe an image decoding session. Stores data about the decoding</summary>
    public unsafe partial class LvImageDecoderDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 96)]
        public partial struct __Internal
        {
            internal __IntPtr decoder;
            internal global::lvgl.LvImageDecoderArgsT.__Internal args;
            internal __IntPtr src;
            internal byte src_type;
            internal global::lvgl.LvImageHeaderT.__Internal header;
            internal __IntPtr decoded;
            internal __IntPtr palette;
            internal uint palette_size;
            internal uint time_to_open;
            internal __IntPtr error_msg;
            internal __IntPtr cache;
            internal __IntPtr cache_entry;
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_image_decoder_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImageDecoderDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImageDecoderDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvImageDecoderDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvImageDecoderDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __error_msg_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static LvImageDecoderDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvImageDecoderDscT(native.ToPointer(), skipVTables);
        }

        internal static LvImageDecoderDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvImageDecoderDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvImageDecoderDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvImageDecoderDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvImageDecoderDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvImageDecoderDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvImageDecoderDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImageDecoderDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvImageDecoderDscT(global::lvgl.LvImageDecoderDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImageDecoderDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvImageDecoderDscT.__Internal*) __Instance) = *((global::lvgl.LvImageDecoderDscT.__Internal*) _0.__Instance);
            if (_0.__error_msg_OwnsNativeMemory)
                this.ErrorMsg = _0.ErrorMsg;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__error_msg_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->error_msg);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The decoder which was able to open the image source</summary>
        public global::lvgl.LvImageDecoderT Decoder
        {
            get
            {
                var __result0 = global::lvgl.LvImageDecoderT.__GetOrCreateInstance(((__Internal*)__Instance)->decoder, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->decoder = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>A copy of parameters of how this image is decoded</summary>
        public global::lvgl.LvImageDecoderArgsT Args
        {
            get
            {
                return global::lvgl.LvImageDecoderArgsT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->args));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->args = *(global::lvgl.LvImageDecoderArgsT.__Internal*) value.__Instance;
            }
        }

        /// <summary>The image source. A file path like &quot;S:my_img.png&quot; or pointer to an `lv_image_dsc_t` variable</summary>
        public __IntPtr Src
        {
            get
            {
                return ((__Internal*)__Instance)->src;
            }
        }

        /// <summary>Type of the source: file or variable. Can be set in `open` function if required</summary>
        public byte SrcType
        {
            get
            {
                return ((__Internal*)__Instance)->src_type;
            }

            set
            {
                ((__Internal*)__Instance)->src_type = value;
            }
        }

        /// <summary>Info about the opened image: color format, size, etc. MUST be set in `open` function</summary>
        public global::lvgl.LvImageHeaderT Header
        {
            get
            {
                return global::lvgl.LvImageHeaderT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->header));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->header = *(global::lvgl.LvImageHeaderT.__Internal*) value.__Instance;
            }
        }

        /// <summary>
        /// <para>Pointer to a draw buffer where the image's data (pixels) are stored in a decoded, plain format.</para>
        /// <para>MUST be set in `open` or `get_area_cb`function</para>
        /// </summary>
        public global::lvgl.LvDrawBufT Decoded
        {
            get
            {
                var __result0 = global::lvgl.LvDrawBufT.__GetOrCreateInstance(((__Internal*)__Instance)->decoded, false);
                return __result0;
            }
        }

        public global::lvgl.LvColor32T Palette
        {
            get
            {
                var __result0 = global::lvgl.LvColor32T.__GetOrCreateInstance(((__Internal*)__Instance)->palette, false);
                return __result0;
            }
        }

        public uint PaletteSize
        {
            get
            {
                return ((__Internal*)__Instance)->palette_size;
            }

            set
            {
                ((__Internal*)__Instance)->palette_size = value;
            }
        }

        /// <summary>
        /// <para>How much time did it take to open the image. [ms]</para>
        /// <para>If not set `lv_image_cache` will measure and set the time to open</para>
        /// </summary>
        public uint TimeToOpen
        {
            get
            {
                return ((__Internal*)__Instance)->time_to_open;
            }

            set
            {
                ((__Internal*)__Instance)->time_to_open = value;
            }
        }

        /// <summary>
        /// <para>A text to display instead of the image when the image can't be opened.</para>
        /// <para>Can be set in `open` function or set NULL.</para>
        /// </summary>
        public string ErrorMsg
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->error_msg);
            }

            set
            {
                if (__error_msg_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->error_msg);
                __error_msg_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->error_msg = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->error_msg = (__IntPtr) __bytePtr0;
            }
        }

        public global::lvgl.LvCacheT Cache
        {
            get
            {
                var __result0 = global::lvgl.LvCacheT.__GetOrCreateInstance(((__Internal*)__Instance)->cache, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->cache = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Point to cache entry information</summary>
        public global::lvgl.LvCacheEntryT CacheEntry
        {
            get
            {
                var __result0 = global::lvgl.LvCacheEntryT.__GetOrCreateInstance(((__Internal*)__Instance)->cache_entry, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->cache_entry = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Store any custom data here is required</summary>
        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class lv_image_decoder
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_image_decoder_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageDecoderInit(uint image_cache_size, uint image_header_count);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_image_decoder_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageDecoderDeinit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_decoder_get_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvImageDecoderGetInfo(__IntPtr src, __IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_decoder_open", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvImageDecoderOpen(__IntPtr dsc, __IntPtr src, __IntPtr args);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_decoder_get_area", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvImageDecoderGetArea(__IntPtr dsc, __IntPtr full_area, __IntPtr decoded_area);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_decoder_close", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageDecoderClose(__IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_decoder_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvImageDecoderCreate();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_decoder_delete", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageDecoderDelete(__IntPtr decoder);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_decoder_get_next", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvImageDecoderGetNext(__IntPtr decoder);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_decoder_set_info_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageDecoderSetInfoCb(__IntPtr decoder, __IntPtr info_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_decoder_set_open_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageDecoderSetOpenCb(__IntPtr decoder, __IntPtr open_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_decoder_set_get_area_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageDecoderSetGetAreaCb(__IntPtr decoder, __IntPtr read_line_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_decoder_set_close_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageDecoderSetCloseCb(__IntPtr decoder, __IntPtr close_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_decoder_add_to_cache", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvImageDecoderAddToCache(__IntPtr decoder, __IntPtr search_key, __IntPtr decoded, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_decoder_post_process", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvImageDecoderPostProcess(__IntPtr dsc, __IntPtr decoded);
        }

        /// <summary>Initialize the image decoder module</summary>
        /// <param name="image_cache_size">Image cache size in bytes. 0 to disable cache.</param>
        /// <param name="image_header_count">Number of header cache entries. 0 to disable header cache.</param>
        public static void LvImageDecoderInit(uint image_cache_size, uint image_header_count)
        {
            __Internal.LvImageDecoderInit(image_cache_size, image_header_count);
        }

        /// <summary>Deinitialize the image decoder module</summary>
        public static void LvImageDecoderDeinit()
        {
            __Internal.LvImageDecoderDeinit();
        }

        /// <summary>
        /// <para>Get information about an image.</para>
        /// <para>Try the created image decoder one by one. Once one is able to get info that info will be used.</para>
        /// </summary>
        /// <param name="src">
        /// <para>the image source. Can be</para>
        /// <para>1) File name: E.g. &quot;S:folder/img1.png&quot; (The drivers needs to registered via `lv_fs_drv_register()`)</para>
        /// <para>2) Variable: Pointer to an `lv_image_dsc_t` variable</para>
        /// <para>3) Symbol: E.g. `LV_SYMBOL_OK`</para>
        /// </param>
        /// <param name="header">the image info will be stored here</param>
        /// <returns>LV_RESULT_OK: success; LV_RESULT_INVALID: wasn't able to get info about the image</returns>
        public static byte LvImageDecoderGetInfo(__IntPtr src, global::lvgl.LvImageHeaderT header)
        {
            var __arg1 = header is null ? __IntPtr.Zero : header.__Instance;
            var ___ret = __Internal.LvImageDecoderGetInfo(src, __arg1);
            return ___ret;
        }

        /// <summary>
        /// <para>Open an image.</para>
        /// <para>Try the created image decoders one by one. Once one is able to open the image that decoder is saved in `dsc`</para>
        /// </summary>
        /// <param name="dsc">describes a decoding session. Simply a pointer to an `lv_image_decoder_dsc_t` variable.</param>
        /// <param name="src">
        /// <para>the image source. Can be</para>
        /// <para>1) File name: E.g. &quot;S:folder/img1.png&quot; (The drivers needs to registered via `lv_fs_drv_register())`)</para>
        /// <para>2) Variable: Pointer to an `lv_image_dsc_t` variable</para>
        /// <para>3) Symbol: E.g. `LV_SYMBOL_OK`</para>
        /// </param>
        /// <param name="color">The color of the image with `LV_COLOR_FORMAT_ALPHA_...`</param>
        /// <param name="args">args about how the image should be opened.</param>
        /// <returns>
        /// <para>LV_RESULT_OK: opened the image. `dsc-&gt;decoded` and `dsc-&gt;header` are set.</para>
        /// <para>LV_RESULT_INVALID: none of the registered image decoders were able to open the image.</para>
        /// </returns>
        public static byte LvImageDecoderOpen(global::lvgl.LvImageDecoderDscT dsc, __IntPtr src, global::lvgl.LvImageDecoderArgsT args)
        {
            var __arg0 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var __arg2 = args is null ? __IntPtr.Zero : args.__Instance;
            var ___ret = __Internal.LvImageDecoderOpen(__arg0, src, __arg2);
            return ___ret;
        }

        /// <summary>
        /// <para>*</para>
        /// <para>Decode `full_area` pixels incrementally by calling in a loop. Set `decoded_area` to `LV_COORD_MIN` on first call.</para>
        /// </summary>
        /// <param name="dsc">image decoder descriptor</param>
        /// <param name="full_area">input parameter. the full area to decode after enough subsequent calls</param>
        /// <param name="decoded_area">
        /// <para>input+output parameter. set the values to `LV_COORD_MIN` for the first call and to reset decoding.</para>
        /// <para>the decoded area is stored here after each call.</para>
        /// </param>
        /// <returns>LV_RESULT_OK: success; LV_RESULT_INVALID: an error occurred or there is nothing left to decode</returns>
        public static byte LvImageDecoderGetArea(global::lvgl.LvImageDecoderDscT dsc, global::lvgl.LvAreaT full_area, global::lvgl.LvAreaT decoded_area)
        {
            var __arg0 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var __arg1 = full_area is null ? __IntPtr.Zero : full_area.__Instance;
            var __arg2 = decoded_area is null ? __IntPtr.Zero : decoded_area.__Instance;
            var ___ret = __Internal.LvImageDecoderGetArea(__arg0, __arg1, __arg2);
            return ___ret;
        }

        /// <summary>Close a decoding session</summary>
        /// <param name="dsc">pointer to `lv_image_decoder_dsc_t` used in `lv_image_decoder_open`</param>
        public static void LvImageDecoderClose(global::lvgl.LvImageDecoderDscT dsc)
        {
            var __arg0 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvImageDecoderClose(__arg0);
        }

        /// <summary>Create a new image decoder</summary>
        /// <returns>pointer to the new image decoder</returns>
        public static global::lvgl.LvImageDecoderT LvImageDecoderCreate()
        {
            var ___ret = __Internal.LvImageDecoderCreate();
            var __result0 = global::lvgl.LvImageDecoderT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Delete an image decoder</summary>
        /// <param name="decoder">pointer to an image decoder</param>
        public static void LvImageDecoderDelete(global::lvgl.LvImageDecoderT decoder)
        {
            var __arg0 = decoder is null ? __IntPtr.Zero : decoder.__Instance;
            __Internal.LvImageDecoderDelete(__arg0);
        }

        /// <summary>Get the next image decoder in the linked list of image decoders</summary>
        /// <param name="decoder">pointer to an image decoder or NULL to get the first one</param>
        /// <returns>the next image decoder or NULL if no more image decoder exists</returns>
        public static global::lvgl.LvImageDecoderT LvImageDecoderGetNext(global::lvgl.LvImageDecoderT decoder)
        {
            var __arg0 = decoder is null ? __IntPtr.Zero : decoder.__Instance;
            var ___ret = __Internal.LvImageDecoderGetNext(__arg0);
            var __result0 = global::lvgl.LvImageDecoderT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set a callback to get information about the image</summary>
        /// <param name="decoder">pointer to an image decoder</param>
        /// <param name="info_cb">a function to collect info about an image (fill an `lv_image_header_t` struct)</param>
        public static void LvImageDecoderSetInfoCb(global::lvgl.LvImageDecoderT decoder, global::lvgl.LvImageDecoderInfoFT info_cb)
        {
            var __arg0 = decoder is null ? __IntPtr.Zero : decoder.__Instance;
            var __arg1 = info_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(info_cb);
            __Internal.LvImageDecoderSetInfoCb(__arg0, __arg1);
        }

        /// <summary>Set a callback to open an image</summary>
        /// <param name="decoder">pointer to an image decoder</param>
        /// <param name="open_cb">a function to open an image</param>
        public static void LvImageDecoderSetOpenCb(global::lvgl.LvImageDecoderT decoder, global::lvgl.LvImageDecoderOpenFT open_cb)
        {
            var __arg0 = decoder is null ? __IntPtr.Zero : decoder.__Instance;
            var __arg1 = open_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(open_cb);
            __Internal.LvImageDecoderSetOpenCb(__arg0, __arg1);
        }

        /// <summary>Set a callback to a decoded line of an image</summary>
        /// <param name="decoder">pointer to an image decoder</param>
        /// <param name="read_line_cb">a function to read a line of an image</param>
        public static void LvImageDecoderSetGetAreaCb(global::lvgl.LvImageDecoderT decoder, global::lvgl.LvImageDecoderGetAreaCbT read_line_cb)
        {
            var __arg0 = decoder is null ? __IntPtr.Zero : decoder.__Instance;
            var __arg1 = read_line_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(read_line_cb);
            __Internal.LvImageDecoderSetGetAreaCb(__arg0, __arg1);
        }

        /// <summary>Set a callback to close a decoding session. E.g. close files and free other resources.</summary>
        /// <param name="decoder">pointer to an image decoder</param>
        /// <param name="close_cb">a function to close a decoding session</param>
        public static void LvImageDecoderSetCloseCb(global::lvgl.LvImageDecoderT decoder, global::lvgl.LvImageDecoderCloseFT close_cb)
        {
            var __arg0 = decoder is null ? __IntPtr.Zero : decoder.__Instance;
            var __arg1 = close_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(close_cb);
            __Internal.LvImageDecoderSetCloseCb(__arg0, __arg1);
        }

        public static global::lvgl.LvCacheEntryT LvImageDecoderAddToCache(global::lvgl.LvImageDecoderT decoder, global::lvgl.LvImageDecoderCacheDataT search_key, global::lvgl.LvDrawBufT decoded, __IntPtr user_data)
        {
            var __arg0 = decoder is null ? __IntPtr.Zero : decoder.__Instance;
            var __arg1 = search_key is null ? __IntPtr.Zero : search_key.__Instance;
            var __arg2 = decoded is null ? __IntPtr.Zero : decoded.__Instance;
            var ___ret = __Internal.LvImageDecoderAddToCache(__arg0, __arg1, __arg2, user_data);
            var __result0 = global::lvgl.LvCacheEntryT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Check the decoded image, make any modification if decoder `args` requires.</summary>
        /// <param name="dsc">pointer to a decoder descriptor</param>
        /// <param name="decoded">pointer to a decoded image to post process to meet dsc-&gt;args requirement.</param>
        /// <returns>post processed draw buffer, when it differs with `decoded`, it's newly allocated.</returns>
        /// <remarks>A new draw buf will be allocated if provided `decoded` is not modifiable or stride mismatch etc.</remarks>
        public static global::lvgl.LvDrawBufT LvImageDecoderPostProcess(global::lvgl.LvImageDecoderDscT dsc, global::lvgl.LvDrawBufT decoded)
        {
            var __arg0 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var __arg1 = decoded is null ? __IntPtr.Zero : decoded.__Instance;
            var ___ret = __Internal.LvImageDecoderPostProcess(__arg0, __arg1);
            var __result0 = global::lvgl.LvDrawBufT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>Errors in the file system module.</summary>
    public enum LvFsResT
    {
        LV_FS_RES_OK = 0,
        LV_FS_RES_HW_ERR = 1,
        LV_FS_RES_FS_ERR = 2,
        LV_FS_RES_NOT_EX = 3,
        LV_FS_RES_FULL = 4,
        LV_FS_RES_LOCKED = 5,
        LV_FS_RES_DENIED = 6,
        LV_FS_RES_BUSY = 7,
        LV_FS_RES_TOUT = 8,
        LV_FS_RES_NOT_IMP = 9,
        LV_FS_RES_OUT_OF_MEM = 10,
        LV_FS_RES_INV_PARAM = 11,
        LV_FS_RES_UNKNOWN = 12
    }

    /// <summary>File open mode.</summary>
    public enum LvFsModeT
    {
        LV_FS_MODE_WR = 1,
        LV_FS_MODE_RD = 2
    }

    /// <summary>Seek modes.</summary>
    public enum LvFsWhenceT
    {
        /// <summary>Set the position from absolutely (from the start of file)</summary>
        LV_FS_SEEK_SET = 0,
        /// <summary>Set the position from the current position</summary>
        LV_FS_SEEK_CUR = 1,
        /// <summary>Set the position from the end of the file</summary>
        LV_FS_SEEK_END = 2
    }

    /// <summary>Seek modes.</summary>
    public unsafe partial class LvFsDrvT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 96)]
        public partial struct __Internal
        {
            internal sbyte letter;
            internal uint cache_size;
            internal __IntPtr ready_cb;
            internal __IntPtr open_cb;
            internal __IntPtr close_cb;
            internal __IntPtr read_cb;
            internal __IntPtr write_cb;
            internal __IntPtr seek_cb;
            internal __IntPtr tell_cb;
            internal __IntPtr dir_open_cb;
            internal __IntPtr dir_read_cb;
            internal __IntPtr dir_close_cb;
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_fs_drv_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFsDrvT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFsDrvT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvFsDrvT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvFsDrvT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvFsDrvT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvFsDrvT(native.ToPointer(), skipVTables);
        }

        internal static LvFsDrvT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvFsDrvT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvFsDrvT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvFsDrvT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvFsDrvT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvFsDrvT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvFsDrvT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFsDrvT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvFsDrvT(global::lvgl.LvFsDrvT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFsDrvT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvFsDrvT.__Internal*) __Instance) = *((global::lvgl.LvFsDrvT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte Letter
        {
            get
            {
                return ((__Internal*)__Instance)->letter;
            }

            set
            {
                ((__Internal*)__Instance)->letter = value;
            }
        }

        public uint CacheSize
        {
            get
            {
                return ((__Internal*)__Instance)->cache_size;
            }

            set
            {
                ((__Internal*)__Instance)->cache_size = value;
            }
        }

        public global::lvgl.Delegates.Func_bool___IntPtr ReadyCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ready_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Func_bool___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Func_bool___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->ready_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.Delegates.Func___IntPtr___IntPtr_string8_byte OpenCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->open_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Func___IntPtr___IntPtr_string8_byte) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Func___IntPtr___IntPtr_string8_byte));
            }

            set
            {
                ((__Internal*)__Instance)->open_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.Delegates.Func_byte___IntPtr___IntPtr CloseCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->close_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Func_byte___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Func_byte___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->close_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.Delegates.Func_byte___IntPtr___IntPtr___IntPtr_uint_uintPtr ReadCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->read_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Func_byte___IntPtr___IntPtr___IntPtr_uint_uintPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Func_byte___IntPtr___IntPtr___IntPtr_uint_uintPtr));
            }

            set
            {
                ((__Internal*)__Instance)->read_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.Delegates.Func_byte___IntPtr___IntPtr___IntPtr_uint_uintPtr WriteCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->write_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Func_byte___IntPtr___IntPtr___IntPtr_uint_uintPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Func_byte___IntPtr___IntPtr___IntPtr_uint_uintPtr));
            }

            set
            {
                ((__Internal*)__Instance)->write_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.Delegates.Func_byte___IntPtr___IntPtr_uint_lvgl_lv_fs_whence_t SeekCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->seek_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Func_byte___IntPtr___IntPtr_uint_lvgl_lv_fs_whence_t) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Func_byte___IntPtr___IntPtr_uint_lvgl_lv_fs_whence_t));
            }

            set
            {
                ((__Internal*)__Instance)->seek_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.Delegates.Func_byte___IntPtr___IntPtr_uintPtr TellCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->tell_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Func_byte___IntPtr___IntPtr_uintPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Func_byte___IntPtr___IntPtr_uintPtr));
            }

            set
            {
                ((__Internal*)__Instance)->tell_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.Delegates.Func___IntPtr___IntPtr_string8 DirOpenCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->dir_open_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Func___IntPtr___IntPtr_string8) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Func___IntPtr___IntPtr_string8));
            }

            set
            {
                ((__Internal*)__Instance)->dir_open_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.Delegates.Func_byte___IntPtr___IntPtr_sbytePtr_uint DirReadCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->dir_read_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Func_byte___IntPtr___IntPtr_sbytePtr_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Func_byte___IntPtr___IntPtr_sbytePtr_uint));
            }

            set
            {
                ((__Internal*)__Instance)->dir_read_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.Delegates.Func_byte___IntPtr___IntPtr DirCloseCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->dir_close_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Func_byte___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Func_byte___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->dir_close_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Custom file user data</summary>
        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class LvFsFileCacheT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal uint start;
            internal uint end;
            internal uint file_position;
            internal __IntPtr buffer;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_fs_file_cache_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFsFileCacheT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFsFileCacheT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvFsFileCacheT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvFsFileCacheT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvFsFileCacheT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvFsFileCacheT(native.ToPointer(), skipVTables);
        }

        internal static LvFsFileCacheT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvFsFileCacheT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvFsFileCacheT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvFsFileCacheT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvFsFileCacheT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvFsFileCacheT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvFsFileCacheT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFsFileCacheT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvFsFileCacheT(global::lvgl.LvFsFileCacheT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFsFileCacheT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvFsFileCacheT.__Internal*) __Instance) = *((global::lvgl.LvFsFileCacheT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Start
        {
            get
            {
                return ((__Internal*)__Instance)->start;
            }

            set
            {
                ((__Internal*)__Instance)->start = value;
            }
        }

        public uint End
        {
            get
            {
                return ((__Internal*)__Instance)->end;
            }

            set
            {
                ((__Internal*)__Instance)->end = value;
            }
        }

        public uint FilePosition
        {
            get
            {
                return ((__Internal*)__Instance)->file_position;
            }

            set
            {
                ((__Internal*)__Instance)->file_position = value;
            }
        }

        public __IntPtr Buffer
        {
            get
            {
                return ((__Internal*)__Instance)->buffer;
            }

            set
            {
                ((__Internal*)__Instance)->buffer = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class LvFsFileT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr file_d;
            internal __IntPtr drv;
            internal __IntPtr cache;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_fs_file_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFsFileT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFsFileT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvFsFileT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvFsFileT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvFsFileT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvFsFileT(native.ToPointer(), skipVTables);
        }

        internal static LvFsFileT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvFsFileT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvFsFileT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvFsFileT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvFsFileT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvFsFileT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvFsFileT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFsFileT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvFsFileT(global::lvgl.LvFsFileT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFsFileT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvFsFileT.__Internal*) __Instance) = *((global::lvgl.LvFsFileT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr FileD
        {
            get
            {
                return ((__Internal*)__Instance)->file_d;
            }

            set
            {
                ((__Internal*)__Instance)->file_d = (__IntPtr) value;
            }
        }

        public global::lvgl.LvFsDrvT Drv
        {
            get
            {
                var __result0 = global::lvgl.LvFsDrvT.__GetOrCreateInstance(((__Internal*)__Instance)->drv, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->drv = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvFsFileCacheT Cache
        {
            get
            {
                var __result0 = global::lvgl.LvFsFileCacheT.__GetOrCreateInstance(((__Internal*)__Instance)->cache, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->cache = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class LvFsPathExT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal fixed sbyte path[4];
            internal __IntPtr buffer;
            internal uint size;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_fs_path_ex_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFsPathExT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFsPathExT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvFsPathExT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvFsPathExT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvFsPathExT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvFsPathExT(native.ToPointer(), skipVTables);
        }

        internal static LvFsPathExT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvFsPathExT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvFsPathExT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvFsPathExT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvFsPathExT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvFsPathExT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvFsPathExT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFsPathExT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvFsPathExT(global::lvgl.LvFsPathExT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFsPathExT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvFsPathExT.__Internal*) __Instance) = *((global::lvgl.LvFsPathExT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] Path
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->path, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->path[i] = value[i];
                }
            }
        }

        public __IntPtr Buffer
        {
            get
            {
                return ((__Internal*)__Instance)->buffer;
            }
        }

        public uint Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }
    }

    public unsafe partial class LvFsDirT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr dir_d;
            internal __IntPtr drv;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_fs_dir_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFsDirT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFsDirT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvFsDirT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvFsDirT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvFsDirT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvFsDirT(native.ToPointer(), skipVTables);
        }

        internal static LvFsDirT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvFsDirT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvFsDirT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvFsDirT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvFsDirT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvFsDirT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvFsDirT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFsDirT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvFsDirT(global::lvgl.LvFsDirT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFsDirT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvFsDirT.__Internal*) __Instance) = *((global::lvgl.LvFsDirT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr DirD
        {
            get
            {
                return ((__Internal*)__Instance)->dir_d;
            }

            set
            {
                ((__Internal*)__Instance)->dir_d = (__IntPtr) value;
            }
        }

        public global::lvgl.LvFsDrvT Drv
        {
            get
            {
                var __result0 = global::lvgl.LvFsDrvT.__GetOrCreateInstance(((__Internal*)__Instance)->drv, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->drv = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class lv_fs
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_fs_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvFsInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_fs_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvFsDeinit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_drv_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvFsDrvInit(__IntPtr drv);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_drv_register", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvFsDrvRegister(__IntPtr drv);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_get_drv", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvFsGetDrv(sbyte letter);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_is_ready", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvFsIsReady(sbyte letter);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_open", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvFsOpen(__IntPtr file_p, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path, byte mode);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_make_path_from_buffer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvFsMakePathFromBuffer(__IntPtr path, sbyte letter, __IntPtr buf, uint size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_close", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvFsClose(__IntPtr file_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_read", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvFsRead(__IntPtr file_p, __IntPtr buf, uint btr, uint* br);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_write", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvFsWrite(__IntPtr file_p, __IntPtr buf, uint btw, uint* bw);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_seek", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvFsSeek(__IntPtr file_p, uint pos, global::lvgl.LvFsWhenceT whence);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_tell", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvFsTell(__IntPtr file_p, uint* pos);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_dir_open", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvFsDirOpen(__IntPtr rddir_p, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_dir_read", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvFsDirRead(__IntPtr rddir_p, sbyte* fn, uint fn_len);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_dir_close", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvFsDirClose(__IntPtr rddir_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_get_letters", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* LvFsGetLetters(sbyte* buf);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_get_ext", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvFsGetExt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fn);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_up", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* LvFsUp(sbyte* path);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_get_last", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvFsGetLast([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path);
        }

        /// <summary>Initialize the File system interface</summary>
        public static void LvFsInit()
        {
            __Internal.LvFsInit();
        }

        /// <summary>Deinitialize the File system interface</summary>
        public static void LvFsDeinit()
        {
            __Internal.LvFsDeinit();
        }

        /// <summary>
        /// <para>Initialize a file system driver with default values.</para>
        /// <para>It is used to ensure all fields have known values and not memory junk.</para>
        /// <para>After it you can set the fields.</para>
        /// </summary>
        /// <param name="drv">pointer to driver variable to initialize</param>
        public static void LvFsDrvInit(global::lvgl.LvFsDrvT drv)
        {
            var __arg0 = drv is null ? __IntPtr.Zero : drv.__Instance;
            __Internal.LvFsDrvInit(__arg0);
        }

        /// <summary>Add a new drive</summary>
        /// <param name="drv">
        /// <para>pointer to an lv_fs_drv_t structure which is inited with the</para>
        /// <para>corresponding function pointers. Only pointer is saved, so the</para>
        /// <para>driver should be static or dynamically allocated.</para>
        /// </param>
        public static void LvFsDrvRegister(global::lvgl.LvFsDrvT drv)
        {
            var __arg0 = drv is null ? __IntPtr.Zero : drv.__Instance;
            __Internal.LvFsDrvRegister(__arg0);
        }

        /// <summary>Give a pointer to a driver from its letter</summary>
        /// <param name="letter">the driver letter</param>
        /// <returns>pointer to a driver or NULL if not found</returns>
        public static global::lvgl.LvFsDrvT LvFsGetDrv(sbyte letter)
        {
            var ___ret = __Internal.LvFsGetDrv(letter);
            var __result0 = global::lvgl.LvFsDrvT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Test if a drive is ready or not. If the `ready` function was not initialized `true` will be</para>
        /// <para>returned.</para>
        /// </summary>
        /// <param name="letter">letter of the drive</param>
        /// <returns>true: drive is ready; false: drive is not ready</returns>
        public static bool LvFsIsReady(sbyte letter)
        {
            var ___ret = __Internal.LvFsIsReady(letter);
            return ___ret;
        }

        /// <summary>Open a file</summary>
        /// <param name="file_p">pointer to a lv_fs_file_t variable</param>
        /// <param name="path">path to the file beginning with the driver letter (e.g. S:/folder/file.txt)</param>
        /// <param name="mode">read: FS_MODE_RD, write: FS_MODE_WR, both: FS_MODE_RD | FS_MODE_WR</param>
        /// <returns>LV_FS_RES_OK or any error from lv_fs_res_t enum</returns>
        public static byte LvFsOpen(global::lvgl.LvFsFileT file_p, string path, byte mode)
        {
            var __arg0 = file_p is null ? __IntPtr.Zero : file_p.__Instance;
            var ___ret = __Internal.LvFsOpen(__arg0, path, mode);
            return ___ret;
        }

        /// <summary>Make a path object for the memory-mapped file compatible with the file system interface</summary>
        /// <param name="path">path to a lv_fs_path_ex object</param>
        /// <param name="letter">the letter of the driver. E.g. `LV_FS_MEMFS_LETTER`</param>
        /// <param name="buf">address of the memory buffer</param>
        /// <param name="size">size of the memory buffer in bytes</param>
        public static void LvFsMakePathFromBuffer(global::lvgl.LvFsPathExT path, sbyte letter, __IntPtr buf, uint size)
        {
            var __arg0 = path is null ? __IntPtr.Zero : path.__Instance;
            __Internal.LvFsMakePathFromBuffer(__arg0, letter, buf, size);
        }

        /// <summary>Close an already opened file</summary>
        /// <param name="file_p">pointer to a lv_fs_file_t variable</param>
        /// <returns>LV_FS_RES_OK or any error from lv_fs_res_t enum</returns>
        public static byte LvFsClose(global::lvgl.LvFsFileT file_p)
        {
            var __arg0 = file_p is null ? __IntPtr.Zero : file_p.__Instance;
            var ___ret = __Internal.LvFsClose(__arg0);
            return ___ret;
        }

        /// <summary>Read from a file</summary>
        /// <param name="file_p">pointer to a lv_fs_file_t variable</param>
        /// <param name="buf">pointer to a buffer where the read bytes are stored</param>
        /// <param name="btr">Bytes To Read</param>
        /// <param name="br">the number of real read bytes (Bytes Read). NULL if unused.</param>
        /// <returns>LV_FS_RES_OK or any error from lv_fs_res_t enum</returns>
        public static byte LvFsRead(global::lvgl.LvFsFileT file_p, __IntPtr buf, uint btr, ref uint br)
        {
            var __arg0 = file_p is null ? __IntPtr.Zero : file_p.__Instance;
            fixed (uint* __br3 = &br)
            {
                var __arg3 = __br3;
                var ___ret = __Internal.LvFsRead(__arg0, buf, btr, __arg3);
                return ___ret;
            }
        }

        /// <summary>Write into a file</summary>
        /// <param name="file_p">pointer to a lv_fs_file_t variable</param>
        /// <param name="buf">pointer to a buffer with the bytes to write</param>
        /// <param name="btw">Bytes To Write</param>
        /// <param name="bw">the number of real written bytes (Bytes Written). NULL if unused.</param>
        /// <returns>LV_FS_RES_OK or any error from lv_fs_res_t enum</returns>
        public static byte LvFsWrite(global::lvgl.LvFsFileT file_p, __IntPtr buf, uint btw, ref uint bw)
        {
            var __arg0 = file_p is null ? __IntPtr.Zero : file_p.__Instance;
            fixed (uint* __bw3 = &bw)
            {
                var __arg3 = __bw3;
                var ___ret = __Internal.LvFsWrite(__arg0, buf, btw, __arg3);
                return ___ret;
            }
        }

        /// <summary>Set the position of the 'cursor' (read write pointer) in a file</summary>
        /// <param name="file_p">pointer to a lv_fs_file_t variable</param>
        /// <param name="pos">the new position expressed in bytes index (0: start of file)</param>
        /// <param name="whence">tells from where set the position. See</param>
        /// <returns>LV_FS_RES_OK or any error from lv_fs_res_t enum</returns>
        /// <remarks>_fs_whence_t</remarks>
        public static byte LvFsSeek(global::lvgl.LvFsFileT file_p, uint pos, global::lvgl.LvFsWhenceT whence)
        {
            var __arg0 = file_p is null ? __IntPtr.Zero : file_p.__Instance;
            var ___ret = __Internal.LvFsSeek(__arg0, pos, whence);
            return ___ret;
        }

        /// <summary>Give the position of the read write pointer</summary>
        /// <param name="file_p">pointer to a lv_fs_file_t variable</param>
        /// <param name="pos">pointer to store the position of the read write pointer</param>
        /// <returns>LV_FS_RES_OK or any error from 'fs_res_t'</returns>
        public static byte LvFsTell(global::lvgl.LvFsFileT file_p, ref uint pos)
        {
            var __arg0 = file_p is null ? __IntPtr.Zero : file_p.__Instance;
            fixed (uint* __pos1 = &pos)
            {
                var __arg1 = __pos1;
                var ___ret = __Internal.LvFsTell(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>Initialize a 'fs_dir_t' variable for directory reading</summary>
        /// <param name="rddir_p">pointer to a 'lv_fs_dir_t' variable</param>
        /// <param name="path">path to a directory</param>
        /// <returns>LV_FS_RES_OK or any error from lv_fs_res_t enum</returns>
        public static byte LvFsDirOpen(global::lvgl.LvFsDirT rddir_p, string path)
        {
            var __arg0 = rddir_p is null ? __IntPtr.Zero : rddir_p.__Instance;
            var ___ret = __Internal.LvFsDirOpen(__arg0, path);
            return ___ret;
        }

        /// <summary>
        /// <para>Read the next filename form a directory.</para>
        /// <para>The name of the directories will begin with '/'</para>
        /// </summary>
        /// <param name="rddir_p">pointer to an initialized 'fs_dir_t' variable</param>
        /// <param name="fn">pointer to a buffer to store the filename</param>
        /// <param name="fn_len">length of the buffer to store the filename</param>
        /// <returns>LV_FS_RES_OK or any error from lv_fs_res_t enum</returns>
        public static byte LvFsDirRead(global::lvgl.LvFsDirT rddir_p, sbyte* fn, uint fn_len)
        {
            var __arg0 = rddir_p is null ? __IntPtr.Zero : rddir_p.__Instance;
            var ___ret = __Internal.LvFsDirRead(__arg0, fn, fn_len);
            return ___ret;
        }

        /// <summary>Close the directory reading</summary>
        /// <param name="rddir_p">pointer to an initialized 'fs_dir_t' variable</param>
        /// <returns>LV_FS_RES_OK or any error from lv_fs_res_t enum</returns>
        public static byte LvFsDirClose(global::lvgl.LvFsDirT rddir_p)
        {
            var __arg0 = rddir_p is null ? __IntPtr.Zero : rddir_p.__Instance;
            var ___ret = __Internal.LvFsDirClose(__arg0);
            return ___ret;
        }

        /// <summary>Fill a buffer with the letters of existing drivers</summary>
        /// <param name="buf">buffer to store the letters ('\0' added after the last letter)</param>
        /// <returns>the buffer</returns>
        public static sbyte* LvFsGetLetters(sbyte* buf)
        {
            var ___ret = __Internal.LvFsGetLetters(buf);
            return ___ret;
        }

        /// <summary>Return with the extension of the filename</summary>
        /// <param name="fn">string with a filename</param>
        /// <returns>pointer to the beginning extension or empty string if no extension</returns>
        public static string LvFsGetExt(string fn)
        {
            var ___ret = __Internal.LvFsGetExt(fn);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Step up one level</summary>
        /// <param name="path">pointer to a file name</param>
        /// <returns>the truncated file name</returns>
        public static sbyte* LvFsUp(sbyte* path)
        {
            var ___ret = __Internal.LvFsUp(path);
            return ___ret;
        }

        /// <summary>Get the last element of a path (e.g. U:/folder/file -&gt; file)</summary>
        /// <param name="path">pointer to a file name</param>
        /// <returns>pointer to the beginning of the last element in the path</returns>
        public static string LvFsGetLast(string path)
        {
            var ___ret = __Internal.LvFsGetLast(path);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvDrawRectDscT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 144)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvDrawDscBaseT.__Internal @base;

            [FieldOffset(48)]
            internal int radius;

            [FieldOffset(52)]
            internal byte bg_opa;

            [FieldOffset(53)]
            internal global::lvgl.LvColorT.__Internal bg_color;

            [FieldOffset(56)]
            internal global::lvgl.LvGradDscT.__Internal bg_grad;

            [FieldOffset(72)]
            internal __IntPtr bg_image_src;

            [FieldOffset(80)]
            internal __IntPtr bg_image_symbol_font;

            [FieldOffset(88)]
            internal global::lvgl.LvColorT.__Internal bg_image_recolor;

            [FieldOffset(91)]
            internal byte bg_image_opa;

            [FieldOffset(92)]
            internal byte bg_image_recolor_opa;

            [FieldOffset(93)]
            internal byte bg_image_tiled;

            [FieldOffset(94)]
            internal global::lvgl.LvColorT.__Internal border_color;

            [FieldOffset(100)]
            internal int border_width;

            [FieldOffset(104)]
            internal byte border_opa;

            [FieldOffset(105)]
            internal byte border_side;

            [FieldOffset(105)]
            internal byte border_post;

            [FieldOffset(106)]
            internal global::lvgl.LvColorT.__Internal outline_color;

            [FieldOffset(112)]
            internal int outline_width;

            [FieldOffset(116)]
            internal int outline_pad;

            [FieldOffset(120)]
            internal byte outline_opa;

            [FieldOffset(121)]
            internal global::lvgl.LvColorT.__Internal shadow_color;

            [FieldOffset(124)]
            internal int shadow_width;

            [FieldOffset(128)]
            internal int shadow_offset_x;

            [FieldOffset(132)]
            internal int shadow_offset_y;

            [FieldOffset(136)]
            internal int shadow_spread;

            [FieldOffset(140)]
            internal byte shadow_opa;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_rect_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawRectDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawRectDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawRectDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawRectDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawRectDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawRectDscT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawRectDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawRectDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawRectDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawRectDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawRectDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawRectDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawRectDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawRectDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawRectDscT(global::lvgl.LvDrawRectDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawRectDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawRectDscT.__Internal*) __Instance) = *((global::lvgl.LvDrawRectDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawDscBaseT Base
        {
            get
            {
                return global::lvgl.LvDrawDscBaseT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->@base));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->@base = *(global::lvgl.LvDrawDscBaseT.__Internal*) value.__Instance;
            }
        }

        public int Radius
        {
            get
            {
                return ((__Internal*)__Instance)->radius;
            }

            set
            {
                ((__Internal*)__Instance)->radius = value;
            }
        }

        public byte BgOpa
        {
            get
            {
                return ((__Internal*)__Instance)->bg_opa;
            }

            set
            {
                ((__Internal*)__Instance)->bg_opa = value;
            }
        }

        /// <summary>First element of a gradient is a color, so it maps well here</summary>
        public global::lvgl.LvColorT BgColor
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->bg_color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->bg_color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvGradDscT BgGrad
        {
            get
            {
                return global::lvgl.LvGradDscT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->bg_grad));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->bg_grad = *(global::lvgl.LvGradDscT.__Internal*) value.__Instance;
            }
        }

        public __IntPtr BgImageSrc
        {
            get
            {
                return ((__Internal*)__Instance)->bg_image_src;
            }
        }

        public __IntPtr BgImageSymbolFont
        {
            get
            {
                return ((__Internal*)__Instance)->bg_image_symbol_font;
            }
        }

        public global::lvgl.LvColorT BgImageRecolor
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->bg_image_recolor));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->bg_image_recolor = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public byte BgImageOpa
        {
            get
            {
                return ((__Internal*)__Instance)->bg_image_opa;
            }

            set
            {
                ((__Internal*)__Instance)->bg_image_opa = value;
            }
        }

        public byte BgImageRecolorOpa
        {
            get
            {
                return ((__Internal*)__Instance)->bg_image_recolor_opa;
            }

            set
            {
                ((__Internal*)__Instance)->bg_image_recolor_opa = value;
            }
        }

        public byte BgImageTiled
        {
            get
            {
                return ((__Internal*)__Instance)->bg_image_tiled;
            }

            set
            {
                ((__Internal*)__Instance)->bg_image_tiled = value;
            }
        }

        public global::lvgl.LvColorT BorderColor
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->border_color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->border_color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public int BorderWidth
        {
            get
            {
                return ((__Internal*)__Instance)->border_width;
            }

            set
            {
                ((__Internal*)__Instance)->border_width = value;
            }
        }

        public byte BorderOpa
        {
            get
            {
                return ((__Internal*)__Instance)->border_opa;
            }

            set
            {
                ((__Internal*)__Instance)->border_opa = value;
            }
        }

        public byte BorderSide
        {
            get
            {
                return ((__Internal*)__Instance)->border_side;
            }

            set
            {
                ((__Internal*)__Instance)->border_side = value;
            }
        }

        public byte BorderPost
        {
            get
            {
                return ((__Internal*)__Instance)->border_post;
            }

            set
            {
                ((__Internal*)__Instance)->border_post = value;
            }
        }

        public global::lvgl.LvColorT OutlineColor
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->outline_color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->outline_color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public int OutlineWidth
        {
            get
            {
                return ((__Internal*)__Instance)->outline_width;
            }

            set
            {
                ((__Internal*)__Instance)->outline_width = value;
            }
        }

        public int OutlinePad
        {
            get
            {
                return ((__Internal*)__Instance)->outline_pad;
            }

            set
            {
                ((__Internal*)__Instance)->outline_pad = value;
            }
        }

        public byte OutlineOpa
        {
            get
            {
                return ((__Internal*)__Instance)->outline_opa;
            }

            set
            {
                ((__Internal*)__Instance)->outline_opa = value;
            }
        }

        public global::lvgl.LvColorT ShadowColor
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->shadow_color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->shadow_color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public int ShadowWidth
        {
            get
            {
                return ((__Internal*)__Instance)->shadow_width;
            }

            set
            {
                ((__Internal*)__Instance)->shadow_width = value;
            }
        }

        public int ShadowOffsetX
        {
            get
            {
                return ((__Internal*)__Instance)->shadow_offset_x;
            }

            set
            {
                ((__Internal*)__Instance)->shadow_offset_x = value;
            }
        }

        public int ShadowOffsetY
        {
            get
            {
                return ((__Internal*)__Instance)->shadow_offset_y;
            }

            set
            {
                ((__Internal*)__Instance)->shadow_offset_y = value;
            }
        }

        public int ShadowSpread
        {
            get
            {
                return ((__Internal*)__Instance)->shadow_spread;
            }

            set
            {
                ((__Internal*)__Instance)->shadow_spread = value;
            }
        }

        public byte ShadowOpa
        {
            get
            {
                return ((__Internal*)__Instance)->shadow_opa;
            }

            set
            {
                ((__Internal*)__Instance)->shadow_opa = value;
            }
        }
    }

    public unsafe partial class LvDrawFillDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal global::lvgl.LvDrawDscBaseT.__Internal @base;
            internal int radius;
            internal byte opa;
            internal global::lvgl.LvColorT.__Internal color;
            internal global::lvgl.LvGradDscT.__Internal grad;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_fill_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawFillDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawFillDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawFillDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawFillDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawFillDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawFillDscT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawFillDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawFillDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawFillDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawFillDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawFillDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawFillDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawFillDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawFillDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawFillDscT(global::lvgl.LvDrawFillDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawFillDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawFillDscT.__Internal*) __Instance) = *((global::lvgl.LvDrawFillDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawDscBaseT Base
        {
            get
            {
                return global::lvgl.LvDrawDscBaseT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->@base));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->@base = *(global::lvgl.LvDrawDscBaseT.__Internal*) value.__Instance;
            }
        }

        public int Radius
        {
            get
            {
                return ((__Internal*)__Instance)->radius;
            }

            set
            {
                ((__Internal*)__Instance)->radius = value;
            }
        }

        public byte Opa
        {
            get
            {
                return ((__Internal*)__Instance)->opa;
            }

            set
            {
                ((__Internal*)__Instance)->opa = value;
            }
        }

        public global::lvgl.LvColorT Color
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvGradDscT Grad
        {
            get
            {
                return global::lvgl.LvGradDscT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->grad));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->grad = *(global::lvgl.LvGradDscT.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class LvDrawBorderDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal global::lvgl.LvDrawDscBaseT.__Internal @base;
            internal int radius;
            internal global::lvgl.LvColorT.__Internal color;
            internal int width;
            internal byte opa;
            internal byte side;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_border_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawBorderDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawBorderDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawBorderDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawBorderDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawBorderDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawBorderDscT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawBorderDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawBorderDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawBorderDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawBorderDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawBorderDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawBorderDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawBorderDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawBorderDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawBorderDscT(global::lvgl.LvDrawBorderDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawBorderDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawBorderDscT.__Internal*) __Instance) = *((global::lvgl.LvDrawBorderDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawDscBaseT Base
        {
            get
            {
                return global::lvgl.LvDrawDscBaseT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->@base));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->@base = *(global::lvgl.LvDrawDscBaseT.__Internal*) value.__Instance;
            }
        }

        public int Radius
        {
            get
            {
                return ((__Internal*)__Instance)->radius;
            }

            set
            {
                ((__Internal*)__Instance)->radius = value;
            }
        }

        public global::lvgl.LvColorT Color
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public int Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public byte Opa
        {
            get
            {
                return ((__Internal*)__Instance)->opa;
            }

            set
            {
                ((__Internal*)__Instance)->opa = value;
            }
        }

        public byte Side
        {
            get
            {
                return ((__Internal*)__Instance)->side;
            }

            set
            {
                ((__Internal*)__Instance)->side = value;
            }
        }
    }

    public unsafe partial class LvDrawBoxShadowDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 80)]
        public partial struct __Internal
        {
            internal global::lvgl.LvDrawDscBaseT.__Internal @base;
            internal int radius;
            internal global::lvgl.LvColorT.__Internal color;
            internal int width;
            internal int spread;
            internal int ofs_x;
            internal int ofs_y;
            internal byte opa;
            internal byte bg_cover;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_box_shadow_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawBoxShadowDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawBoxShadowDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawBoxShadowDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawBoxShadowDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawBoxShadowDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawBoxShadowDscT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawBoxShadowDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawBoxShadowDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawBoxShadowDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawBoxShadowDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawBoxShadowDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawBoxShadowDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawBoxShadowDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawBoxShadowDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawBoxShadowDscT(global::lvgl.LvDrawBoxShadowDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawBoxShadowDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawBoxShadowDscT.__Internal*) __Instance) = *((global::lvgl.LvDrawBoxShadowDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawDscBaseT Base
        {
            get
            {
                return global::lvgl.LvDrawDscBaseT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->@base));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->@base = *(global::lvgl.LvDrawDscBaseT.__Internal*) value.__Instance;
            }
        }

        public int Radius
        {
            get
            {
                return ((__Internal*)__Instance)->radius;
            }

            set
            {
                ((__Internal*)__Instance)->radius = value;
            }
        }

        public global::lvgl.LvColorT Color
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public int Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public int Spread
        {
            get
            {
                return ((__Internal*)__Instance)->spread;
            }

            set
            {
                ((__Internal*)__Instance)->spread = value;
            }
        }

        public int OfsX
        {
            get
            {
                return ((__Internal*)__Instance)->ofs_x;
            }

            set
            {
                ((__Internal*)__Instance)->ofs_x = value;
            }
        }

        public int OfsY
        {
            get
            {
                return ((__Internal*)__Instance)->ofs_y;
            }

            set
            {
                ((__Internal*)__Instance)->ofs_y = value;
            }
        }

        public byte Opa
        {
            get
            {
                return ((__Internal*)__Instance)->opa;
            }

            set
            {
                ((__Internal*)__Instance)->opa = value;
            }
        }

        public byte BgCover
        {
            get
            {
                return ((__Internal*)__Instance)->bg_cover;
            }

            set
            {
                ((__Internal*)__Instance)->bg_cover = value;
            }
        }
    }

    public unsafe partial class lv_draw_rect
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_rect_dsc_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawRectDscInit(__IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_fill_dsc_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawFillDscInit(__IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_task_get_fill_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawTaskGetFillDsc(__IntPtr task);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_border_dsc_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawBorderDscInit(__IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_task_get_border_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawTaskGetBorderDsc(__IntPtr task);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_box_shadow_dsc_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawBoxShadowDscInit(__IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_task_get_box_shadow_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawTaskGetBoxShadowDsc(__IntPtr task);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_rect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawRect(__IntPtr layer, __IntPtr dsc, __IntPtr coords);
        }

        /// <summary>Initialize a rectangle draw descriptor.</summary>
        /// <param name="dsc">pointer to a draw descriptor</param>
        public static void LvDrawRectDscInit(global::lvgl.LvDrawRectDscT dsc)
        {
            var __arg0 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvDrawRectDscInit(__arg0);
        }

        /// <summary>Initialize a fill draw descriptor.</summary>
        /// <param name="dsc">pointer to a draw descriptor</param>
        public static void LvDrawFillDscInit(global::lvgl.LvDrawFillDscT dsc)
        {
            var __arg0 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvDrawFillDscInit(__arg0);
        }

        /// <summary>Try to get a fill draw descriptor from a draw task.</summary>
        /// <param name="task">draw task</param>
        /// <returns>the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_FILL</returns>
        public static global::lvgl.LvDrawFillDscT LvDrawTaskGetFillDsc(global::lvgl.LvDrawTaskT task)
        {
            var __arg0 = task is null ? __IntPtr.Zero : task.__Instance;
            var ___ret = __Internal.LvDrawTaskGetFillDsc(__arg0);
            var __result0 = global::lvgl.LvDrawFillDscT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Initialize a border draw descriptor.</summary>
        /// <param name="dsc">pointer to a draw descriptor</param>
        public static void LvDrawBorderDscInit(global::lvgl.LvDrawBorderDscT dsc)
        {
            var __arg0 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvDrawBorderDscInit(__arg0);
        }

        /// <summary>Try to get a border draw descriptor from a draw task.</summary>
        /// <param name="task">draw task</param>
        /// <returns>the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_BORDER</returns>
        public static global::lvgl.LvDrawBorderDscT LvDrawTaskGetBorderDsc(global::lvgl.LvDrawTaskT task)
        {
            var __arg0 = task is null ? __IntPtr.Zero : task.__Instance;
            var ___ret = __Internal.LvDrawTaskGetBorderDsc(__arg0);
            var __result0 = global::lvgl.LvDrawBorderDscT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Initialize a box shadow draw descriptor.</summary>
        /// <param name="dsc">pointer to a draw descriptor</param>
        public static void LvDrawBoxShadowDscInit(global::lvgl.LvDrawBoxShadowDscT dsc)
        {
            var __arg0 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvDrawBoxShadowDscInit(__arg0);
        }

        /// <summary>Try to get a box shadow draw descriptor from a draw task.</summary>
        /// <param name="task">draw task</param>
        /// <returns>the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_BOX_SHADOW</returns>
        public static global::lvgl.LvDrawBoxShadowDscT LvDrawTaskGetBoxShadowDsc(global::lvgl.LvDrawTaskT task)
        {
            var __arg0 = task is null ? __IntPtr.Zero : task.__Instance;
            var ___ret = __Internal.LvDrawTaskGetBoxShadowDsc(__arg0);
            var __result0 = global::lvgl.LvDrawBoxShadowDscT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>The rectangle is a wrapper for fill, border, bg. image and box shadow.</para>
        /// <para>Internally fill, border, image and box shadow draw tasks will be created.</para>
        /// </summary>
        /// <param name="layer">pointer to a layer</param>
        /// <param name="dsc">pointer to an initialized draw descriptor variable</param>
        /// <param name="coords">the coordinates of the rectangle</param>
        public static void LvDrawRect(global::lvgl.LvLayerT layer, global::lvgl.LvDrawRectDscT dsc, global::lvgl.LvAreaT coords)
        {
            var __arg0 = layer is null ? __IntPtr.Zero : layer.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var __arg2 = coords is null ? __IntPtr.Zero : coords.__Instance;
            __Internal.LvDrawRect(__arg0, __arg1, __arg2);
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvGradientCacheT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr color_map;
            internal __IntPtr opa_map;
            internal uint size;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_gradient_cache_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvGradientCacheT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvGradientCacheT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvGradientCacheT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvGradientCacheT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvGradientCacheT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvGradientCacheT(native.ToPointer(), skipVTables);
        }

        internal static LvGradientCacheT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvGradientCacheT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvGradientCacheT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvGradientCacheT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvGradientCacheT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvGradientCacheT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvGradientCacheT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvGradientCacheT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvGradientCacheT(global::lvgl.LvGradientCacheT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvGradientCacheT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvGradientCacheT.__Internal*) __Instance) = *((global::lvgl.LvGradientCacheT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvColorT ColorMap
        {
            get
            {
                var __result0 = global::lvgl.LvColorT.__GetOrCreateInstance(((__Internal*)__Instance)->color_map, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->color_map = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public byte* OpaMap
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->opa_map;
            }

            set
            {
                ((__Internal*)__Instance)->opa_map = (__IntPtr) value;
            }
        }

        public uint Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }
    }

    public unsafe partial class lv_draw_sw_gradient
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_gradient_color_calculate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGradientColorCalculate(__IntPtr dsc, int range, int frac, __IntPtr color_out, byte* opa_out);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_gradient_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvGradientGet(__IntPtr gradient, int w, int h);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_gradient_cleanup", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGradientCleanup(__IntPtr grad);
        }

        /// <summary>
        /// <para>********************</para>
        /// <para>PROTOTYPES</para>
        /// <para>********************</para>
        /// </summary>
        /// <param name="dsc">The gradient descriptor to use</param>
        /// <param name="range">The range to use in computation.</param>
        /// <param name="frac">The current part used in the range. frac is in [0; range]</param>
        /// <remarks>
        /// <para>Compute the color in the given gradient and fraction</para>
        /// <para>Gradient are specified in a virtual [0-255] range, so this function scales the virtual range to the given range</para>
        /// </remarks>
        public static void LvGradientColorCalculate(global::lvgl.LvGradDscT dsc, int range, int frac, global::lvgl.LvColorT color_out, byte* opa_out)
        {
            var __arg0 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var __arg3 = color_out is null ? __IntPtr.Zero : color_out.__Instance;
            __Internal.LvGradientColorCalculate(__arg0, range, frac, __arg3, opa_out);
        }

        /// <summary>Get a gradient cache from the given parameters</summary>
        public static global::lvgl.LvGradientCacheT LvGradientGet(global::lvgl.LvGradDscT gradient, int w, int h)
        {
            var __arg0 = gradient is null ? __IntPtr.Zero : gradient.__Instance;
            var ___ret = __Internal.LvGradientGet(__arg0, w, h);
            var __result0 = global::lvgl.LvGradientCacheT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Clean up the gradient item after it was get with `lv_grad_get_from_cache`.</summary>
        /// <param name="grad">pointer to a gradient</param>
        public static void LvGradientCleanup(global::lvgl.LvGradientCacheT grad)
        {
            var __arg0 = grad is null ? __IntPtr.Zero : grad.__Instance;
            __Internal.LvGradientCleanup(__arg0);
        }
    }

    /// <summary>
    /// <para>Store some info to speed up drawing of very large texts</para>
    /// <para>It takes a lot of time to get the first visible character because</para>
    /// <para>all the previous characters needs to be checked to calculate the positions.</para>
    /// <para>This structure stores an earlier (e.g. at -1000 px) coordinate and the index of that line.</para>
    /// <para>Therefore the calculations can start from here.</para>
    /// </summary>
    /// <summary>
    /// <para>Passed as a parameter to `lv_draw_label_iterate_characters` to</para>
    /// <para>draw the characters one by one</para>
    /// </summary>
    /// <param name="draw_unit">pointer to a draw unit</param>
    /// <param name="dsc">
    /// <para>pointer to `lv_draw_glyph_dsc_t` to describe the character to draw</para>
    /// <para>if NULL don't draw character</para>
    /// </param>
    /// <param name="fill_dsc">
    /// <para>pointer to a fill descriptor to draw a background for the character or</para>
    /// <para>underline or strike through</para>
    /// <para>if NULL do not fill anything</para>
    /// </param>
    /// <param name="fill_area">
    /// <para>the area to fill</para>
    /// <para>if NULL do not fill anything</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvDrawGlyphCbT(__IntPtr draw_unit, __IntPtr dsc, __IntPtr fill_dsc, __IntPtr fill_area);

    /// <summary>
    /// <para>Store some info to speed up drawing of very large texts</para>
    /// <para>It takes a lot of time to get the first visible character because</para>
    /// <para>all the previous characters needs to be checked to calculate the positions.</para>
    /// <para>This structure stores an earlier (e.g. at -1000 px) coordinate and the index of that line.</para>
    /// <para>Therefore the calculations can start from here.</para>
    /// </summary>
    public unsafe partial class LvDrawLabelHintT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal int line_start;
            internal int y;
            internal int coord_y;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_draw_label_hint_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawLabelHintT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawLabelHintT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawLabelHintT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawLabelHintT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawLabelHintT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawLabelHintT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawLabelHintT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawLabelHintT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawLabelHintT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawLabelHintT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawLabelHintT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawLabelHintT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawLabelHintT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawLabelHintT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawLabelHintT(global::lvgl.LvDrawLabelHintT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawLabelHintT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawLabelHintT.__Internal*) __Instance) = *((global::lvgl.LvDrawLabelHintT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Index of the line at `y` coordinate</summary>
        public int LineStart
        {
            get
            {
                return ((__Internal*)__Instance)->line_start;
            }

            set
            {
                ((__Internal*)__Instance)->line_start = value;
            }
        }

        /// <summary>Give the `y` coordinate of the first letter at `line start` index. Relative to the label's coordinates</summary>
        public int Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        /// <summary>
        /// <para>The 'y1' coordinate of the label when the hint was saved.</para>
        /// <para>Used to invalidate the hint if the label has moved too much.</para>
        /// </summary>
        public int CoordY
        {
            get
            {
                return ((__Internal*)__Instance)->coord_y;
            }

            set
            {
                ((__Internal*)__Instance)->coord_y = value;
            }
        }
    }

    public unsafe partial class LvDrawLabelDscT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 120)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvDrawDscBaseT.__Internal @base;

            [FieldOffset(48)]
            internal __IntPtr text;

            [FieldOffset(56)]
            internal __IntPtr font;

            [FieldOffset(64)]
            internal uint sel_start;

            [FieldOffset(68)]
            internal uint sel_end;

            [FieldOffset(72)]
            internal global::lvgl.LvColorT.__Internal color;

            [FieldOffset(75)]
            internal global::lvgl.LvColorT.__Internal sel_color;

            [FieldOffset(78)]
            internal global::lvgl.LvColorT.__Internal sel_bg_color;

            [FieldOffset(84)]
            internal int line_space;

            [FieldOffset(88)]
            internal int letter_space;

            [FieldOffset(92)]
            internal int ofs_x;

            [FieldOffset(96)]
            internal int ofs_y;

            [FieldOffset(100)]
            internal byte opa;

            [FieldOffset(101)]
            internal byte bidi_dir;

            [FieldOffset(102)]
            internal byte align;

            [FieldOffset(103)]
            internal byte flag;

            [FieldOffset(104)]
            internal byte decor;

            [FieldOffset(104)]
            internal byte blend_mode;

            [FieldOffset(104)]
            internal byte text_local;

            [FieldOffset(112)]
            internal __IntPtr hint;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_label_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawLabelDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawLabelDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawLabelDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawLabelDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __text_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static LvDrawLabelDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawLabelDscT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawLabelDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawLabelDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawLabelDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawLabelDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawLabelDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawLabelDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawLabelDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawLabelDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawLabelDscT(global::lvgl.LvDrawLabelDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawLabelDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawLabelDscT.__Internal*) __Instance) = *((global::lvgl.LvDrawLabelDscT.__Internal*) _0.__Instance);
            if (_0.__text_OwnsNativeMemory)
                this.Text = _0.Text;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__text_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->text);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawDscBaseT Base
        {
            get
            {
                return global::lvgl.LvDrawDscBaseT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->@base));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->@base = *(global::lvgl.LvDrawDscBaseT.__Internal*) value.__Instance;
            }
        }

        public string Text
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->text);
            }

            set
            {
                if (__text_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->text);
                __text_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->text = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->text = (__IntPtr) __bytePtr0;
            }
        }

        public global::lvgl.LvFontT Font
        {
            get
            {
                var __result0 = global::lvgl.LvFontT.__GetOrCreateInstance(((__Internal*)__Instance)->font, false);
                return __result0;
            }
        }

        public uint SelStart
        {
            get
            {
                return ((__Internal*)__Instance)->sel_start;
            }

            set
            {
                ((__Internal*)__Instance)->sel_start = value;
            }
        }

        public uint SelEnd
        {
            get
            {
                return ((__Internal*)__Instance)->sel_end;
            }

            set
            {
                ((__Internal*)__Instance)->sel_end = value;
            }
        }

        public global::lvgl.LvColorT Color
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvColorT SelColor
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sel_color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sel_color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvColorT SelBgColor
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sel_bg_color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sel_bg_color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public int LineSpace
        {
            get
            {
                return ((__Internal*)__Instance)->line_space;
            }

            set
            {
                ((__Internal*)__Instance)->line_space = value;
            }
        }

        public int LetterSpace
        {
            get
            {
                return ((__Internal*)__Instance)->letter_space;
            }

            set
            {
                ((__Internal*)__Instance)->letter_space = value;
            }
        }

        public int OfsX
        {
            get
            {
                return ((__Internal*)__Instance)->ofs_x;
            }

            set
            {
                ((__Internal*)__Instance)->ofs_x = value;
            }
        }

        public int OfsY
        {
            get
            {
                return ((__Internal*)__Instance)->ofs_y;
            }

            set
            {
                ((__Internal*)__Instance)->ofs_y = value;
            }
        }

        public byte Opa
        {
            get
            {
                return ((__Internal*)__Instance)->opa;
            }

            set
            {
                ((__Internal*)__Instance)->opa = value;
            }
        }

        public byte BidiDir
        {
            get
            {
                return ((__Internal*)__Instance)->bidi_dir;
            }

            set
            {
                ((__Internal*)__Instance)->bidi_dir = value;
            }
        }

        public byte Align
        {
            get
            {
                return ((__Internal*)__Instance)->align;
            }

            set
            {
                ((__Internal*)__Instance)->align = value;
            }
        }

        public byte Flag
        {
            get
            {
                return ((__Internal*)__Instance)->flag;
            }

            set
            {
                ((__Internal*)__Instance)->flag = value;
            }
        }

        public byte Decor
        {
            get
            {
                return ((__Internal*)__Instance)->decor;
            }

            set
            {
                ((__Internal*)__Instance)->decor = value;
            }
        }

        public byte BlendMode
        {
            get
            {
                return ((__Internal*)__Instance)->blend_mode;
            }

            set
            {
                ((__Internal*)__Instance)->blend_mode = value;
            }
        }

        /// <summary>
        /// <para>&lt;1: malloc buffer and copy `text` there.</para>
        /// <para>0: `text` is const and it's pointer will be valid during rendering.</para>
        /// </summary>
        public byte TextLocal
        {
            get
            {
                return ((__Internal*)__Instance)->text_local;
            }

            set
            {
                ((__Internal*)__Instance)->text_local = value;
            }
        }

        public global::lvgl.LvDrawLabelHintT Hint
        {
            get
            {
                var __result0 = global::lvgl.LvDrawLabelHintT.__GetOrCreateInstance(((__Internal*)__Instance)->hint, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->hint = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class LvDrawGlyphDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal __IntPtr glyph_data;
            internal byte format;
            internal __IntPtr letter_coords;
            internal __IntPtr bg_coords;
            internal __IntPtr g;
            internal global::lvgl.LvColorT.__Internal color;
            internal byte opa;
            internal __IntPtr _draw_buf;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_glyph_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawGlyphDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawGlyphDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawGlyphDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawGlyphDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawGlyphDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawGlyphDscT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawGlyphDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawGlyphDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawGlyphDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawGlyphDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawGlyphDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawGlyphDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawGlyphDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawGlyphDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawGlyphDscT(global::lvgl.LvDrawGlyphDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawGlyphDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawGlyphDscT.__Internal*) __Instance) = *((global::lvgl.LvDrawGlyphDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr GlyphData
        {
            get
            {
                return ((__Internal*)__Instance)->glyph_data;
            }

            set
            {
                ((__Internal*)__Instance)->glyph_data = (__IntPtr) value;
            }
        }

        public byte Format
        {
            get
            {
                return ((__Internal*)__Instance)->format;
            }

            set
            {
                ((__Internal*)__Instance)->format = value;
            }
        }

        public global::lvgl.LvAreaT LetterCoords
        {
            get
            {
                var __result0 = global::lvgl.LvAreaT.__GetOrCreateInstance(((__Internal*)__Instance)->letter_coords, false);
                return __result0;
            }
        }

        public global::lvgl.LvAreaT BgCoords
        {
            get
            {
                var __result0 = global::lvgl.LvAreaT.__GetOrCreateInstance(((__Internal*)__Instance)->bg_coords, false);
                return __result0;
            }
        }

        public global::lvgl.LvFontGlyphDscT G
        {
            get
            {
                var __result0 = global::lvgl.LvFontGlyphDscT.__GetOrCreateInstance(((__Internal*)__Instance)->g, false);
                return __result0;
            }
        }

        public global::lvgl.LvColorT Color
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public byte Opa
        {
            get
            {
                return ((__Internal*)__Instance)->opa;
            }

            set
            {
                ((__Internal*)__Instance)->opa = value;
            }
        }

        public global::lvgl.LvDrawBufT DrawBuf
        {
            get
            {
                var __result0 = global::lvgl.LvDrawBufT.__GetOrCreateInstance(((__Internal*)__Instance)->_draw_buf, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_draw_buf = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class lv_draw_label
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_label_dsc_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawLabelDscInit(__IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_task_get_label_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawTaskGetLabelDsc(__IntPtr task);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_glyph_dsc_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawGlyphDscInit(__IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_label", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawLabel(__IntPtr layer, __IntPtr dsc, __IntPtr coords);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_character", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawCharacter(__IntPtr layer, __IntPtr dsc, __IntPtr point, uint unicode_letter);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_label_iterate_characters", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawLabelIterateCharacters(__IntPtr draw_unit, __IntPtr dsc, __IntPtr coords, __IntPtr cb);
        }

        /// <summary>Initialize a label draw descriptor</summary>
        /// <param name="dsc">pointer to a draw descriptor</param>
        public static void LvDrawLabelDscInit(global::lvgl.LvDrawLabelDscT dsc)
        {
            var __arg0 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvDrawLabelDscInit(__arg0);
        }

        /// <summary>Try to get a label draw descriptor from a draw task.</summary>
        /// <param name="task">draw task</param>
        /// <returns>the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_LABEL</returns>
        public static global::lvgl.LvDrawLabelDscT LvDrawTaskGetLabelDsc(global::lvgl.LvDrawTaskT task)
        {
            var __arg0 = task is null ? __IntPtr.Zero : task.__Instance;
            var ___ret = __Internal.LvDrawTaskGetLabelDsc(__arg0);
            var __result0 = global::lvgl.LvDrawLabelDscT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Initialize a glyph draw descriptor.</para>
        /// <para>Used internally.</para>
        /// </summary>
        /// <param name="dsc">pointer to a draw descriptor</param>
        public static void LvDrawGlyphDscInit(global::lvgl.LvDrawGlyphDscT dsc)
        {
            var __arg0 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvDrawGlyphDscInit(__arg0);
        }

        /// <summary>Crate a draw task to render a text</summary>
        /// <param name="layer">pointer to a layer</param>
        /// <param name="dsc">pointer to draw descriptor</param>
        /// <param name="coords">coordinates of the character</param>
        public static void LvDrawLabel(global::lvgl.LvLayerT layer, global::lvgl.LvDrawLabelDscT dsc, global::lvgl.LvAreaT coords)
        {
            var __arg0 = layer is null ? __IntPtr.Zero : layer.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var __arg2 = coords is null ? __IntPtr.Zero : coords.__Instance;
            __Internal.LvDrawLabel(__arg0, __arg1, __arg2);
        }

        /// <summary>Crate a draw task to render a single character</summary>
        /// <param name="layer">pointer to a layer</param>
        /// <param name="dsc">pointer to draw descriptor</param>
        /// <param name="point">position of the label</param>
        /// <param name="unicode_letter">the letter to draw</param>
        public static void LvDrawCharacter(global::lvgl.LvLayerT layer, global::lvgl.LvDrawLabelDscT dsc, global::lvgl.LvPointT point, uint unicode_letter)
        {
            var __arg0 = layer is null ? __IntPtr.Zero : layer.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var __arg2 = point is null ? __IntPtr.Zero : point.__Instance;
            __Internal.LvDrawCharacter(__arg0, __arg1, __arg2, unicode_letter);
        }

        /// <summary>
        /// <para>Should be used during rendering the characters to get the position and other</para>
        /// <para>parameters of the characters</para>
        /// </summary>
        /// <param name="draw_unit">pointer to a draw unit</param>
        /// <param name="dsc">pointer to draw descriptor</param>
        /// <param name="coords">coordinates of the label</param>
        /// <param name="cb">a callback to call to draw each glyphs one by one</param>
        public static void LvDrawLabelIterateCharacters(global::lvgl.LvDrawUnitT draw_unit, global::lvgl.LvDrawLabelDscT dsc, global::lvgl.LvAreaT coords, global::lvgl.LvDrawGlyphCbT cb)
        {
            var __arg0 = draw_unit is null ? __IntPtr.Zero : draw_unit.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var __arg2 = coords is null ? __IntPtr.Zero : coords.__Instance;
            var __arg3 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            __Internal.LvDrawLabelIterateCharacters(__arg0, __arg1, __arg2, __arg3);
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>PErform the actual rendering of a decoded image</summary>
    /// <param name="draw_unit">pointer to a draw unit</param>
    /// <param name="draw_dsc">the draw descriptor of the image</param>
    /// <param name="decoder_dsc">pointer to the decoded image's descriptor</param>
    /// <param name="sup">supplementary data</param>
    /// <param name="img_coords">the absolute coordinates of the image</param>
    /// <param name="clipped_img_area">the absolute clip coordinates</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvDrawImageCoreCb(__IntPtr draw_unit, __IntPtr draw_dsc, __IntPtr decoder_dsc, __IntPtr sup, __IntPtr img_coords, __IntPtr clipped_img_area);

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvDrawImageSupT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal global::lvgl.LvColorT.__Internal alpha_color;
            internal __IntPtr palette;
            internal uint palette_size;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_image_sup_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawImageSupT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawImageSupT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawImageSupT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawImageSupT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawImageSupT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawImageSupT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawImageSupT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawImageSupT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawImageSupT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawImageSupT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawImageSupT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawImageSupT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawImageSupT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawImageSupT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawImageSupT(global::lvgl.LvDrawImageSupT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawImageSupT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawImageSupT.__Internal*) __Instance) = *((global::lvgl.LvDrawImageSupT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvColorT AlphaColor
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->alpha_color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->alpha_color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvColor32T Palette
        {
            get
            {
                var __result0 = global::lvgl.LvColor32T.__GetOrCreateInstance(((__Internal*)__Instance)->palette, false);
                return __result0;
            }
        }

        public uint PaletteSize
        {
            get
            {
                return ((__Internal*)__Instance)->palette_size;
            }

            set
            {
                ((__Internal*)__Instance)->palette_size = value;
            }
        }
    }

    public unsafe partial class LvDrawImageDscT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 136)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvDrawDscBaseT.__Internal @base;

            [FieldOffset(48)]
            internal __IntPtr src;

            [FieldOffset(56)]
            internal global::lvgl.LvImageHeaderT.__Internal header;

            [FieldOffset(68)]
            internal int rotation;

            [FieldOffset(72)]
            internal int scale_x;

            [FieldOffset(76)]
            internal int scale_y;

            [FieldOffset(80)]
            internal int skew_x;

            [FieldOffset(84)]
            internal int skew_y;

            [FieldOffset(88)]
            internal global::lvgl.LvPointT.__Internal pivot;

            [FieldOffset(96)]
            internal global::lvgl.LvColorT.__Internal recolor;

            [FieldOffset(99)]
            internal byte recolor_opa;

            [FieldOffset(100)]
            internal byte opa;

            [FieldOffset(101)]
            internal byte blend_mode;

            [FieldOffset(102)]
            internal ushort antialias;

            [FieldOffset(102)]
            internal ushort tile;

            [FieldOffset(104)]
            internal __IntPtr sup;

            [FieldOffset(112)]
            internal global::lvgl.LvAreaT.__Internal image_area;

            [FieldOffset(128)]
            internal __IntPtr bitmap_mask_src;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_draw_image_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawImageDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawImageDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawImageDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawImageDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawImageDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawImageDscT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawImageDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawImageDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawImageDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawImageDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawImageDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawImageDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawImageDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawImageDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawImageDscT(global::lvgl.LvDrawImageDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawImageDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawImageDscT.__Internal*) __Instance) = *((global::lvgl.LvDrawImageDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawDscBaseT Base
        {
            get
            {
                return global::lvgl.LvDrawDscBaseT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->@base));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->@base = *(global::lvgl.LvDrawDscBaseT.__Internal*) value.__Instance;
            }
        }

        public __IntPtr Src
        {
            get
            {
                return ((__Internal*)__Instance)->src;
            }
        }

        public global::lvgl.LvImageHeaderT Header
        {
            get
            {
                return global::lvgl.LvImageHeaderT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->header));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->header = *(global::lvgl.LvImageHeaderT.__Internal*) value.__Instance;
            }
        }

        public int Rotation
        {
            get
            {
                return ((__Internal*)__Instance)->rotation;
            }

            set
            {
                ((__Internal*)__Instance)->rotation = value;
            }
        }

        public int ScaleX
        {
            get
            {
                return ((__Internal*)__Instance)->scale_x;
            }

            set
            {
                ((__Internal*)__Instance)->scale_x = value;
            }
        }

        public int ScaleY
        {
            get
            {
                return ((__Internal*)__Instance)->scale_y;
            }

            set
            {
                ((__Internal*)__Instance)->scale_y = value;
            }
        }

        public int SkewX
        {
            get
            {
                return ((__Internal*)__Instance)->skew_x;
            }

            set
            {
                ((__Internal*)__Instance)->skew_x = value;
            }
        }

        public int SkewY
        {
            get
            {
                return ((__Internal*)__Instance)->skew_y;
            }

            set
            {
                ((__Internal*)__Instance)->skew_y = value;
            }
        }

        public global::lvgl.LvPointT Pivot
        {
            get
            {
                return global::lvgl.LvPointT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->pivot));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->pivot = *(global::lvgl.LvPointT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvColorT Recolor
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->recolor));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->recolor = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public byte RecolorOpa
        {
            get
            {
                return ((__Internal*)__Instance)->recolor_opa;
            }

            set
            {
                ((__Internal*)__Instance)->recolor_opa = value;
            }
        }

        public byte Opa
        {
            get
            {
                return ((__Internal*)__Instance)->opa;
            }

            set
            {
                ((__Internal*)__Instance)->opa = value;
            }
        }

        public byte BlendMode
        {
            get
            {
                return ((__Internal*)__Instance)->blend_mode;
            }

            set
            {
                ((__Internal*)__Instance)->blend_mode = value;
            }
        }

        public ushort Antialias
        {
            get
            {
                return ((__Internal*)__Instance)->antialias;
            }

            set
            {
                ((__Internal*)__Instance)->antialias = value;
            }
        }

        public ushort Tile
        {
            get
            {
                return ((__Internal*)__Instance)->tile;
            }

            set
            {
                ((__Internal*)__Instance)->tile = value;
            }
        }

        public global::lvgl.LvDrawImageSupT Sup
        {
            get
            {
                var __result0 = global::lvgl.LvDrawImageSupT.__GetOrCreateInstance(((__Internal*)__Instance)->sup, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->sup = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>
        /// <para>Used to indicate the entire original, non-clipped area where the image is to be drawn.</para>
        /// <para>This is important for:</para>
        /// <para>1. Layer rendering, where it might happen that only a smaller area of the layer is rendered.</para>
        /// <para>2. Tiled images, where the target draw area is larger than the image to be tiled.</para>
        /// </summary>
        public global::lvgl.LvAreaT ImageArea
        {
            get
            {
                return global::lvgl.LvAreaT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->image_area));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->image_area = *(global::lvgl.LvAreaT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvImageDscT BitmapMaskSrc
        {
            get
            {
                var __result0 = global::lvgl.LvImageDscT.__GetOrCreateInstance(((__Internal*)__Instance)->bitmap_mask_src, false);
                return __result0;
            }
        }
    }

    public unsafe partial class lv_draw_image
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_image_dsc_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawImageDscInit(__IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_task_get_image_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawTaskGetImageDsc(__IntPtr task);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_image", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawImage(__IntPtr layer, __IntPtr dsc, __IntPtr coords);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_layer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawLayer(__IntPtr layer, __IntPtr dsc, __IntPtr coords);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_src_get_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvImageSrcGetType(__IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_draw_image_normal_helper", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawImageNormalHelper(__IntPtr draw_unit, __IntPtr draw_dsc, __IntPtr coords, __IntPtr draw_core_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_draw_image_tiled_helper", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawImageTiledHelper(__IntPtr draw_unit, __IntPtr draw_dsc, __IntPtr coords, __IntPtr draw_core_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_image_buf_get_transformed_area", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageBufGetTransformedArea(__IntPtr res, int w, int h, int angle, ushort scale_x, ushort scale_y, __IntPtr pivot);
        }

        /// <summary>Initialize an image draw descriptor.</summary>
        /// <param name="dsc">pointer to a draw descriptor</param>
        public static void LvDrawImageDscInit(global::lvgl.LvDrawImageDscT dsc)
        {
            var __arg0 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvDrawImageDscInit(__arg0);
        }

        /// <summary>Try to get an image draw descriptor from a draw task.</summary>
        /// <param name="task">draw task</param>
        /// <returns>the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_IMAGE</returns>
        public static global::lvgl.LvDrawImageDscT LvDrawTaskGetImageDsc(global::lvgl.LvDrawTaskT task)
        {
            var __arg0 = task is null ? __IntPtr.Zero : task.__Instance;
            var ___ret = __Internal.LvDrawTaskGetImageDsc(__arg0);
            var __result0 = global::lvgl.LvDrawImageDscT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create an image draw task</summary>
        /// <param name="layer">pointer to a layer</param>
        /// <param name="dsc">pointer to an initialized draw descriptor</param>
        /// <param name="coords">the coordinates of the image</param>
        /// <remarks>
        /// <para>`coords` can be small than the real image area</para>
        /// <para>(if only a part of the image is rendered)</para>
        /// <para>or can be larger (in case of tiled images).   .</para>
        /// </remarks>
        public static void LvDrawImage(global::lvgl.LvLayerT layer, global::lvgl.LvDrawImageDscT dsc, global::lvgl.LvAreaT coords)
        {
            var __arg0 = layer is null ? __IntPtr.Zero : layer.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var __arg2 = coords is null ? __IntPtr.Zero : coords.__Instance;
            __Internal.LvDrawImage(__arg0, __arg1, __arg2);
        }

        /// <summary>Create a draw task to blend a layer to an other layer</summary>
        /// <param name="layer">pointer to a layer</param>
        /// <param name="dsc">pointer to an initialized draw descriptor</param>
        /// <param name="coords">the coordinates of the layer.</param>
        /// <remarks>
        /// <para>`coords` can be small than the total widget area from which the layer is created</para>
        /// <para>(if only a part of the widget was rendered to a layer)</para>
        /// </remarks>
        public static void LvDrawLayer(global::lvgl.LvLayerT layer, global::lvgl.LvDrawImageDscT dsc, global::lvgl.LvAreaT coords)
        {
            var __arg0 = layer is null ? __IntPtr.Zero : layer.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var __arg2 = coords is null ? __IntPtr.Zero : coords.__Instance;
            __Internal.LvDrawLayer(__arg0, __arg1, __arg2);
        }

        /// <summary>Get the type of an image source</summary>
        /// <param name="src">
        /// <para>pointer to an image source:</para>
        /// <para>- pointer to an 'lv_image_t' variable (image stored internally and compiled into the code)</para>
        /// <para>- a path to a file (e.g. &quot;S:/folder/image.bin&quot;)</para>
        /// <para>- or a symbol (e.g. LV_SYMBOL_CLOSE)</para>
        /// </param>
        /// <returns>type of the image source LV_IMAGE_SRC_VARIABLE/FILE/SYMBOL/UNKNOWN</returns>
        public static byte LvImageSrcGetType(__IntPtr src)
        {
            var ___ret = __Internal.LvImageSrcGetType(src);
            return ___ret;
        }

        /// <summary>
        /// <para>Can be used by draw units to handle the decoding and</para>
        /// <para>prepare everything for the actual image rendering</para>
        /// </summary>
        /// <param name="draw_unit">pointer to a draw unit</param>
        /// <param name="draw_dsc">the draw descriptor of the image</param>
        /// <param name="coords">the absolute coordinates of the image</param>
        /// <param name="draw_core_cb">a callback to perform the actual rendering</param>
        public static void LvDrawImageNormalHelper(global::lvgl.LvDrawUnitT draw_unit, global::lvgl.LvDrawImageDscT draw_dsc, global::lvgl.LvAreaT coords, global::lvgl.LvDrawImageCoreCb draw_core_cb)
        {
            var __arg0 = draw_unit is null ? __IntPtr.Zero : draw_unit.__Instance;
            var __arg1 = draw_dsc is null ? __IntPtr.Zero : draw_dsc.__Instance;
            var __arg2 = coords is null ? __IntPtr.Zero : coords.__Instance;
            var __arg3 = draw_core_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(draw_core_cb);
            __Internal.LvDrawImageNormalHelper(__arg0, __arg1, __arg2, __arg3);
        }

        /// <summary>
        /// <para>Can be used by draw units for TILED images to handle the decoding and</para>
        /// <para>prepare everything for the actual image rendering</para>
        /// </summary>
        /// <param name="draw_unit">pointer to a draw unit</param>
        /// <param name="draw_dsc">the draw descriptor of the image</param>
        /// <param name="coords">the absolute coordinates of the image</param>
        /// <param name="draw_core_cb">a callback to perform the actual rendering</param>
        public static void LvDrawImageTiledHelper(global::lvgl.LvDrawUnitT draw_unit, global::lvgl.LvDrawImageDscT draw_dsc, global::lvgl.LvAreaT coords, global::lvgl.LvDrawImageCoreCb draw_core_cb)
        {
            var __arg0 = draw_unit is null ? __IntPtr.Zero : draw_unit.__Instance;
            var __arg1 = draw_dsc is null ? __IntPtr.Zero : draw_dsc.__Instance;
            var __arg2 = coords is null ? __IntPtr.Zero : coords.__Instance;
            var __arg3 = draw_core_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(draw_core_cb);
            __Internal.LvDrawImageTiledHelper(__arg0, __arg1, __arg2, __arg3);
        }

        /// <summary>Get the area of a rectangle if its rotated and scaled</summary>
        /// <param name="res">store the coordinates here</param>
        /// <param name="w">width of the rectangle to transform</param>
        /// <param name="h">height of the rectangle to transform</param>
        /// <param name="angle">angle of rotation</param>
        /// <param name="scale_x">zoom in x direction, (256 no zoom)</param>
        /// <param name="scale_y">zoom in y direction, (256 no zoom)</param>
        /// <param name="pivot">x,y pivot coordinates of rotation</param>
        public static void LvImageBufGetTransformedArea(global::lvgl.LvAreaT res, int w, int h, int angle, ushort scale_x, ushort scale_y, global::lvgl.LvPointT pivot)
        {
            var __arg0 = res is null ? __IntPtr.Zero : res.__Instance;
            var __arg6 = pivot is null ? __IntPtr.Zero : pivot.__Instance;
            __Internal.LvImageBufGetTransformedArea(__arg0, w, h, angle, scale_x, scale_y, __arg6);
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvDrawArcDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 96)]
        public partial struct __Internal
        {
            internal global::lvgl.LvDrawDscBaseT.__Internal @base;
            internal global::lvgl.LvColorT.__Internal color;
            internal int width;
            internal int start_angle;
            internal int end_angle;
            internal global::lvgl.LvPointT.__Internal center;
            internal ushort radius;
            internal __IntPtr img_src;
            internal byte opa;
            internal byte rounded;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_arc_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawArcDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawArcDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawArcDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawArcDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawArcDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawArcDscT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawArcDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawArcDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawArcDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawArcDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawArcDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawArcDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawArcDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawArcDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawArcDscT(global::lvgl.LvDrawArcDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawArcDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawArcDscT.__Internal*) __Instance) = *((global::lvgl.LvDrawArcDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawDscBaseT Base
        {
            get
            {
                return global::lvgl.LvDrawDscBaseT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->@base));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->@base = *(global::lvgl.LvDrawDscBaseT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvColorT Color
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public int Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public int StartAngle
        {
            get
            {
                return ((__Internal*)__Instance)->start_angle;
            }

            set
            {
                ((__Internal*)__Instance)->start_angle = value;
            }
        }

        public int EndAngle
        {
            get
            {
                return ((__Internal*)__Instance)->end_angle;
            }

            set
            {
                ((__Internal*)__Instance)->end_angle = value;
            }
        }

        public global::lvgl.LvPointT Center
        {
            get
            {
                return global::lvgl.LvPointT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->center));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->center = *(global::lvgl.LvPointT.__Internal*) value.__Instance;
            }
        }

        public ushort Radius
        {
            get
            {
                return ((__Internal*)__Instance)->radius;
            }

            set
            {
                ((__Internal*)__Instance)->radius = value;
            }
        }

        public __IntPtr ImgSrc
        {
            get
            {
                return ((__Internal*)__Instance)->img_src;
            }
        }

        public byte Opa
        {
            get
            {
                return ((__Internal*)__Instance)->opa;
            }

            set
            {
                ((__Internal*)__Instance)->opa = value;
            }
        }

        public byte Rounded
        {
            get
            {
                return ((__Internal*)__Instance)->rounded;
            }

            set
            {
                ((__Internal*)__Instance)->rounded = value;
            }
        }
    }

    public unsafe partial class lv_draw_arc
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_arc_dsc_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawArcDscInit(__IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_task_get_arc_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawTaskGetArcDsc(__IntPtr task);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_arc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawArc(__IntPtr layer, __IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_arc_get_area", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawArcGetArea(int x, int y, ushort radius, int start_angle, int end_angle, int w, bool rounded, __IntPtr area);
        }

        /// <summary>Initialize an arc draw descriptor.</summary>
        /// <param name="dsc">pointer to a draw descriptor</param>
        public static void LvDrawArcDscInit(global::lvgl.LvDrawArcDscT dsc)
        {
            var __arg0 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvDrawArcDscInit(__arg0);
        }

        /// <summary>Try to get an arc draw descriptor from a draw task.</summary>
        /// <param name="task">draw task</param>
        /// <returns>the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_ARC</returns>
        public static global::lvgl.LvDrawArcDscT LvDrawTaskGetArcDsc(global::lvgl.LvDrawTaskT task)
        {
            var __arg0 = task is null ? __IntPtr.Zero : task.__Instance;
            var ___ret = __Internal.LvDrawTaskGetArcDsc(__arg0);
            var __result0 = global::lvgl.LvDrawArcDscT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create an arc draw task.</summary>
        /// <param name="layer">pointer to a layer</param>
        /// <param name="dsc">pointer to an initialized draw descriptor variable</param>
        public static void LvDrawArc(global::lvgl.LvLayerT layer, global::lvgl.LvDrawArcDscT dsc)
        {
            var __arg0 = layer is null ? __IntPtr.Zero : layer.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvDrawArc(__arg0, __arg1);
        }

        /// <summary>Get an area the should be invalidated when the arcs angle changed between start_angle and end_ange</summary>
        /// <param name="x">the x coordinate of the center of the arc</param>
        /// <param name="y">the y coordinate of the center of the arc</param>
        /// <param name="radius">the radius of the arc</param>
        /// <param name="start_angle">the start angle of the arc (0 deg on the bottom, 90 deg on the right)</param>
        /// <param name="end_angle">the end angle of the arc</param>
        /// <param name="w">width of the arc</param>
        /// <param name="rounded">true: the arc is rounded</param>
        /// <param name="area">store the area to invalidate here</param>
        public static void LvDrawArcGetArea(int x, int y, ushort radius, int start_angle, int end_angle, int w, bool rounded, global::lvgl.LvAreaT area)
        {
            var __arg7 = area is null ? __IntPtr.Zero : area.__Instance;
            __Internal.LvDrawArcGetArea(x, y, radius, start_angle, end_angle, w, rounded, __arg7);
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvDrawLineDscT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 88)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvDrawDscBaseT.__Internal @base;

            [FieldOffset(48)]
            internal global::lvgl.LvPointPreciseT.__Internal p1;

            [FieldOffset(56)]
            internal global::lvgl.LvPointPreciseT.__Internal p2;

            [FieldOffset(64)]
            internal global::lvgl.LvColorT.__Internal color;

            [FieldOffset(68)]
            internal int width;

            [FieldOffset(72)]
            internal int dash_width;

            [FieldOffset(76)]
            internal int dash_gap;

            [FieldOffset(80)]
            internal byte opa;

            [FieldOffset(81)]
            internal byte blend_mode;

            [FieldOffset(81)]
            internal byte round_start;

            [FieldOffset(81)]
            internal byte round_end;

            [FieldOffset(81)]
            internal byte raw_end;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_line_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawLineDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawLineDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawLineDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawLineDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawLineDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawLineDscT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawLineDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawLineDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawLineDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawLineDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawLineDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawLineDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawLineDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawLineDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawLineDscT(global::lvgl.LvDrawLineDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawLineDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawLineDscT.__Internal*) __Instance) = *((global::lvgl.LvDrawLineDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawDscBaseT Base
        {
            get
            {
                return global::lvgl.LvDrawDscBaseT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->@base));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->@base = *(global::lvgl.LvDrawDscBaseT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvPointPreciseT P1
        {
            get
            {
                return global::lvgl.LvPointPreciseT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->p1));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->p1 = *(global::lvgl.LvPointPreciseT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvPointPreciseT P2
        {
            get
            {
                return global::lvgl.LvPointPreciseT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->p2));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->p2 = *(global::lvgl.LvPointPreciseT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvColorT Color
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public int Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public int DashWidth
        {
            get
            {
                return ((__Internal*)__Instance)->dash_width;
            }

            set
            {
                ((__Internal*)__Instance)->dash_width = value;
            }
        }

        public int DashGap
        {
            get
            {
                return ((__Internal*)__Instance)->dash_gap;
            }

            set
            {
                ((__Internal*)__Instance)->dash_gap = value;
            }
        }

        public byte Opa
        {
            get
            {
                return ((__Internal*)__Instance)->opa;
            }

            set
            {
                ((__Internal*)__Instance)->opa = value;
            }
        }

        public byte BlendMode
        {
            get
            {
                return ((__Internal*)__Instance)->blend_mode;
            }

            set
            {
                ((__Internal*)__Instance)->blend_mode = value;
            }
        }

        public byte RoundStart
        {
            get
            {
                return ((__Internal*)__Instance)->round_start;
            }

            set
            {
                ((__Internal*)__Instance)->round_start = value;
            }
        }

        public byte RoundEnd
        {
            get
            {
                return ((__Internal*)__Instance)->round_end;
            }

            set
            {
                ((__Internal*)__Instance)->round_end = value;
            }
        }

        public byte RawEnd
        {
            get
            {
                return ((__Internal*)__Instance)->raw_end;
            }

            set
            {
                ((__Internal*)__Instance)->raw_end = value;
            }
        }
    }

    public unsafe partial class lv_draw_line
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_line_dsc_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawLineDscInit(__IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_task_get_line_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawTaskGetLineDsc(__IntPtr task);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_line", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawLine(__IntPtr layer, __IntPtr dsc);
        }

        /// <summary>Initialize a line draw descriptor</summary>
        /// <param name="dsc">pointer to a draw descriptor</param>
        public static void LvDrawLineDscInit(global::lvgl.LvDrawLineDscT dsc)
        {
            var __arg0 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvDrawLineDscInit(__arg0);
        }

        /// <summary>Try to get a line draw descriptor from a draw task.</summary>
        /// <param name="task">draw task</param>
        /// <returns>the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_LINE</returns>
        public static global::lvgl.LvDrawLineDscT LvDrawTaskGetLineDsc(global::lvgl.LvDrawTaskT task)
        {
            var __arg0 = task is null ? __IntPtr.Zero : task.__Instance;
            var ___ret = __Internal.LvDrawTaskGetLineDsc(__arg0);
            var __result0 = global::lvgl.LvDrawLineDscT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create a line draw task</summary>
        /// <param name="layer">pointer to a layer</param>
        /// <param name="dsc">pointer to an initialized `lv_draw_line_dsc_t` variable</param>
        public static void LvDrawLine(global::lvgl.LvLayerT layer, global::lvgl.LvDrawLineDscT dsc)
        {
            var __arg0 = layer is null ? __IntPtr.Zero : layer.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvDrawLine(__arg0, __arg1);
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvDrawTriangleDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 88)]
        public partial struct __Internal
        {
            internal global::lvgl.LvDrawDscBaseT.__Internal @base;
            internal byte bg_opa;
            internal global::lvgl.LvColorT.__Internal bg_color;
            internal global::lvgl.LvGradDscT.__Internal bg_grad;
            internal fixed byte p[24];

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_triangle_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawTriangleDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawTriangleDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawTriangleDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawTriangleDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawTriangleDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawTriangleDscT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawTriangleDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawTriangleDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawTriangleDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawTriangleDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawTriangleDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawTriangleDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawTriangleDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawTriangleDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawTriangleDscT(global::lvgl.LvDrawTriangleDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawTriangleDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawTriangleDscT.__Internal*) __Instance) = *((global::lvgl.LvDrawTriangleDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawDscBaseT Base
        {
            get
            {
                return global::lvgl.LvDrawDscBaseT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->@base));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->@base = *(global::lvgl.LvDrawDscBaseT.__Internal*) value.__Instance;
            }
        }

        public byte BgOpa
        {
            get
            {
                return ((__Internal*)__Instance)->bg_opa;
            }

            set
            {
                ((__Internal*)__Instance)->bg_opa = value;
            }
        }

        public global::lvgl.LvColorT BgColor
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->bg_color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->bg_color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvGradDscT BgGrad
        {
            get
            {
                return global::lvgl.LvGradDscT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->bg_grad));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->bg_grad = *(global::lvgl.LvGradDscT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvPointPreciseT[] P
        {
            get
            {
                global::lvgl.LvPointPreciseT[] __value = null;
                if (((__Internal*)__Instance)->p != null)
                {
                    __value = new global::lvgl.LvPointPreciseT[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = global::lvgl.LvPointPreciseT.__GetOrCreateInstance((IntPtr)((global::lvgl.LvPointPreciseT.__Internal*)&(((__Internal*)__Instance)->p[i * sizeof(global::lvgl.LvPointPreciseT.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 3)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 3; i++)
                        *(global::lvgl.LvPointPreciseT.__Internal*) &((__Internal*)__Instance)->p[i * sizeof(global::lvgl.LvPointPreciseT.__Internal)] = *(global::lvgl.LvPointPreciseT.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class lv_draw_triangle
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_triangle_dsc_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawTriangleDscInit(__IntPtr draw_dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_task_get_triangle_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawTaskGetTriangleDsc(__IntPtr task);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_triangle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawTriangle(__IntPtr layer, __IntPtr draw_dsc);
        }

        /// <summary>Initialize a triangle draw descriptor</summary>
        /// <param name="dsc">pointer to a draw descriptor</param>
        public static void LvDrawTriangleDscInit(global::lvgl.LvDrawTriangleDscT draw_dsc)
        {
            var __arg0 = draw_dsc is null ? __IntPtr.Zero : draw_dsc.__Instance;
            __Internal.LvDrawTriangleDscInit(__arg0);
        }

        /// <summary>Try to get a triangle draw descriptor from a draw task.</summary>
        /// <param name="task">draw task</param>
        /// <returns>the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_TRIANGLE</returns>
        public static global::lvgl.LvDrawTriangleDscT LvDrawTaskGetTriangleDsc(global::lvgl.LvDrawTaskT task)
        {
            var __arg0 = task is null ? __IntPtr.Zero : task.__Instance;
            var ___ret = __Internal.LvDrawTaskGetTriangleDsc(__arg0);
            var __result0 = global::lvgl.LvDrawTriangleDscT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create a triangle draw task</summary>
        /// <param name="layer">pointer to a layer</param>
        /// <param name="dsc">pointer to an initialized `lv_draw_triangle_dsc_t` variable</param>
        public static void LvDrawTriangle(global::lvgl.LvLayerT layer, global::lvgl.LvDrawTriangleDscT draw_dsc)
        {
            var __arg0 = layer is null ? __IntPtr.Zero : layer.__Instance;
            var __arg1 = draw_dsc is null ? __IntPtr.Zero : draw_dsc.__Instance;
            __Internal.LvDrawTriangle(__arg0, __arg1);
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvDrawMaskRectDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal global::lvgl.LvDrawDscBaseT.__Internal @base;
            internal global::lvgl.LvAreaT.__Internal area;
            internal int radius;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_mask_rect_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawMaskRectDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawMaskRectDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawMaskRectDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawMaskRectDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawMaskRectDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawMaskRectDscT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawMaskRectDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawMaskRectDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawMaskRectDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawMaskRectDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawMaskRectDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawMaskRectDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawMaskRectDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawMaskRectDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawMaskRectDscT(global::lvgl.LvDrawMaskRectDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawMaskRectDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawMaskRectDscT.__Internal*) __Instance) = *((global::lvgl.LvDrawMaskRectDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawDscBaseT Base
        {
            get
            {
                return global::lvgl.LvDrawDscBaseT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->@base));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->@base = *(global::lvgl.LvDrawDscBaseT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvAreaT Area
        {
            get
            {
                return global::lvgl.LvAreaT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->area));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->area = *(global::lvgl.LvAreaT.__Internal*) value.__Instance;
            }
        }

        public int Radius
        {
            get
            {
                return ((__Internal*)__Instance)->radius;
            }

            set
            {
                ((__Internal*)__Instance)->radius = value;
            }
        }
    }

    public unsafe partial class lv_draw_mask
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_mask_rect_dsc_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawMaskRectDscInit(__IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_task_get_mask_rect_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDrawTaskGetMaskRectDsc(__IntPtr task);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_mask_rect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawMaskRect(__IntPtr layer, __IntPtr dsc);
        }

        /// <summary>Initialize a rectangle mask draw descriptor.</summary>
        /// <param name="dsc">pointer to a draw descriptor</param>
        public static void LvDrawMaskRectDscInit(global::lvgl.LvDrawMaskRectDscT dsc)
        {
            var __arg0 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvDrawMaskRectDscInit(__arg0);
        }

        /// <summary>Try to get a rectangle mask draw descriptor from a draw task.</summary>
        /// <param name="task">draw task</param>
        /// <returns>the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_MASK_RECTANGLE</returns>
        public static global::lvgl.LvDrawMaskRectDscT LvDrawTaskGetMaskRectDsc(global::lvgl.LvDrawTaskT task)
        {
            var __arg0 = task is null ? __IntPtr.Zero : task.__Instance;
            var ___ret = __Internal.LvDrawTaskGetMaskRectDsc(__arg0);
            var __result0 = global::lvgl.LvDrawMaskRectDscT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create a draw task to mask a rectangle from the buffer</summary>
        /// <param name="layer">pointer to a layer</param>
        /// <param name="dsc">pointer to a draw descriptor</param>
        public static void LvDrawMaskRect(global::lvgl.LvLayerT layer, global::lvgl.LvDrawMaskRectDscT dsc)
        {
            var __arg0 = layer is null ? __IntPtr.Zero : layer.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvDrawMaskRect(__arg0, __arg1);
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public enum LvObjPointTransformFlagT
    {
        /// <summary>No flags</summary>
        LV_OBJ_POINT_TRANSFORM_FLAG_NONE = 0,
        /// <summary>Consider the transformation properties of the parents too</summary>
        LV_OBJ_POINT_TRANSFORM_FLAG_RECURSIVE = 1,
        /// <summary>Execute the inverse of the transformation (-angle and 1/zoom)</summary>
        LV_OBJ_POINT_TRANSFORM_FLAG_INVERSE = 2,
        /// <summary>Both inverse and recursive</summary>
        LV_OBJ_POINT_TRANSFORM_FLAG_INVERSE_RECURSIVE = 3
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class lv_obj_pos
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_pos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetPos(__IntPtr obj, int x, int y);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetX(__IntPtr obj, int x);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetY(__IntPtr obj, int y);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetSize(__IntPtr obj, int w, int h);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_refr_size", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjRefrSize(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetWidth(__IntPtr obj, int w);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetHeight(__IntPtr obj, int h);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_content_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetContentWidth(__IntPtr obj, int w);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_content_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetContentHeight(__IntPtr obj, int h);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_layout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetLayout(__IntPtr obj, uint layout);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_is_layout_positioned", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjIsLayoutPositioned(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_mark_layout_as_dirty", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjMarkLayoutAsDirty(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_update_layout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjUpdateLayout(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetAlign(__IntPtr obj, byte align);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjAlign(__IntPtr obj, byte align, int x_ofs, int y_ofs);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_align_to", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjAlignTo(__IntPtr obj, __IntPtr @base, byte align, int x_ofs, int y_ofs);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_coords", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjGetCoords(__IntPtr obj, __IntPtr coords);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetX(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_x2", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetX2(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetY(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_y2", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetY2(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_x_aligned", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetXAligned(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_y_aligned", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetYAligned(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetWidth(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetHeight(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_content_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetContentWidth(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_content_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetContentHeight(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_content_coords", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjGetContentCoords(__IntPtr obj, __IntPtr area);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_self_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetSelfWidth(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_self_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetSelfHeight(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_refresh_self_size", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjRefreshSelfSize(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_refr_pos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjRefrPos(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_move_to", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjMoveTo(__IntPtr obj, int x, int y);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_move_children_by", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjMoveChildrenBy(__IntPtr obj, int x_diff, int y_diff, bool ignore_floating);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_transform_point", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjTransformPoint(__IntPtr obj, __IntPtr p, global::lvgl.LvObjPointTransformFlagT flags);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_transform_point_array", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjTransformPointArray(__IntPtr obj, global::lvgl.LvPointT.__Internal[] points, ulong count, global::lvgl.LvObjPointTransformFlagT flags);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_transformed_area", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjGetTransformedArea(__IntPtr obj, __IntPtr area, global::lvgl.LvObjPointTransformFlagT flags);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_invalidate_area", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjInvalidateArea(__IntPtr obj, __IntPtr area);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_invalidate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjInvalidate(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_area_is_visible", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjAreaIsVisible(__IntPtr obj, __IntPtr area);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_is_visible", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjIsVisible(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_ext_click_area", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetExtClickArea(__IntPtr obj, int size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_click_area", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjGetClickArea(__IntPtr obj, __IntPtr area);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_hit_test", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjHitTest(__IntPtr obj, __IntPtr point);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_clamp_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvClampWidth(int width, int min_width, int max_width, int ref_width);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_clamp_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvClampHeight(int height, int min_height, int max_height, int ref_height);
        }

        /// <summary>Set the position of an object relative to the set alignment.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="x">new x coordinate</param>
        /// <param name="y">new y coordinate</param>
        /// <remarks>
        /// <para>With default alignment it's the distance from the top left corner</para>
        /// <para>E.g. LV_ALIGN_CENTER alignment it's the offset from the center of the parent</para>
        /// <para>The position is interpreted on the content area of the parent</para>
        /// <para>The values can be set in pixel or in percentage of parent size with `lv_pct(v)`</para>
        /// </remarks>
        public static void LvObjSetPos(global::lvgl.LvObjT obj, int x, int y)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetPos(__arg0, x, y);
        }

        /// <summary>Set the x coordinate of an object</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="x">new x coordinate</param>
        /// <remarks>
        /// <para>With default alignment it's the distance from the top left corner</para>
        /// <para>E.g. LV_ALIGN_CENTER alignment it's the offset from the center of the parent</para>
        /// <para>The position is interpreted on the content area of the parent</para>
        /// <para>The values can be set in pixel or in percentage of parent size with `lv_pct(v)`</para>
        /// </remarks>
        public static void LvObjSetX(global::lvgl.LvObjT obj, int x)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetX(__arg0, x);
        }

        /// <summary>Set the y coordinate of an object</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="y">new y coordinate</param>
        /// <remarks>
        /// <para>With default alignment it's the distance from the top left corner</para>
        /// <para>E.g. LV_ALIGN_CENTER alignment it's the offset from the center of the parent</para>
        /// <para>The position is interpreted on the content area of the parent</para>
        /// <para>The values can be set in pixel or in percentage of parent size with `lv_pct(v)`</para>
        /// </remarks>
        public static void LvObjSetY(global::lvgl.LvObjT obj, int y)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetY(__arg0, y);
        }

        /// <summary>Set the size of an object.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="w">the new width</param>
        /// <param name="h">the new height</param>
        /// <remarks>
        /// <para>possible values are:</para>
        /// <para>pixel               simple set the size accordingly</para>
        /// <para>LV_SIZE_CONTENT     set the size to involve all children in the given direction</para>
        /// <para>lv_pct(x)           to set size in percentage of the parent's content area size (the size without paddings).</para>
        /// <para>x should be in [0..1000]% range</para>
        /// </remarks>
        public static void LvObjSetSize(global::lvgl.LvObjT obj, int w, int h)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetSize(__arg0, w, h);
        }

        /// <summary>Recalculate the size of the object</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>true: the size has been changed</returns>
        public static bool LvObjRefrSize(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjRefrSize(__arg0);
            return ___ret;
        }

        /// <summary>Set the width of an object</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="w">the new width</param>
        /// <remarks>
        /// <para>possible values are:</para>
        /// <para>pixel               simple set the size accordingly</para>
        /// <para>LV_SIZE_CONTENT     set the size to involve all children in the given direction</para>
        /// <para>lv_pct(x)           to set size in percentage of the parent's content area size (the size without paddings).</para>
        /// <para>x should be in [0..1000]% range</para>
        /// </remarks>
        public static void LvObjSetWidth(global::lvgl.LvObjT obj, int w)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetWidth(__arg0, w);
        }

        /// <summary>Set the height of an object</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="h">the new height</param>
        /// <remarks>
        /// <para>possible values are:</para>
        /// <para>pixel               simple set the size accordingly</para>
        /// <para>LV_SIZE_CONTENT     set the size to involve all children in the given direction</para>
        /// <para>lv_pct(x)           to set size in percentage of the parent's content area size (the size without paddings).</para>
        /// <para>x should be in [0..1000]% range</para>
        /// </remarks>
        public static void LvObjSetHeight(global::lvgl.LvObjT obj, int h)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetHeight(__arg0, h);
        }

        /// <summary>Set the width reduced by the left and right padding and the border width.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="w">the width without paddings in pixels</param>
        public static void LvObjSetContentWidth(global::lvgl.LvObjT obj, int w)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetContentWidth(__arg0, w);
        }

        /// <summary>Set the height reduced by the top and bottom padding and the border width.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="h">the height without paddings in pixels</param>
        public static void LvObjSetContentHeight(global::lvgl.LvObjT obj, int h)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetContentHeight(__arg0, h);
        }

        /// <summary>Set a layout for an object</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="layout">pointer to a layout descriptor to set</param>
        public static void LvObjSetLayout(global::lvgl.LvObjT obj, uint layout)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetLayout(__arg0, layout);
        }

        /// <summary>Test whether the and object is positioned by a layout or not</summary>
        /// <param name="obj">pointer to an object to test</param>
        /// <returns>true:    positioned by a layout; false: not positioned by a layout</returns>
        public static bool LvObjIsLayoutPositioned(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjIsLayoutPositioned(__arg0);
            return ___ret;
        }

        /// <summary>Mark the object for layout update.</summary>
        /// <param name="obj">pointer to an object whose children needs to be updated</param>
        public static void LvObjMarkLayoutAsDirty(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjMarkLayoutAsDirty(__arg0);
        }

        /// <summary>Update the layout of an object.</summary>
        /// <param name="obj">pointer to an object whose children needs to be updated</param>
        public static void LvObjUpdateLayout(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjUpdateLayout(__arg0);
        }

        /// <summary>Change the alignment of an object.</summary>
        /// <param name="obj">pointer to an object to align</param>
        /// <param name="align">type of alignment (see 'lv_align_t' enum) `LV_ALIGN_OUT_...` can't be used.</param>
        public static void LvObjSetAlign(global::lvgl.LvObjT obj, byte align)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetAlign(__arg0, align);
        }

        /// <summary>
        /// <para>Change the alignment of an object and set new coordinates.</para>
        /// <para>Equivalent to:</para>
        /// <para>lv_obj_set_align(obj, align);</para>
        /// <para>lv_obj_set_pos(obj, x_ofs, y_ofs);</para>
        /// </summary>
        /// <param name="obj">pointer to an object to align</param>
        /// <param name="align">type of alignment (see 'lv_align_t' enum) `LV_ALIGN_OUT_...` can't be used.</param>
        /// <param name="x_ofs">x coordinate offset after alignment</param>
        /// <param name="y_ofs">y coordinate offset after alignment</param>
        public static void LvObjAlign(global::lvgl.LvObjT obj, byte align, int x_ofs, int y_ofs)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjAlign(__arg0, align, x_ofs, y_ofs);
        }

        /// <summary>Align an object to an other object.</summary>
        /// <param name="obj">pointer to an object to align</param>
        /// <param name="base">pointer to an other object (if NULL `obj`s parent is used). 'obj' will be aligned to it.</param>
        /// <param name="align">type of alignment (see 'lv_align_t' enum)</param>
        /// <param name="x_ofs">x coordinate offset after alignment</param>
        /// <param name="y_ofs">y coordinate offset after alignment</param>
        /// <remarks>if the position or size of `base` changes `obj` needs to be aligned manually again</remarks>
        public static void LvObjAlignTo(global::lvgl.LvObjT obj, global::lvgl.LvObjT @base, byte align, int x_ofs, int y_ofs)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = @base is null ? __IntPtr.Zero : @base.__Instance;
            __Internal.LvObjAlignTo(__arg0, __arg1, align, x_ofs, y_ofs);
        }

        /// <summary>Copy the coordinates of an object to an area</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="coords">pointer to an area to store the coordinates</param>
        public static void LvObjGetCoords(global::lvgl.LvObjT obj, global::lvgl.LvAreaT coords)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = coords is null ? __IntPtr.Zero : coords.__Instance;
            __Internal.LvObjGetCoords(__arg0, __arg1);
        }

        /// <summary>Get the x coordinate of object.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>distance of `obj` from the left side of its parent plus the parent's left padding</returns>
        /// <remarks>
        /// <para>The position of the object is recalculated only on the next redraw. To force coordinate recalculation</para>
        /// <para>call `lv_obj_update_layout(obj)`.</para>
        /// <para>Zero return value means the object is on the left padding of the parent, and not on the left edge.</para>
        /// <para>Scrolling of the parent doesn't change the returned value.</para>
        /// <para>The returned value is always the distance from the parent even if `obj` is positioned by a layout.</para>
        /// </remarks>
        public static int LvObjGetX(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetX(__arg0);
            return ___ret;
        }

        /// <summary>Get the x2 coordinate of object.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>distance of `obj` from the right side of its parent plus the parent's right padding</returns>
        /// <remarks>
        /// <para>The position of the object is recalculated only on the next redraw. To force coordinate recalculation</para>
        /// <para>call `lv_obj_update_layout(obj)`.</para>
        /// <para>Zero return value means the object is on the right padding of the parent, and not on the right edge.</para>
        /// <para>Scrolling of the parent doesn't change the returned value.</para>
        /// <para>The returned value is always the distance from the parent even if `obj` is positioned by a layout.</para>
        /// </remarks>
        public static int LvObjGetX2(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetX2(__arg0);
            return ___ret;
        }

        /// <summary>Get the y coordinate of object.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>distance of `obj` from the top side of its parent plus the parent's top padding</returns>
        /// <remarks>
        /// <para>The position of the object is recalculated only on the next redraw. To force coordinate recalculation</para>
        /// <para>call `lv_obj_update_layout(obj)`.</para>
        /// <para>Zero return value means the object is on the top padding of the parent, and not on the top edge.</para>
        /// <para>Scrolling of the parent doesn't change the returned value.</para>
        /// <para>The returned value is always the distance from the parent even if `obj` is positioned by a layout.</para>
        /// </remarks>
        public static int LvObjGetY(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetY(__arg0);
            return ___ret;
        }

        /// <summary>Get the y2 coordinate of object.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>distance of `obj` from the bottom side of its parent plus the parent's bottom padding</returns>
        /// <remarks>
        /// <para>The position of the object is recalculated only on the next redraw. To force coordinate recalculation</para>
        /// <para>call `lv_obj_update_layout(obj)`.</para>
        /// <para>Zero return value means the object is on the bottom padding of the parent, and not on the bottom edge.</para>
        /// <para>Scrolling of the parent doesn't change the returned value.</para>
        /// <para>The returned value is always the distance from the parent even if `obj` is positioned by a layout.</para>
        /// </remarks>
        public static int LvObjGetY2(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetY2(__arg0);
            return ___ret;
        }

        /// <summary>Get the actually set x coordinate of object, i.e. the offset form the set alignment</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the set x coordinate</returns>
        public static int LvObjGetXAligned(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetXAligned(__arg0);
            return ___ret;
        }

        /// <summary>Get the actually set y coordinate of object, i.e. the offset form the set alignment</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the set y coordinate</returns>
        public static int LvObjGetYAligned(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetYAligned(__arg0);
            return ___ret;
        }

        /// <summary>Get the width of an object</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the width in pixels</returns>
        /// <remarks>
        /// <para>The position of the object is recalculated only on the next redraw. To force coordinate recalculation</para>
        /// <para>call `lv_obj_update_layout(obj)`.</para>
        /// </remarks>
        public static int LvObjGetWidth(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetWidth(__arg0);
            return ___ret;
        }

        /// <summary>Get the height of an object</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the height in pixels</returns>
        /// <remarks>
        /// <para>The position of the object is recalculated only on the next redraw. To force coordinate recalculation</para>
        /// <para>call `lv_obj_update_layout(obj)`.</para>
        /// </remarks>
        public static int LvObjGetHeight(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetHeight(__arg0);
            return ___ret;
        }

        /// <summary>Get the width reduced by the left and right padding and the border width.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the width which still fits into its parent without causing overflow (making the parent scrollable)</returns>
        /// <remarks>
        /// <para>The position of the object is recalculated only on the next redraw. To force coordinate recalculation</para>
        /// <para>call `lv_obj_update_layout(obj)`.</para>
        /// </remarks>
        public static int LvObjGetContentWidth(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetContentWidth(__arg0);
            return ___ret;
        }

        /// <summary>Get the height reduced by the top and bottom padding and the border width.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the height which still fits into the parent without causing overflow (making the parent scrollable)</returns>
        /// <remarks>
        /// <para>The position of the object is recalculated only on the next redraw. To force coordinate recalculation</para>
        /// <para>call `lv_obj_update_layout(obj)`.</para>
        /// </remarks>
        public static int LvObjGetContentHeight(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetContentHeight(__arg0);
            return ___ret;
        }

        /// <summary>Get the area reduced by the paddings and the border width.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="area">the area which still fits into the parent without causing overflow (making the parent scrollable)</param>
        /// <remarks>
        /// <para>The position of the object is recalculated only on the next redraw. To force coordinate recalculation</para>
        /// <para>call `lv_obj_update_layout(obj)`.</para>
        /// </remarks>
        public static void LvObjGetContentCoords(global::lvgl.LvObjT obj, global::lvgl.LvAreaT area)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = area is null ? __IntPtr.Zero : area.__Instance;
            __Internal.LvObjGetContentCoords(__arg0, __arg1);
        }

        /// <summary>Get the width occupied by the &quot;parts&quot; of the widget. E.g. the width of all columns of a table.</summary>
        /// <param name="obj">pointer to an objects</param>
        /// <returns>the width of the virtually drawn content</returns>
        /// <remarks>
        /// <para>This size independent from the real size of the widget.</para>
        /// <para>It just tells how large the internal (&quot;virtual&quot;) content is.</para>
        /// </remarks>
        public static int LvObjGetSelfWidth(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetSelfWidth(__arg0);
            return ___ret;
        }

        /// <summary>Get the height occupied by the &quot;parts&quot; of the widget. E.g. the height of all rows of a table.</summary>
        /// <param name="obj">pointer to an objects</param>
        /// <returns>the width of the virtually drawn content</returns>
        /// <remarks>
        /// <para>This size independent from the real size of the widget.</para>
        /// <para>It just tells how large the internal (&quot;virtual&quot;) content is.</para>
        /// </remarks>
        public static int LvObjGetSelfHeight(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetSelfHeight(__arg0);
            return ___ret;
        }

        /// <summary>Handle if the size of the internal (&quot;virtual&quot;) content of an object has changed.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>false: nothing happened; true: refresh happened</returns>
        public static bool LvObjRefreshSelfSize(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjRefreshSelfSize(__arg0);
            return ___ret;
        }

        public static void LvObjRefrPos(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjRefrPos(__arg0);
        }

        public static void LvObjMoveTo(global::lvgl.LvObjT obj, int x, int y)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjMoveTo(__arg0, x, y);
        }

        public static void LvObjMoveChildrenBy(global::lvgl.LvObjT obj, int x_diff, int y_diff, bool ignore_floating)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjMoveChildrenBy(__arg0, x_diff, y_diff, ignore_floating);
        }

        /// <summary>Transform a point using the angle and zoom style properties of an object</summary>
        /// <param name="obj">pointer to an object whose style properties should be used</param>
        /// <param name="p">a point to transform, the result will be written back here too</param>
        /// <param name="flags">OR-ed valued of :cpp:enum:`lv_obj_point_transform_flag_t`</param>
        public static void LvObjTransformPoint(global::lvgl.LvObjT obj, global::lvgl.LvPointT p, global::lvgl.LvObjPointTransformFlagT flags)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = p is null ? __IntPtr.Zero : p.__Instance;
            __Internal.LvObjTransformPoint(__arg0, __arg1, flags);
        }

        /// <summary>Transform an array of points using the angle and zoom style properties of an object</summary>
        /// <param name="obj">pointer to an object whose style properties should be used</param>
        /// <param name="points">the array of points to transform, the result will be written back here too</param>
        /// <param name="count">number of points in the array</param>
        /// <param name="flags">OR-ed valued of :cpp:enum:`lv_obj_point_transform_flag_t`</param>
        public static void LvObjTransformPointArray(global::lvgl.LvObjT obj, global::lvgl.LvPointT[] points, ulong count, global::lvgl.LvObjPointTransformFlagT flags)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            global::lvgl.LvPointT.__Internal[] __points;
            if (points == null)
                __points = null;
            else
            {
                __points = new global::lvgl.LvPointT.__Internal[points.Length];
                for (int i = 0; i < __points.Length; i++)
                {
                    var __element = points[i];
                    __points[i] = __element is null ? new global::lvgl.LvPointT.__Internal() : *(global::lvgl.LvPointT.__Internal*) __element.__Instance;
                }
            }
            var __arg1 = __points;
            __Internal.LvObjTransformPointArray(__arg0, __arg1, count, flags);
        }

        /// <summary>Transform an area using the angle and zoom style properties of an object</summary>
        /// <param name="obj">pointer to an object whose style properties should be used</param>
        /// <param name="area">an area to transform, the result will be written back here too</param>
        /// <param name="flags">OR-ed valued of :cpp:enum:`lv_obj_point_transform_flag_t`</param>
        public static void LvObjGetTransformedArea(global::lvgl.LvObjT obj, global::lvgl.LvAreaT area, global::lvgl.LvObjPointTransformFlagT flags)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = area is null ? __IntPtr.Zero : area.__Instance;
            __Internal.LvObjGetTransformedArea(__arg0, __arg1, flags);
        }

        /// <summary>
        /// <para>Mark an area of an object as invalid.</para>
        /// <para>The area will be truncated to the object's area and marked for redraw.</para>
        /// </summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="area">the area to redraw</param>
        public static void LvObjInvalidateArea(global::lvgl.LvObjT obj, global::lvgl.LvAreaT area)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = area is null ? __IntPtr.Zero : area.__Instance;
            __Internal.LvObjInvalidateArea(__arg0, __arg1);
        }

        /// <summary>Mark the object as invalid to redrawn its area</summary>
        /// <param name="obj">pointer to an object</param>
        public static void LvObjInvalidate(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjInvalidate(__arg0);
        }

        /// <summary>Tell whether an area of an object is visible (even partially) now or not</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="area">the are to check. The visible part of the area will be written back here.</param>
        /// <returns>true     visible; false not visible (hidden, out of parent, on other screen, etc)</returns>
        public static bool LvObjAreaIsVisible(global::lvgl.LvObjT obj, global::lvgl.LvAreaT area)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = area is null ? __IntPtr.Zero : area.__Instance;
            var ___ret = __Internal.LvObjAreaIsVisible(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Tell whether an object is visible (even partially) now or not</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>true: visible; false not visible (hidden, out of parent, on other screen, etc)</returns>
        public static bool LvObjIsVisible(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjIsVisible(__arg0);
            return ___ret;
        }

        /// <summary>Set the size of an extended clickable area</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="size">extended clickable area in all 4 directions [px]</param>
        public static void LvObjSetExtClickArea(global::lvgl.LvObjT obj, int size)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetExtClickArea(__arg0, size);
        }

        /// <summary>
        /// <para>Get the an area where to object can be clicked.</para>
        /// <para>It's the object's normal area plus the extended click area.</para>
        /// </summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="area">store the result area here</param>
        public static void LvObjGetClickArea(global::lvgl.LvObjT obj, global::lvgl.LvAreaT area)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = area is null ? __IntPtr.Zero : area.__Instance;
            __Internal.LvObjGetClickArea(__arg0, __arg1);
        }

        /// <summary>Hit-test an object given a particular point in screen space.</summary>
        /// <param name="obj">object to hit-test</param>
        /// <param name="point">screen-space point (absolute coordinate)</param>
        /// <returns>true: if the object is considered under the point</returns>
        public static bool LvObjHitTest(global::lvgl.LvObjT obj, global::lvgl.LvPointT point)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = point is null ? __IntPtr.Zero : point.__Instance;
            var ___ret = __Internal.LvObjHitTest(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Clamp a width between min and max width. If the min/max width is in percentage value use the ref_width</summary>
        /// <param name="width">width to clamp</param>
        /// <param name="min_width">the minimal width</param>
        /// <param name="max_width">the maximal width</param>
        /// <param name="ref_width">the reference width used when min/max width is in percentage</param>
        /// <returns>the clamped width</returns>
        public static int LvClampWidth(int width, int min_width, int max_width, int ref_width)
        {
            var ___ret = __Internal.LvClampWidth(width, min_width, max_width, ref_width);
            return ___ret;
        }

        /// <summary>Clamp a height between min and max height. If the min/max height is in percentage value use the ref_height</summary>
        /// <param name="height">height to clamp</param>
        /// <param name="min_height">the minimal height</param>
        /// <param name="max_height">the maximal height</param>
        /// <param name="ref_height">the reference height used when min/max height is in percentage</param>
        /// <returns>the clamped height</returns>
        public static int LvClampHeight(int height, int min_height, int max_height, int ref_height)
        {
            var ___ret = __Internal.LvClampHeight(height, min_height, max_height, ref_height);
            return ___ret;
        }
    }

    /// <summary>Scrollbar modes: shows when should the scrollbars be visible</summary>
    public enum LvScrollbarModeT
    {
        /// <summary>Never show scrollbars</summary>
        LV_SCROLLBAR_MODE_OFF = 0,
        /// <summary>Always show scrollbars</summary>
        LV_SCROLLBAR_MODE_ON = 1,
        /// <summary>Show scroll bars when object is being scrolled</summary>
        LV_SCROLLBAR_MODE_ACTIVE = 2,
        /// <summary>Show scroll bars when the content is large enough to be scrolled</summary>
        LV_SCROLLBAR_MODE_AUTO = 3
    }

    /// <summary>Scroll span align options. Tells where to align the snappable children when scroll stops.</summary>
    public enum LvScrollSnapT
    {
        /// <summary>Do not align, leave where it is</summary>
        LV_SCROLL_SNAP_NONE = 0,
        /// <summary>Align to the left/top</summary>
        LV_SCROLL_SNAP_START = 1,
        /// <summary>Align to the right/bottom</summary>
        LV_SCROLL_SNAP_END = 2,
        /// <summary>Align to the center</summary>
        LV_SCROLL_SNAP_CENTER = 3
    }

    public unsafe partial class lv_obj_scroll
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_scrollbar_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetScrollbarMode(__IntPtr obj, byte mode);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_scroll_dir", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetScrollDir(__IntPtr obj, byte dir);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_scroll_snap_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetScrollSnapX(__IntPtr obj, byte align);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_scroll_snap_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetScrollSnapY(__IntPtr obj, byte align);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_scrollbar_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvObjGetScrollbarMode(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_scroll_dir", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvObjGetScrollDir(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_scroll_snap_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvObjGetScrollSnapX(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_scroll_snap_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvObjGetScrollSnapY(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_scroll_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetScrollX(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_scroll_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetScrollY(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_scroll_top", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetScrollTop(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_scroll_bottom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetScrollBottom(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_scroll_left", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetScrollLeft(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_scroll_right", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetScrollRight(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_scroll_end", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjGetScrollEnd(__IntPtr obj, __IntPtr end);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_scroll_by", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjScrollBy(__IntPtr obj, int x, int y, global::lvgl.LvAnimEnableT anim_en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_scroll_by_bounded", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjScrollByBounded(__IntPtr obj, int dx, int dy, global::lvgl.LvAnimEnableT anim_en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_scroll_to", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjScrollTo(__IntPtr obj, int x, int y, global::lvgl.LvAnimEnableT anim_en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_scroll_to_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjScrollToX(__IntPtr obj, int x, global::lvgl.LvAnimEnableT anim_en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_scroll_to_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjScrollToY(__IntPtr obj, int y, global::lvgl.LvAnimEnableT anim_en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_scroll_to_view", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjScrollToView(__IntPtr obj, global::lvgl.LvAnimEnableT anim_en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_scroll_to_view_recursive", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjScrollToViewRecursive(__IntPtr obj, global::lvgl.LvAnimEnableT anim_en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_obj_scroll_by_raw", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvObjScrollByRaw(__IntPtr obj, int x, int y);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_is_scrolling", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjIsScrolling(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_update_snap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjUpdateSnap(__IntPtr obj, global::lvgl.LvAnimEnableT anim_en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_scrollbar_area", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjGetScrollbarArea(__IntPtr obj, __IntPtr hor, __IntPtr ver);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_scrollbar_invalidate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjScrollbarInvalidate(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_readjust_scroll", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjReadjustScroll(__IntPtr obj, global::lvgl.LvAnimEnableT anim_en);
        }

        /// <summary>Set how the scrollbars should behave.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="mode">LV_SCROLL_MODE_ON/OFF/AUTO/ACTIVE</param>
        public static void LvObjSetScrollbarMode(global::lvgl.LvObjT obj, byte mode)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetScrollbarMode(__arg0, mode);
        }

        /// <summary>Set the object in which directions can be scrolled</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="dir">the allow scroll directions. An element or OR-ed values of `lv_dir_t`</param>
        public static void LvObjSetScrollDir(global::lvgl.LvObjT obj, byte dir)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetScrollDir(__arg0, dir);
        }

        /// <summary>Set where to snap the children when scrolling ends horizontally</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="align">the snap align to set from `lv_scroll_snap_t`</param>
        public static void LvObjSetScrollSnapX(global::lvgl.LvObjT obj, byte align)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetScrollSnapX(__arg0, align);
        }

        /// <summary>Set where to snap the children when scrolling ends vertically</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="align">the snap align to set from `lv_scroll_snap_t`</param>
        public static void LvObjSetScrollSnapY(global::lvgl.LvObjT obj, byte align)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetScrollSnapY(__arg0, align);
        }

        /// <summary>Get the current scroll mode (when to hide the scrollbars)</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the current scroll mode from `lv_scrollbar_mode_t`</returns>
        public static byte LvObjGetScrollbarMode(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetScrollbarMode(__arg0);
            return ___ret;
        }

        /// <summary>Get the object in which directions can be scrolled</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="dir">the allow scroll directions. An element or OR-ed values of `lv_dir_t`</param>
        public static byte LvObjGetScrollDir(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetScrollDir(__arg0);
            return ___ret;
        }

        /// <summary>Get where to snap the children when scrolling ends horizontally</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the current snap align from `lv_scroll_snap_t`</returns>
        public static byte LvObjGetScrollSnapX(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetScrollSnapX(__arg0);
            return ___ret;
        }

        /// <summary>Get where to snap the children when scrolling ends vertically</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the current snap align from `lv_scroll_snap_t`</returns>
        public static byte LvObjGetScrollSnapY(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetScrollSnapY(__arg0);
            return ___ret;
        }

        /// <summary>Get current X scroll position.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>
        /// <para>the current scroll position from the left edge.</para>
        /// <para>If the object is not scrolled return 0</para>
        /// <para>If scrolled return &gt; 0</para>
        /// <para>If scrolled in (elastic scroll) return&lt;0</para>
        /// </returns>
        public static int LvObjGetScrollX(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetScrollX(__arg0);
            return ___ret;
        }

        /// <summary>Get current Y scroll position.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>
        /// <para>the current scroll position from the top edge.</para>
        /// <para>If the object is not scrolled return 0</para>
        /// <para>If scrolled return &gt; 0</para>
        /// <para>If scrolled inside return&lt;0</para>
        /// </returns>
        public static int LvObjGetScrollY(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetScrollY(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Return the height of the area above the object.</para>
        /// <para>That is the number of pixels the object can be scrolled down.</para>
        /// <para>Normally positive but can be negative when scrolled inside.</para>
        /// </summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the scrollable area above the object in pixels</returns>
        public static int LvObjGetScrollTop(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetScrollTop(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Return the height of the area below the object.</para>
        /// <para>That is the number of pixels the object can be scrolled down.</para>
        /// <para>Normally positive but can be negative when scrolled inside.</para>
        /// </summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the scrollable area below the object in pixels</returns>
        public static int LvObjGetScrollBottom(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetScrollBottom(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Return the width of the area on the left the object.</para>
        /// <para>That is the number of pixels the object can be scrolled down.</para>
        /// <para>Normally positive but can be negative when scrolled inside.</para>
        /// </summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the scrollable area on the left the object in pixels</returns>
        public static int LvObjGetScrollLeft(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetScrollLeft(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Return the width of the area on the right the object.</para>
        /// <para>That is the number of pixels the object can be scrolled down.</para>
        /// <para>Normally positive but can be negative when scrolled inside.</para>
        /// </summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the scrollable area on the right the object in pixels</returns>
        public static int LvObjGetScrollRight(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetScrollRight(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Get the X and Y coordinates where the scrolling will end for this object if a scrolling animation is in progress.</para>
        /// <para>If no scrolling animation, give the current `x` or `y` scroll position.</para>
        /// </summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="end">pointer to store the result</param>
        public static void LvObjGetScrollEnd(global::lvgl.LvObjT obj, global::lvgl.LvPointT end)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = end is null ? __IntPtr.Zero : end.__Instance;
            __Internal.LvObjGetScrollEnd(__arg0, __arg1);
        }

        /// <summary>Scroll by a given amount of pixels</summary>
        /// <param name="obj">pointer to an object to scroll</param>
        /// <param name="x">pixels to scroll horizontally</param>
        /// <param name="y">pixels to scroll vertically</param>
        /// <param name="anim_en">LV_ANIM_ON: scroll with animation; LV_ANIM_OFF: scroll immediately</param>
        /// <remarks>
        /// <para>&gt; 0 value means scroll right/bottom (show the more content on the right/bottom)</para>
        /// <para>e.g. dy = -20 means scroll down 20 px</para>
        /// </remarks>
        public static void LvObjScrollBy(global::lvgl.LvObjT obj, int x, int y, global::lvgl.LvAnimEnableT anim_en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjScrollBy(__arg0, x, y, anim_en);
        }

        /// <summary>
        /// <para>Scroll by a given amount of pixels.</para>
        /// <para>`dx` and `dy` will be limited internally to allow scrolling only on the content area.</para>
        /// </summary>
        /// <param name="obj">pointer to an object to scroll</param>
        /// <param name="dx">pixels to scroll horizontally</param>
        /// <param name="dy">pixels to scroll vertically</param>
        /// <param name="anim_en">LV_ANIM_ON: scroll with animation; LV_ANIM_OFF: scroll immediately</param>
        /// <remarks>e.g. dy = -20 means scroll down 20 px</remarks>
        public static void LvObjScrollByBounded(global::lvgl.LvObjT obj, int dx, int dy, global::lvgl.LvAnimEnableT anim_en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjScrollByBounded(__arg0, dx, dy, anim_en);
        }

        /// <summary>
        /// <para>Scroll to a given coordinate on an object.</para>
        /// <para>`x` and `y` will be limited internally to allow scrolling only on the content area.</para>
        /// </summary>
        /// <param name="obj">pointer to an object to scroll</param>
        /// <param name="x">pixels to scroll horizontally</param>
        /// <param name="y">pixels to scroll vertically</param>
        /// <param name="anim_en">LV_ANIM_ON: scroll with animation; LV_ANIM_OFF: scroll immediately</param>
        public static void LvObjScrollTo(global::lvgl.LvObjT obj, int x, int y, global::lvgl.LvAnimEnableT anim_en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjScrollTo(__arg0, x, y, anim_en);
        }

        /// <summary>
        /// <para>Scroll to a given X coordinate on an object.</para>
        /// <para>`x` will be limited internally to allow scrolling only on the content area.</para>
        /// </summary>
        /// <param name="obj">pointer to an object to scroll</param>
        /// <param name="x">pixels to scroll horizontally</param>
        /// <param name="anim_en">LV_ANIM_ON: scroll with animation; LV_ANIM_OFF: scroll immediately</param>
        public static void LvObjScrollToX(global::lvgl.LvObjT obj, int x, global::lvgl.LvAnimEnableT anim_en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjScrollToX(__arg0, x, anim_en);
        }

        /// <summary>
        /// <para>Scroll to a given Y coordinate on an object</para>
        /// <para>`y` will be limited internally to allow scrolling only on the content area.</para>
        /// </summary>
        /// <param name="obj">pointer to an object to scroll</param>
        /// <param name="y">pixels to scroll vertically</param>
        /// <param name="anim_en">LV_ANIM_ON: scroll with animation; LV_ANIM_OFF: scroll immediately</param>
        public static void LvObjScrollToY(global::lvgl.LvObjT obj, int y, global::lvgl.LvAnimEnableT anim_en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjScrollToY(__arg0, y, anim_en);
        }

        /// <summary>Scroll to an object until it becomes visible on its parent</summary>
        /// <param name="obj">pointer to an object to scroll into view</param>
        /// <param name="anim_en">LV_ANIM_ON: scroll with animation; LV_ANIM_OFF: scroll immediately</param>
        public static void LvObjScrollToView(global::lvgl.LvObjT obj, global::lvgl.LvAnimEnableT anim_en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjScrollToView(__arg0, anim_en);
        }

        /// <summary>
        /// <para>Scroll to an object until it becomes visible on its parent.</para>
        /// <para>Do the same on the parent's parent, and so on.</para>
        /// <para>Therefore the object will be scrolled into view even it has nested scrollable parents</para>
        /// </summary>
        /// <param name="obj">pointer to an object to scroll into view</param>
        /// <param name="anim_en">LV_ANIM_ON: scroll with animation; LV_ANIM_OFF: scroll immediately</param>
        public static void LvObjScrollToViewRecursive(global::lvgl.LvObjT obj, global::lvgl.LvAnimEnableT anim_en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjScrollToViewRecursive(__arg0, anim_en);
        }

        /// <summary>
        /// <para>Low level function to scroll by given x and y coordinates.</para>
        /// <para>`LV_EVENT_SCROLL` is sent.</para>
        /// </summary>
        /// <param name="obj">pointer to an object to scroll</param>
        /// <param name="x">pixels to scroll horizontally</param>
        /// <param name="y">pixels to scroll vertically</param>
        /// <returns>
        /// <para>`LV_RESULT_INVALID`: to object was deleted in `LV_EVENT_SCROLL`;</para>
        /// <para>`LV_RESULT_OK`: if the object is still valid</para>
        /// </returns>
        public static byte LvObjScrollByRaw(global::lvgl.LvObjT obj, int x, int y)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjScrollByRaw(__arg0, x, y);
            return ___ret;
        }

        /// <summary>Tell whether an object is being scrolled or not at this moment</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>true: `obj` is being scrolled</returns>
        public static bool LvObjIsScrolling(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjIsScrolling(__arg0);
            return ___ret;
        }

        /// <summary>Check the children of `obj` and scroll `obj` to fulfill the scroll_snap settings</summary>
        /// <param name="obj">an object whose children needs to checked and snapped</param>
        /// <param name="anim_en">LV_ANIM_ON/OFF</param>
        public static void LvObjUpdateSnap(global::lvgl.LvObjT obj, global::lvgl.LvAnimEnableT anim_en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjUpdateSnap(__arg0, anim_en);
        }

        /// <summary>Get the area of the scrollbars</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="hor">pointer to store the area of the horizontal scrollbar</param>
        /// <param name="ver">pointer to store the area of the vertical  scrollbar</param>
        public static void LvObjGetScrollbarArea(global::lvgl.LvObjT obj, global::lvgl.LvAreaT hor, global::lvgl.LvAreaT ver)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = hor is null ? __IntPtr.Zero : hor.__Instance;
            var __arg2 = ver is null ? __IntPtr.Zero : ver.__Instance;
            __Internal.LvObjGetScrollbarArea(__arg0, __arg1, __arg2);
        }

        /// <summary>Invalidate the area of the scrollbars</summary>
        /// <param name="obj">pointer to an object</param>
        public static void LvObjScrollbarInvalidate(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjScrollbarInvalidate(__arg0);
        }

        /// <summary>Checks if the content is scrolled &quot;in&quot; and adjusts it to a normal position.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="anim_en">LV_ANIM_ON/OFF</param>
        public static void LvObjReadjustScroll(global::lvgl.LvObjT obj, global::lvgl.LvAnimEnableT anim_en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjReadjustScroll(__arg0, anim_en);
        }
    }

    public enum LvStyleStateCmpT
    {
        LV_STYLE_STATE_CMP_SAME = 0,
        LV_STYLE_STATE_CMP_DIFF_REDRAW = 1,
        LV_STYLE_STATE_CMP_DIFF_DRAW_PAD = 2,
        LV_STYLE_STATE_CMP_DIFF_LAYOUT = 3
    }

    public unsafe partial class LvObjStyleT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr style;

            [FieldOffset(8)]
            internal uint selector;

            [FieldOffset(11)]
            internal uint is_local;

            [FieldOffset(11)]
            internal uint is_trans;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_obj_style_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvObjStyleT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvObjStyleT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvObjStyleT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvObjStyleT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvObjStyleT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvObjStyleT(native.ToPointer(), skipVTables);
        }

        internal static LvObjStyleT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvObjStyleT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvObjStyleT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvObjStyleT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvObjStyleT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvObjStyleT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvObjStyleT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvObjStyleT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvObjStyleT(global::lvgl.LvObjStyleT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvObjStyleT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvObjStyleT.__Internal*) __Instance) = *((global::lvgl.LvObjStyleT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvStyleT Style
        {
            get
            {
                var __result0 = global::lvgl.LvStyleT.__GetOrCreateInstance(((__Internal*)__Instance)->style, false);
                return __result0;
            }
        }

        public uint Selector
        {
            get
            {
                return ((__Internal*)__Instance)->selector;
            }

            set
            {
                ((__Internal*)__Instance)->selector = value;
            }
        }

        public uint IsLocal
        {
            get
            {
                return ((__Internal*)__Instance)->is_local;
            }

            set
            {
                ((__Internal*)__Instance)->is_local = value;
            }
        }

        public uint IsTrans
        {
            get
            {
                return ((__Internal*)__Instance)->is_trans;
            }

            set
            {
                ((__Internal*)__Instance)->is_trans = value;
            }
        }
    }

    public unsafe partial class LvObjStyleTransitionDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal ushort time;
            internal ushort delay;
            internal uint selector;
            internal byte prop;
            internal __IntPtr path_cb;
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_obj_style_transition_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvObjStyleTransitionDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvObjStyleTransitionDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvObjStyleTransitionDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvObjStyleTransitionDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvObjStyleTransitionDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvObjStyleTransitionDscT(native.ToPointer(), skipVTables);
        }

        internal static LvObjStyleTransitionDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvObjStyleTransitionDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvObjStyleTransitionDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvObjStyleTransitionDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvObjStyleTransitionDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvObjStyleTransitionDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvObjStyleTransitionDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvObjStyleTransitionDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvObjStyleTransitionDscT(global::lvgl.LvObjStyleTransitionDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvObjStyleTransitionDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvObjStyleTransitionDscT.__Internal*) __Instance) = *((global::lvgl.LvObjStyleTransitionDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Time
        {
            get
            {
                return ((__Internal*)__Instance)->time;
            }

            set
            {
                ((__Internal*)__Instance)->time = value;
            }
        }

        public ushort Delay
        {
            get
            {
                return ((__Internal*)__Instance)->delay;
            }

            set
            {
                ((__Internal*)__Instance)->delay = value;
            }
        }

        public uint Selector
        {
            get
            {
                return ((__Internal*)__Instance)->selector;
            }

            set
            {
                ((__Internal*)__Instance)->selector = value;
            }
        }

        public byte Prop
        {
            get
            {
                return ((__Internal*)__Instance)->prop;
            }

            set
            {
                ((__Internal*)__Instance)->prop = value;
            }
        }

        public global::lvgl.LvAnimPathCbT PathCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->path_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvAnimPathCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvAnimPathCbT));
            }

            set
            {
                ((__Internal*)__Instance)->path_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class lv_obj_style
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_obj_style_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjStyleInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_obj_style_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjStyleDeinit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_add_style", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjAddStyle(__IntPtr obj, __IntPtr style, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_replace_style", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjReplaceStyle(__IntPtr obj, __IntPtr old_style, __IntPtr new_style, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_remove_style", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjRemoveStyle(__IntPtr obj, __IntPtr style, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_remove_style_all", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjRemoveStyleAll(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_report_style_change", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjReportStyleChange(__IntPtr style);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_refresh_style", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjRefreshStyle(__IntPtr obj, uint part, byte prop);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_enable_style_refresh", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjEnableStyleRefresh(bool en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_style_prop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::lvgl.LvStyleValueT.__Internal LvObjGetStyleProp(__IntPtr obj, uint part, byte prop);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_has_style_prop", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjHasStyleProp(__IntPtr obj, uint selector, byte prop);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_local_style_prop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetLocalStyleProp(__IntPtr obj, byte prop, global::lvgl.LvStyleValueT.__Internal value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_local_style_prop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvObjGetLocalStyleProp(__IntPtr obj, byte prop, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_remove_local_style_prop", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjRemoveLocalStyleProp(__IntPtr obj, byte prop, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_obj_style_apply_color_filter", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::lvgl.LvStyleValueT.__Internal LvObjStyleApplyColorFilter(__IntPtr obj, uint part, global::lvgl.LvStyleValueT.__Internal v);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_obj_style_create_transition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjStyleCreateTransition(__IntPtr obj, uint part, ushort prev_state, ushort new_state, __IntPtr tr);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_obj_style_state_compare", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::lvgl.LvStyleStateCmpT LvObjStyleStateCompare(__IntPtr obj, ushort state1, ushort state2);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_fade_in", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjFadeIn(__IntPtr obj, uint time, uint delay);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_fade_out", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjFadeOut(__IntPtr obj, uint time, uint delay);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_calculate_style_text_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvObjCalculateStyleTextAlign(__IntPtr obj, uint part, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string txt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_style_opa_recursive", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvObjGetStyleOpaRecursive(__IntPtr obj, uint part);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_obj_update_layer_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjUpdateLayerType(__IntPtr obj);
        }

        /// <summary>
        /// <para>Initialize the object related style manager module.</para>
        /// <para>Called by LVGL in `lv_init()`</para>
        /// </summary>
        public static void LvObjStyleInit()
        {
            __Internal.LvObjStyleInit();
        }

        /// <summary>
        /// <para>Deinitialize the object related style manager module.</para>
        /// <para>Called by LVGL in `lv_deinit()`</para>
        /// </summary>
        public static void LvObjStyleDeinit()
        {
            __Internal.LvObjStyleDeinit();
        }

        /// <summary>Add a style to an object.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="style">pointer to a style to add</param>
        /// <param name="selector">OR-ed value of parts and state to which the style should be added</param>
        public static void LvObjAddStyle(global::lvgl.LvObjT obj, global::lvgl.LvStyleT style, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvObjAddStyle(__arg0, __arg1, selector);
        }

        /// <summary>Replaces a style of an object, preserving the order of the style stack (local styles and transitions are ignored).</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="old_style">pointer to a style to replace.</param>
        /// <param name="new_style">pointer to a style to replace the old style with.</param>
        /// <param name="selector">OR-ed values of states and a part to replace only styles with matching selectors. LV_STATE_ANY and LV_PART_ANY can be used</param>
        public static bool LvObjReplaceStyle(global::lvgl.LvObjT obj, global::lvgl.LvStyleT old_style, global::lvgl.LvStyleT new_style, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = old_style is null ? __IntPtr.Zero : old_style.__Instance;
            var __arg2 = new_style is null ? __IntPtr.Zero : new_style.__Instance;
            var ___ret = __Internal.LvObjReplaceStyle(__arg0, __arg1, __arg2, selector);
            return ___ret;
        }

        /// <summary>Remove a style from an object.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="style">pointer to a style to remove. Can be NULL to check only the selector</param>
        /// <param name="selector">OR-ed values of states and a part to remove only styles with matching selectors. LV_STATE_ANY and LV_PART_ANY can be used</param>
        public static void LvObjRemoveStyle(global::lvgl.LvObjT obj, global::lvgl.LvStyleT style, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvObjRemoveStyle(__arg0, __arg1, selector);
        }

        /// <summary>Remove all styles from an object</summary>
        /// <param name="obj">pointer to an object</param>
        public static void LvObjRemoveStyleAll(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjRemoveStyleAll(__arg0);
        }

        /// <summary>Notify all object if a style is modified</summary>
        /// <param name="style">
        /// <para>pointer to a style. Only the objects with this style will be notified</para>
        /// <para>(NULL to notify all objects)</para>
        /// </param>
        public static void LvObjReportStyleChange(global::lvgl.LvStyleT style)
        {
            var __arg0 = style is null ? __IntPtr.Zero : style.__Instance;
            __Internal.LvObjReportStyleChange(__arg0);
        }

        /// <summary>Notify an object and its children about its style is modified.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="part">the part whose style was changed. E.g. `LV_PART_ANY`, `LV_PART_MAIN`</param>
        /// <param name="prop">
        /// <para>`LV_STYLE_PROP_ANY` or an `LV_STYLE_...` property.</para>
        /// <para>It is used to optimize what needs to be refreshed.</para>
        /// <para>`LV_STYLE_PROP_INV` to perform only a style cache update</para>
        /// </param>
        public static void LvObjRefreshStyle(global::lvgl.LvObjT obj, uint part, byte prop)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjRefreshStyle(__arg0, part, prop);
        }

        /// <summary>
        /// <para>Enable or disable automatic style refreshing when a new style is added/removed to/from an object</para>
        /// <para>or any other style change happens.</para>
        /// </summary>
        /// <param name="en">true: enable refreshing; false: disable refreshing</param>
        public static void LvObjEnableStyleRefresh(bool en)
        {
            __Internal.LvObjEnableStyleRefresh(en);
        }

        /// <summary>
        /// <para>Get the value of a style property. The current state of the object will be considered.</para>
        /// <para>Inherited properties will be inherited.</para>
        /// <para>If a property is not set a default value will be returned.</para>
        /// </summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="part">a part from which the property should be get</param>
        /// <param name="prop">the property to get</param>
        /// <returns>
        /// <para>the value of the property.</para>
        /// <para>Should be read from the correct field of the `lv_style_value_t` according to the type of the property.</para>
        /// </returns>
        public static global::lvgl.LvStyleValueT LvObjGetStyleProp(global::lvgl.LvObjT obj, uint part, byte prop)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetStyleProp(__arg0, part, prop);
            return global::lvgl.LvStyleValueT.__CreateInstance(___ret);
        }

        /// <summary>Check if an object has a specified style property for a given style selector.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="selector">the style selector to be checked, defining the scope of the style to be examined.</param>
        /// <param name="prop">the property to be checked.</param>
        /// <returns>true if the object has the specified selector and property, false otherwise.</returns>
        public static bool LvObjHasStyleProp(global::lvgl.LvObjT obj, uint selector, byte prop)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjHasStyleProp(__arg0, selector, prop);
            return ___ret;
        }

        /// <summary>Set local style property on an object's part and state.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="prop">the property</param>
        /// <param name="value">value of the property. The correct element should be set according to the type of the property</param>
        /// <param name="selector">OR-ed value of parts and state for which the style should be set</param>
        public static void LvObjSetLocalStyleProp(global::lvgl.LvObjT obj, byte prop, global::lvgl.LvStyleValueT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg2 = value.__Instance;
            __Internal.LvObjSetLocalStyleProp(__arg0, prop, __arg2, selector);
        }

        public static byte LvObjGetLocalStyleProp(global::lvgl.LvObjT obj, byte prop, global::lvgl.LvStyleValueT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ____arg2 = value.__Instance;
            var __arg2 = new __IntPtr(&____arg2);
            var ___ret = __Internal.LvObjGetLocalStyleProp(__arg0, prop, __arg2, selector);
            return ___ret;
        }

        /// <summary>Remove a local style property from a part of an object with a given state.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="prop">a style property to remove.</param>
        /// <param name="selector">OR-ed value of parts and state for which the style should be removed</param>
        /// <returns>true     the property was found and removed; false: the property was not found</returns>
        public static bool LvObjRemoveLocalStyleProp(global::lvgl.LvObjT obj, byte prop, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjRemoveLocalStyleProp(__arg0, prop, selector);
            return ___ret;
        }

        /// <summary>Used internally for color filtering</summary>
        public static global::lvgl.LvStyleValueT LvObjStyleApplyColorFilter(global::lvgl.LvObjT obj, uint part, global::lvgl.LvStyleValueT v)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg2 = v.__Instance;
            var ___ret = __Internal.LvObjStyleApplyColorFilter(__arg0, part, __arg2);
            return global::lvgl.LvStyleValueT.__CreateInstance(___ret);
        }

        /// <summary>Used internally to create a style transition</summary>
        public static void LvObjStyleCreateTransition(global::lvgl.LvObjT obj, uint part, ushort prev_state, ushort new_state, global::lvgl.LvObjStyleTransitionDscT tr)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg4 = tr is null ? __IntPtr.Zero : tr.__Instance;
            __Internal.LvObjStyleCreateTransition(__arg0, part, prev_state, new_state, __arg4);
        }

        /// <summary>Used internally to compare the appearance of an object in 2 states</summary>
        public static global::lvgl.LvStyleStateCmpT LvObjStyleStateCompare(global::lvgl.LvObjT obj, ushort state1, ushort state2)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjStyleStateCompare(__arg0, state1, state2);
            return ___ret;
        }

        /// <summary>Fade in an an object and all its children.</summary>
        /// <param name="obj">the object to fade in</param>
        /// <param name="time">time of fade</param>
        /// <param name="delay">delay to start the animation</param>
        public static void LvObjFadeIn(global::lvgl.LvObjT obj, uint time, uint delay)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjFadeIn(__arg0, time, delay);
        }

        /// <summary>Fade out an an object and all its children.</summary>
        /// <param name="obj">the object to fade out</param>
        /// <param name="time">time of fade</param>
        /// <param name="delay">delay to start the animation</param>
        public static void LvObjFadeOut(global::lvgl.LvObjT obj, uint time, uint delay)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjFadeOut(__arg0, time, delay);
        }

        public static byte LvObjCalculateStyleTextAlign(global::lvgl.LvObjT obj, uint part, string txt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjCalculateStyleTextAlign(__arg0, part, txt);
            return ___ret;
        }

        /// <summary>Get the `opa` style property from all parents and multiply and `&gt;&gt; 8` them.</summary>
        /// <param name="obj">the object whose opacity should be get</param>
        /// <param name="part">the part whose opacity should be get. Non-MAIN parts will consider the `opa` of the MAIN part too</param>
        /// <returns>the final opacity considering the parents' opacity too</returns>
        public static byte LvObjGetStyleOpaRecursive(global::lvgl.LvObjT obj, uint part)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetStyleOpaRecursive(__arg0, part);
            return ___ret;
        }

        /// <summary>
        /// <para>Update the layer type of a widget bayed on its current styles.</para>
        /// <para>The result will be stored in `obj-&gt;spec_attr-&gt;layer_type`</para>
        /// </summary>
        /// <param name="obj">the object whose layer should be updated</param>
        public static void LvObjUpdateLayerType(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjUpdateLayerType(__arg0);
        }
    }

    public unsafe partial class lv_obj_style_gen
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleWidth(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_min_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleMinWidth(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_max_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleMaxWidth(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleHeight(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_min_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleMinHeight(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_max_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleMaxHeight(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_length", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleLength(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleX(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleY(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleAlign(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_transform_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTransformWidth(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_transform_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTransformHeight(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_translate_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTranslateX(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_translate_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTranslateY(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_transform_scale_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTransformScaleX(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_transform_scale_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTransformScaleY(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_transform_rotation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTransformRotation(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_transform_pivot_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTransformPivotX(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_transform_pivot_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTransformPivotY(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_transform_skew_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTransformSkewX(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_transform_skew_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTransformSkewY(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_pad_top", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStylePadTop(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_pad_bottom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStylePadBottom(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_pad_left", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStylePadLeft(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_pad_right", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStylePadRight(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_pad_row", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStylePadRow(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_pad_column", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStylePadColumn(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_margin_top", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleMarginTop(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_margin_bottom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleMarginBottom(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_margin_left", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleMarginLeft(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_margin_right", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleMarginRight(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_bg_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBgColor(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_bg_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBgOpa(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_bg_grad_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBgGradColor(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_bg_grad_dir", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBgGradDir(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_bg_main_stop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBgMainStop(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_bg_grad_stop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBgGradStop(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_bg_main_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBgMainOpa(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_bg_grad_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBgGradOpa(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_bg_grad", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBgGrad(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_bg_image_src", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBgImageSrc(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_bg_image_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBgImageOpa(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_bg_image_recolor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBgImageRecolor(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_bg_image_recolor_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBgImageRecolorOpa(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_bg_image_tiled", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBgImageTiled(__IntPtr obj, bool value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_border_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBorderColor(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_border_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBorderOpa(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_border_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBorderWidth(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_border_side", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBorderSide(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_border_post", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBorderPost(__IntPtr obj, bool value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_outline_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleOutlineWidth(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_outline_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleOutlineColor(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_outline_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleOutlineOpa(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_outline_pad", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleOutlinePad(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_shadow_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleShadowWidth(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_shadow_offset_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleShadowOffsetX(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_shadow_offset_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleShadowOffsetY(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_shadow_spread", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleShadowSpread(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_shadow_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleShadowColor(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_shadow_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleShadowOpa(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_image_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleImageOpa(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_image_recolor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleImageRecolor(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_image_recolor_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleImageRecolorOpa(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_line_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleLineWidth(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_line_dash_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleLineDashWidth(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_line_dash_gap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleLineDashGap(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_line_rounded", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleLineRounded(__IntPtr obj, bool value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_line_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleLineColor(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_line_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleLineOpa(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_arc_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleArcWidth(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_arc_rounded", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleArcRounded(__IntPtr obj, bool value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_arc_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleArcColor(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_arc_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleArcOpa(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_arc_image_src", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleArcImageSrc(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_text_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTextColor(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_text_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTextOpa(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_text_font", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTextFont(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_text_letter_space", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTextLetterSpace(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_text_line_space", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTextLineSpace(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_text_decor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTextDecor(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_text_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTextAlign(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_radius", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleRadius(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_clip_corner", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleClipCorner(__IntPtr obj, bool value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleOpa(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_opa_layered", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleOpaLayered(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_color_filter_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleColorFilterDsc(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_color_filter_opa", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleColorFilterOpa(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_anim", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleAnim(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_anim_duration", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleAnimDuration(__IntPtr obj, uint value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_transition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleTransition(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_blend_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBlendMode(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_layout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleLayout(__IntPtr obj, ushort value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_base_dir", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBaseDir(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_bitmap_mask_src", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleBitmapMaskSrc(__IntPtr obj, __IntPtr value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_rotary_sensitivity", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleRotarySensitivity(__IntPtr obj, uint value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_flex_flow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleFlexFlow(__IntPtr obj, global::lvgl.LvFlexFlowT value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_flex_main_place", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleFlexMainPlace(__IntPtr obj, global::lvgl.LvFlexAlignT value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_flex_cross_place", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleFlexCrossPlace(__IntPtr obj, global::lvgl.LvFlexAlignT value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_flex_track_place", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleFlexTrackPlace(__IntPtr obj, global::lvgl.LvFlexAlignT value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_flex_grow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleFlexGrow(__IntPtr obj, byte value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_grid_column_dsc_array", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleGridColumnDscArray(__IntPtr obj, int* value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_grid_column_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleGridColumnAlign(__IntPtr obj, global::lvgl.LvGridAlignT value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_grid_row_dsc_array", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleGridRowDscArray(__IntPtr obj, int* value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_grid_row_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleGridRowAlign(__IntPtr obj, global::lvgl.LvGridAlignT value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_grid_cell_column_pos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleGridCellColumnPos(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_grid_cell_x_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleGridCellXAlign(__IntPtr obj, global::lvgl.LvGridAlignT value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_grid_cell_column_span", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleGridCellColumnSpan(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_grid_cell_row_pos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleGridCellRowPos(__IntPtr obj, int value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_grid_cell_y_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleGridCellYAlign(__IntPtr obj, global::lvgl.LvGridAlignT value, uint selector);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_set_style_grid_cell_row_span", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjSetStyleGridCellRowSpan(__IntPtr obj, int value, uint selector);
        }

        public static void LvObjSetStyleWidth(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleWidth(__arg0, value, selector);
        }

        public static void LvObjSetStyleMinWidth(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleMinWidth(__arg0, value, selector);
        }

        public static void LvObjSetStyleMaxWidth(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleMaxWidth(__arg0, value, selector);
        }

        public static void LvObjSetStyleHeight(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleHeight(__arg0, value, selector);
        }

        public static void LvObjSetStyleMinHeight(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleMinHeight(__arg0, value, selector);
        }

        public static void LvObjSetStyleMaxHeight(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleMaxHeight(__arg0, value, selector);
        }

        public static void LvObjSetStyleLength(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleLength(__arg0, value, selector);
        }

        public static void LvObjSetStyleX(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleX(__arg0, value, selector);
        }

        public static void LvObjSetStyleY(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleY(__arg0, value, selector);
        }

        public static void LvObjSetStyleAlign(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleAlign(__arg0, value, selector);
        }

        public static void LvObjSetStyleTransformWidth(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleTransformWidth(__arg0, value, selector);
        }

        public static void LvObjSetStyleTransformHeight(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleTransformHeight(__arg0, value, selector);
        }

        public static void LvObjSetStyleTranslateX(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleTranslateX(__arg0, value, selector);
        }

        public static void LvObjSetStyleTranslateY(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleTranslateY(__arg0, value, selector);
        }

        public static void LvObjSetStyleTransformScaleX(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleTransformScaleX(__arg0, value, selector);
        }

        public static void LvObjSetStyleTransformScaleY(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleTransformScaleY(__arg0, value, selector);
        }

        public static void LvObjSetStyleTransformRotation(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleTransformRotation(__arg0, value, selector);
        }

        public static void LvObjSetStyleTransformPivotX(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleTransformPivotX(__arg0, value, selector);
        }

        public static void LvObjSetStyleTransformPivotY(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleTransformPivotY(__arg0, value, selector);
        }

        public static void LvObjSetStyleTransformSkewX(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleTransformSkewX(__arg0, value, selector);
        }

        public static void LvObjSetStyleTransformSkewY(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleTransformSkewY(__arg0, value, selector);
        }

        public static void LvObjSetStylePadTop(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStylePadTop(__arg0, value, selector);
        }

        public static void LvObjSetStylePadBottom(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStylePadBottom(__arg0, value, selector);
        }

        public static void LvObjSetStylePadLeft(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStylePadLeft(__arg0, value, selector);
        }

        public static void LvObjSetStylePadRight(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStylePadRight(__arg0, value, selector);
        }

        public static void LvObjSetStylePadRow(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStylePadRow(__arg0, value, selector);
        }

        public static void LvObjSetStylePadColumn(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStylePadColumn(__arg0, value, selector);
        }

        public static void LvObjSetStyleMarginTop(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleMarginTop(__arg0, value, selector);
        }

        public static void LvObjSetStyleMarginBottom(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleMarginBottom(__arg0, value, selector);
        }

        public static void LvObjSetStyleMarginLeft(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleMarginLeft(__arg0, value, selector);
        }

        public static void LvObjSetStyleMarginRight(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleMarginRight(__arg0, value, selector);
        }

        public static void LvObjSetStyleBgColor(global::lvgl.LvObjT obj, global::lvgl.LvColorT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvObjSetStyleBgColor(__arg0, __arg1, selector);
        }

        public static void LvObjSetStyleBgOpa(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleBgOpa(__arg0, value, selector);
        }

        public static void LvObjSetStyleBgGradColor(global::lvgl.LvObjT obj, global::lvgl.LvColorT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvObjSetStyleBgGradColor(__arg0, __arg1, selector);
        }

        public static void LvObjSetStyleBgGradDir(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleBgGradDir(__arg0, value, selector);
        }

        public static void LvObjSetStyleBgMainStop(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleBgMainStop(__arg0, value, selector);
        }

        public static void LvObjSetStyleBgGradStop(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleBgGradStop(__arg0, value, selector);
        }

        public static void LvObjSetStyleBgMainOpa(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleBgMainOpa(__arg0, value, selector);
        }

        public static void LvObjSetStyleBgGradOpa(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleBgGradOpa(__arg0, value, selector);
        }

        public static void LvObjSetStyleBgGrad(global::lvgl.LvObjT obj, global::lvgl.LvGradDscT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = value is null ? __IntPtr.Zero : value.__Instance;
            __Internal.LvObjSetStyleBgGrad(__arg0, __arg1, selector);
        }

        public static void LvObjSetStyleBgImageSrc(global::lvgl.LvObjT obj, __IntPtr value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleBgImageSrc(__arg0, value, selector);
        }

        public static void LvObjSetStyleBgImageOpa(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleBgImageOpa(__arg0, value, selector);
        }

        public static void LvObjSetStyleBgImageRecolor(global::lvgl.LvObjT obj, global::lvgl.LvColorT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvObjSetStyleBgImageRecolor(__arg0, __arg1, selector);
        }

        public static void LvObjSetStyleBgImageRecolorOpa(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleBgImageRecolorOpa(__arg0, value, selector);
        }

        public static void LvObjSetStyleBgImageTiled(global::lvgl.LvObjT obj, bool value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleBgImageTiled(__arg0, value, selector);
        }

        public static void LvObjSetStyleBorderColor(global::lvgl.LvObjT obj, global::lvgl.LvColorT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvObjSetStyleBorderColor(__arg0, __arg1, selector);
        }

        public static void LvObjSetStyleBorderOpa(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleBorderOpa(__arg0, value, selector);
        }

        public static void LvObjSetStyleBorderWidth(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleBorderWidth(__arg0, value, selector);
        }

        public static void LvObjSetStyleBorderSide(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleBorderSide(__arg0, value, selector);
        }

        public static void LvObjSetStyleBorderPost(global::lvgl.LvObjT obj, bool value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleBorderPost(__arg0, value, selector);
        }

        public static void LvObjSetStyleOutlineWidth(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleOutlineWidth(__arg0, value, selector);
        }

        public static void LvObjSetStyleOutlineColor(global::lvgl.LvObjT obj, global::lvgl.LvColorT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvObjSetStyleOutlineColor(__arg0, __arg1, selector);
        }

        public static void LvObjSetStyleOutlineOpa(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleOutlineOpa(__arg0, value, selector);
        }

        public static void LvObjSetStyleOutlinePad(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleOutlinePad(__arg0, value, selector);
        }

        public static void LvObjSetStyleShadowWidth(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleShadowWidth(__arg0, value, selector);
        }

        public static void LvObjSetStyleShadowOffsetX(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleShadowOffsetX(__arg0, value, selector);
        }

        public static void LvObjSetStyleShadowOffsetY(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleShadowOffsetY(__arg0, value, selector);
        }

        public static void LvObjSetStyleShadowSpread(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleShadowSpread(__arg0, value, selector);
        }

        public static void LvObjSetStyleShadowColor(global::lvgl.LvObjT obj, global::lvgl.LvColorT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvObjSetStyleShadowColor(__arg0, __arg1, selector);
        }

        public static void LvObjSetStyleShadowOpa(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleShadowOpa(__arg0, value, selector);
        }

        public static void LvObjSetStyleImageOpa(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleImageOpa(__arg0, value, selector);
        }

        public static void LvObjSetStyleImageRecolor(global::lvgl.LvObjT obj, global::lvgl.LvColorT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvObjSetStyleImageRecolor(__arg0, __arg1, selector);
        }

        public static void LvObjSetStyleImageRecolorOpa(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleImageRecolorOpa(__arg0, value, selector);
        }

        public static void LvObjSetStyleLineWidth(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleLineWidth(__arg0, value, selector);
        }

        public static void LvObjSetStyleLineDashWidth(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleLineDashWidth(__arg0, value, selector);
        }

        public static void LvObjSetStyleLineDashGap(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleLineDashGap(__arg0, value, selector);
        }

        public static void LvObjSetStyleLineRounded(global::lvgl.LvObjT obj, bool value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleLineRounded(__arg0, value, selector);
        }

        public static void LvObjSetStyleLineColor(global::lvgl.LvObjT obj, global::lvgl.LvColorT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvObjSetStyleLineColor(__arg0, __arg1, selector);
        }

        public static void LvObjSetStyleLineOpa(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleLineOpa(__arg0, value, selector);
        }

        public static void LvObjSetStyleArcWidth(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleArcWidth(__arg0, value, selector);
        }

        public static void LvObjSetStyleArcRounded(global::lvgl.LvObjT obj, bool value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleArcRounded(__arg0, value, selector);
        }

        public static void LvObjSetStyleArcColor(global::lvgl.LvObjT obj, global::lvgl.LvColorT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvObjSetStyleArcColor(__arg0, __arg1, selector);
        }

        public static void LvObjSetStyleArcOpa(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleArcOpa(__arg0, value, selector);
        }

        public static void LvObjSetStyleArcImageSrc(global::lvgl.LvObjT obj, __IntPtr value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleArcImageSrc(__arg0, value, selector);
        }

        public static void LvObjSetStyleTextColor(global::lvgl.LvObjT obj, global::lvgl.LvColorT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            if (ReferenceEquals(value, null))
                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
            var __arg1 = value.__Instance;
            __Internal.LvObjSetStyleTextColor(__arg0, __arg1, selector);
        }

        public static void LvObjSetStyleTextOpa(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleTextOpa(__arg0, value, selector);
        }

        public static void LvObjSetStyleTextFont(global::lvgl.LvObjT obj, global::lvgl.LvFontT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = value is null ? __IntPtr.Zero : value.__Instance;
            __Internal.LvObjSetStyleTextFont(__arg0, __arg1, selector);
        }

        public static void LvObjSetStyleTextLetterSpace(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleTextLetterSpace(__arg0, value, selector);
        }

        public static void LvObjSetStyleTextLineSpace(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleTextLineSpace(__arg0, value, selector);
        }

        public static void LvObjSetStyleTextDecor(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleTextDecor(__arg0, value, selector);
        }

        public static void LvObjSetStyleTextAlign(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleTextAlign(__arg0, value, selector);
        }

        public static void LvObjSetStyleRadius(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleRadius(__arg0, value, selector);
        }

        public static void LvObjSetStyleClipCorner(global::lvgl.LvObjT obj, bool value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleClipCorner(__arg0, value, selector);
        }

        public static void LvObjSetStyleOpa(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleOpa(__arg0, value, selector);
        }

        public static void LvObjSetStyleOpaLayered(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleOpaLayered(__arg0, value, selector);
        }

        public static void LvObjSetStyleColorFilterDsc(global::lvgl.LvObjT obj, global::lvgl.LvColorFilterDscT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = value is null ? __IntPtr.Zero : value.__Instance;
            __Internal.LvObjSetStyleColorFilterDsc(__arg0, __arg1, selector);
        }

        public static void LvObjSetStyleColorFilterOpa(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleColorFilterOpa(__arg0, value, selector);
        }

        public static void LvObjSetStyleAnim(global::lvgl.LvObjT obj, global::lvgl.LvAnimT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = value is null ? __IntPtr.Zero : value.__Instance;
            __Internal.LvObjSetStyleAnim(__arg0, __arg1, selector);
        }

        public static void LvObjSetStyleAnimDuration(global::lvgl.LvObjT obj, uint value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleAnimDuration(__arg0, value, selector);
        }

        public static void LvObjSetStyleTransition(global::lvgl.LvObjT obj, global::lvgl.LvStyleTransitionDscT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = value is null ? __IntPtr.Zero : value.__Instance;
            __Internal.LvObjSetStyleTransition(__arg0, __arg1, selector);
        }

        public static void LvObjSetStyleBlendMode(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleBlendMode(__arg0, value, selector);
        }

        public static void LvObjSetStyleLayout(global::lvgl.LvObjT obj, ushort value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleLayout(__arg0, value, selector);
        }

        public static void LvObjSetStyleBaseDir(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleBaseDir(__arg0, value, selector);
        }

        public static void LvObjSetStyleBitmapMaskSrc(global::lvgl.LvObjT obj, __IntPtr value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleBitmapMaskSrc(__arg0, value, selector);
        }

        public static void LvObjSetStyleRotarySensitivity(global::lvgl.LvObjT obj, uint value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleRotarySensitivity(__arg0, value, selector);
        }

        public static void LvObjSetStyleFlexFlow(global::lvgl.LvObjT obj, global::lvgl.LvFlexFlowT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleFlexFlow(__arg0, value, selector);
        }

        public static void LvObjSetStyleFlexMainPlace(global::lvgl.LvObjT obj, global::lvgl.LvFlexAlignT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleFlexMainPlace(__arg0, value, selector);
        }

        public static void LvObjSetStyleFlexCrossPlace(global::lvgl.LvObjT obj, global::lvgl.LvFlexAlignT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleFlexCrossPlace(__arg0, value, selector);
        }

        public static void LvObjSetStyleFlexTrackPlace(global::lvgl.LvObjT obj, global::lvgl.LvFlexAlignT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleFlexTrackPlace(__arg0, value, selector);
        }

        public static void LvObjSetStyleFlexGrow(global::lvgl.LvObjT obj, byte value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleFlexGrow(__arg0, value, selector);
        }

        public static void LvObjSetStyleGridColumnDscArray(global::lvgl.LvObjT obj, ref int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            fixed (int* __value1 = &value)
            {
                var __arg1 = __value1;
                __Internal.LvObjSetStyleGridColumnDscArray(__arg0, __arg1, selector);
            }
        }

        public static void LvObjSetStyleGridColumnAlign(global::lvgl.LvObjT obj, global::lvgl.LvGridAlignT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleGridColumnAlign(__arg0, value, selector);
        }

        public static void LvObjSetStyleGridRowDscArray(global::lvgl.LvObjT obj, ref int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            fixed (int* __value1 = &value)
            {
                var __arg1 = __value1;
                __Internal.LvObjSetStyleGridRowDscArray(__arg0, __arg1, selector);
            }
        }

        public static void LvObjSetStyleGridRowAlign(global::lvgl.LvObjT obj, global::lvgl.LvGridAlignT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleGridRowAlign(__arg0, value, selector);
        }

        public static void LvObjSetStyleGridCellColumnPos(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleGridCellColumnPos(__arg0, value, selector);
        }

        public static void LvObjSetStyleGridCellXAlign(global::lvgl.LvObjT obj, global::lvgl.LvGridAlignT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleGridCellXAlign(__arg0, value, selector);
        }

        public static void LvObjSetStyleGridCellColumnSpan(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleGridCellColumnSpan(__arg0, value, selector);
        }

        public static void LvObjSetStyleGridCellRowPos(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleGridCellRowPos(__arg0, value, selector);
        }

        public static void LvObjSetStyleGridCellYAlign(global::lvgl.LvObjT obj, global::lvgl.LvGridAlignT value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleGridCellYAlign(__arg0, value, selector);
        }

        public static void LvObjSetStyleGridCellRowSpan(global::lvgl.LvObjT obj, int value, uint selector)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjSetStyleGridCellRowSpan(__arg0, value, selector);
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public enum LvLayerTypeT
    {
        LV_LAYER_TYPE_NONE = 0,
        LV_LAYER_TYPE_SIMPLE = 1,
        LV_LAYER_TYPE_TRANSFORM = 2
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class lv_obj_draw
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_init_draw_rect_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjInitDrawRectDsc(__IntPtr obj, uint part, __IntPtr draw_dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_init_draw_label_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjInitDrawLabelDsc(__IntPtr obj, uint part, __IntPtr draw_dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_init_draw_image_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjInitDrawImageDsc(__IntPtr obj, uint part, __IntPtr draw_dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_init_draw_line_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjInitDrawLineDsc(__IntPtr obj, uint part, __IntPtr draw_dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_init_draw_arc_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjInitDrawArcDsc(__IntPtr obj, uint part, __IntPtr draw_dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_calculate_ext_draw_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjCalculateExtDrawSize(__IntPtr obj, uint part);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_refresh_ext_draw_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjRefreshExtDrawSize(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_obj_get_ext_draw_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvObjGetExtDrawSize(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_obj_get_layer_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::lvgl.LvLayerTypeT LvObjGetLayerType(__IntPtr obj);
        }

        /// <summary>Initialize a rectangle draw descriptor from an object's styles in its current state</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="part">part of the object, e.g. `LV_PART_MAIN`, `LV_PART_SCROLLBAR`, `LV_PART_KNOB`, etc</param>
        /// <param name="draw_dsc">
        /// <para>the descriptor to initialize.</para>
        /// <para>If an `..._opa` field is set to `LV_OPA_TRANSP` the related properties won't be initialized.</para>
        /// <para>Should be initialized with `lv_draw_rect_dsc_init(draw_dsc)`.</para>
        /// </param>
        /// <remarks>
        /// <para>Only the relevant fields will be set.</para>
        /// <para>E.g. if `border width == 0` the other border properties won't be evaluated.</para>
        /// </remarks>
        public static void LvObjInitDrawRectDsc(global::lvgl.LvObjT obj, uint part, global::lvgl.LvDrawRectDscT draw_dsc)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg2 = draw_dsc is null ? __IntPtr.Zero : draw_dsc.__Instance;
            __Internal.LvObjInitDrawRectDsc(__arg0, part, __arg2);
        }

        /// <summary>Initialize a label draw descriptor from an object's styles in its current state</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="part">part of the object, e.g. `LV_PART_MAIN`, `LV_PART_SCROLLBAR`, `LV_PART_KNOB`, etc</param>
        /// <param name="draw_dsc">
        /// <para>the descriptor to initialize.</para>
        /// <para>If the `opa` field is set to or the property is equal to `LV_OPA_TRANSP` the rest won't be initialized.</para>
        /// <para>Should be initialized with `lv_draw_label_dsc_init(draw_dsc)`.</para>
        /// </param>
        public static void LvObjInitDrawLabelDsc(global::lvgl.LvObjT obj, uint part, global::lvgl.LvDrawLabelDscT draw_dsc)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg2 = draw_dsc is null ? __IntPtr.Zero : draw_dsc.__Instance;
            __Internal.LvObjInitDrawLabelDsc(__arg0, part, __arg2);
        }

        /// <summary>Initialize an image draw descriptor from an object's styles in its current state</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="part">part of the object, e.g. `LV_PART_MAIN`, `LV_PART_SCROLLBAR`, `LV_PART_KNOB`, etc</param>
        /// <param name="draw_dsc">
        /// <para>the descriptor to initialize.</para>
        /// <para>Should be initialized with `lv_draw_image_dsc_init(draw_dsc)`.</para>
        /// </param>
        public static void LvObjInitDrawImageDsc(global::lvgl.LvObjT obj, uint part, global::lvgl.LvDrawImageDscT draw_dsc)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg2 = draw_dsc is null ? __IntPtr.Zero : draw_dsc.__Instance;
            __Internal.LvObjInitDrawImageDsc(__arg0, part, __arg2);
        }

        /// <summary>Initialize a line draw descriptor from an object's styles in its current state</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="part">part of the object, e.g. `LV_PART_MAIN`, `LV_PART_SCROLLBAR`, `LV_PART_KNOB`, etc</param>
        /// <param name="draw_dsc">
        /// <para>the descriptor to initialize.</para>
        /// <para>Should be initialized with `lv_draw_line_dsc_init(draw_dsc)`.</para>
        /// </param>
        public static void LvObjInitDrawLineDsc(global::lvgl.LvObjT obj, uint part, global::lvgl.LvDrawLineDscT draw_dsc)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg2 = draw_dsc is null ? __IntPtr.Zero : draw_dsc.__Instance;
            __Internal.LvObjInitDrawLineDsc(__arg0, part, __arg2);
        }

        /// <summary>Initialize an arc draw descriptor from an object's styles in its current state</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="part">part of the object, e.g. `LV_PART_MAIN`, `LV_PART_SCROLLBAR`, `LV_PART_KNOB`, etc</param>
        /// <param name="draw_dsc">
        /// <para>the descriptor to initialize.</para>
        /// <para>Should be initialized with `lv_draw_arc_dsc_init(draw_dsc)`.</para>
        /// </param>
        public static void LvObjInitDrawArcDsc(global::lvgl.LvObjT obj, uint part, global::lvgl.LvDrawArcDscT draw_dsc)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg2 = draw_dsc is null ? __IntPtr.Zero : draw_dsc.__Instance;
            __Internal.LvObjInitDrawArcDsc(__arg0, part, __arg2);
        }

        /// <summary>Get the required extra size (around the object's part) to draw shadow, outline, value etc.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="part">part of the object</param>
        /// <returns>the extra size required around the object</returns>
        public static int LvObjCalculateExtDrawSize(global::lvgl.LvObjT obj, uint part)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjCalculateExtDrawSize(__arg0, part);
            return ___ret;
        }

        /// <summary>
        /// <para>Send a 'LV_EVENT_REFR_EXT_DRAW_SIZE' Call the ancestor's event handler to the object to refresh the value of the extended draw size.</para>
        /// <para>The result will be saved in `obj`.</para>
        /// </summary>
        /// <param name="obj">pointer to an object</param>
        public static void LvObjRefreshExtDrawSize(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjRefreshExtDrawSize(__arg0);
        }

        /// <summary>Get the extended draw area of an object.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the size extended draw area around the real coordinates</returns>
        public static int LvObjGetExtDrawSize(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetExtDrawSize(__arg0);
            return ___ret;
        }

        public static global::lvgl.LvLayerTypeT LvObjGetLayerType(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetLayerType(__arg0);
            return ___ret;
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public enum LvObjClassEditableT
    {
        /// <summary>Check the base class. Must have 0 value to let zero initialized class inherit</summary>
        LV_OBJ_CLASS_EDITABLE_INHERIT = 0,
        LV_OBJ_CLASS_EDITABLE_TRUE = 1,
        LV_OBJ_CLASS_EDITABLE_FALSE = 2
    }

    public enum LvObjClassGroupDefT
    {
        /// <summary>Check the base class. Must have 0 value to let zero initialized class inherit</summary>
        LV_OBJ_CLASS_GROUP_DEF_INHERIT = 0,
        LV_OBJ_CLASS_GROUP_DEF_TRUE = 1,
        LV_OBJ_CLASS_GROUP_DEF_FALSE = 2
    }

    public enum LvObjClassThemeInheritableT
    {
        /// <summary>Do not inherit theme from base class.</summary>
        LV_OBJ_CLASS_THEME_INHERITABLE_FALSE = 0,
        LV_OBJ_CLASS_THEME_INHERITABLE_TRUE = 1
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvObjClassEventCbT(__IntPtr class_p, __IntPtr e);

    /// <summary>
    /// <para>Describe the common methods of every object.</para>
    /// <para>Similar to a C++ class.</para>
    /// </summary>
    public unsafe partial class LvObjClassT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr base_class;

            [FieldOffset(8)]
            internal __IntPtr constructor_cb;

            [FieldOffset(16)]
            internal __IntPtr destructor_cb;

            [FieldOffset(24)]
            internal __IntPtr event_cb;

            [FieldOffset(32)]
            internal __IntPtr user_data;

            [FieldOffset(40)]
            internal __IntPtr name;

            [FieldOffset(48)]
            internal int width_def;

            [FieldOffset(52)]
            internal int height_def;

            [FieldOffset(56)]
            internal uint editable;

            [FieldOffset(56)]
            internal uint group_def;

            [FieldOffset(56)]
            internal uint instance_size;

            [FieldOffset(58)]
            internal uint theme_inheritable;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_obj_class_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvObjClassT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvObjClassT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvObjClassT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvObjClassT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __name_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static LvObjClassT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvObjClassT(native.ToPointer(), skipVTables);
        }

        internal static LvObjClassT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvObjClassT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvObjClassT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvObjClassT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvObjClassT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvObjClassT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvObjClassT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvObjClassT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvObjClassT(global::lvgl.LvObjClassT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvObjClassT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvObjClassT.__Internal*) __Instance) = *((global::lvgl.LvObjClassT.__Internal*) _0.__Instance);
            if (_0.__name_OwnsNativeMemory)
                this.Name = _0.Name;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjClassT BaseClass
        {
            get
            {
                var __result0 = global::lvgl.LvObjClassT.__GetOrCreateInstance(((__Internal*)__Instance)->base_class, false);
                return __result0;
            }
        }

        public global::lvgl.Delegates.Action___IntPtr___IntPtr ConstructorCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->constructor_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->constructor_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::lvgl.Delegates.Action___IntPtr___IntPtr DestructorCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->destructor_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->destructor_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Widget type specific event function</summary>
        public global::lvgl.Delegates.Action___IntPtr___IntPtr EventCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->event_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->event_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }

        public string Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->name);
            }

            set
            {
                if (__name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                __name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->name = (__IntPtr) __bytePtr0;
            }
        }

        public int WidthDef
        {
            get
            {
                return ((__Internal*)__Instance)->width_def;
            }

            set
            {
                ((__Internal*)__Instance)->width_def = value;
            }
        }

        public int HeightDef
        {
            get
            {
                return ((__Internal*)__Instance)->height_def;
            }

            set
            {
                ((__Internal*)__Instance)->height_def = value;
            }
        }

        /// <summary>Value from ::lv_obj_class_editable_t</summary>
        public uint Editable
        {
            get
            {
                return ((__Internal*)__Instance)->editable;
            }

            set
            {
                ((__Internal*)__Instance)->editable = value;
            }
        }

        /// <summary>Value from ::lv_obj_class_group_def_t</summary>
        public uint GroupDef
        {
            get
            {
                return ((__Internal*)__Instance)->group_def;
            }

            set
            {
                ((__Internal*)__Instance)->group_def = value;
            }
        }

        public uint InstanceSize
        {
            get
            {
                return ((__Internal*)__Instance)->instance_size;
            }

            set
            {
                ((__Internal*)__Instance)->instance_size = value;
            }
        }

        /// <summary>Value from ::lv_obj_class_theme_inheritable_t</summary>
        public uint ThemeInheritable
        {
            get
            {
                return ((__Internal*)__Instance)->theme_inheritable;
            }

            set
            {
                ((__Internal*)__Instance)->theme_inheritable = value;
            }
        }
    }

    public unsafe partial class lv_obj_class
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_class_create_obj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjClassCreateObj(__IntPtr class_p, __IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_class_init_obj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjClassInitObj(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_obj_destruct", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjDestruct(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_is_editable", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjIsEditable(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_is_group_def", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjIsGroupDef(__IntPtr obj);
        }

        /// <summary>Create an object form a class descriptor</summary>
        /// <param name="class_p">pointer to a class</param>
        /// <param name="parent">pointer to an object where the new object should be created</param>
        /// <returns>pointer to the created object</returns>
        public static global::lvgl.LvObjT LvObjClassCreateObj(global::lvgl.LvObjClassT class_p, global::lvgl.LvObjT parent)
        {
            var __arg0 = class_p is null ? __IntPtr.Zero : class_p.__Instance;
            var __arg1 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvObjClassCreateObj(__arg0, __arg1);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static void LvObjClassInitObj(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjClassInitObj(__arg0);
        }

        public static void LvObjDestruct(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjDestruct(__arg0);
        }

        public static bool LvObjIsEditable(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjIsEditable(__arg0);
            return ___ret;
        }

        public static bool LvObjIsGroupDef(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjIsGroupDef(__arg0);
            return ___ret;
        }
    }

    /// <summary>Cover check results.</summary>
    public enum LvCoverResT
    {
        LV_COVER_RES_COVER = 0,
        LV_COVER_RES_NOT_COVER = 1,
        LV_COVER_RES_MASKED = 2
    }

    /// <summary>
    /// <para>Used as the event parameter of ::LV_EVENT_HIT_TEST to check if an `point` can click the object or not.</para>
    /// <para>`res` should be set like this:</para>
    /// <para>- If already set to `false` an other event wants that point non clickable. If you want to respect it leave it as `false` or set `true` to overwrite it.</para>
    /// <para>- If already set `true` and `point` shouldn't be clickable set to `false`</para>
    /// <para>- If already set to `true` you agree that `point` can click the object leave it as `true`</para>
    /// </summary>
    /// <summary>Cover check results.</summary>
    /// <summary>
    /// <para>Used as the event parameter of ::LV_EVENT_COVER_CHECK to check if an area is covered by the object or not.</para>
    /// <para>In the event use `const lv_area_t * area = lv_event_get_cover_area(e)` to get the area to check</para>
    /// <para>and `lv_event_set_cover_res(e, res)` to set the result.</para>
    /// </summary>
    /// <summary>
    /// <para>Used as the event parameter of ::LV_EVENT_HIT_TEST to check if an `point` can click the object or not.</para>
    /// <para>`res` should be set like this:</para>
    /// <para>- If already set to `false` an other event wants that point non clickable. If you want to respect it leave it as `false` or set `true` to overwrite it.</para>
    /// <para>- If already set `true` and `point` shouldn't be clickable set to `false`</para>
    /// <para>- If already set to `true` you agree that `point` can click the object leave it as `true`</para>
    /// </summary>
    public unsafe partial class LvHitTestInfoT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr point;
            internal byte res;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_hit_test_info_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvHitTestInfoT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvHitTestInfoT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvHitTestInfoT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvHitTestInfoT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvHitTestInfoT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvHitTestInfoT(native.ToPointer(), skipVTables);
        }

        internal static LvHitTestInfoT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvHitTestInfoT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvHitTestInfoT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvHitTestInfoT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvHitTestInfoT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvHitTestInfoT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvHitTestInfoT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvHitTestInfoT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvHitTestInfoT(global::lvgl.LvHitTestInfoT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvHitTestInfoT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvHitTestInfoT.__Internal*) __Instance) = *((global::lvgl.LvHitTestInfoT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>A point relative to screen to check if it can click the object or not</summary>
        public global::lvgl.LvPointT Point
        {
            get
            {
                var __result0 = global::lvgl.LvPointT.__GetOrCreateInstance(((__Internal*)__Instance)->point, false);
                return __result0;
            }
        }

        /// <summary>true: `point` can click the object; false: it cannot</summary>
        public bool Res
        {
            get
            {
                return ((__Internal*)__Instance)->res != 0;
            }

            set
            {
                ((__Internal*)__Instance)->res = (byte) (value ? 1 : 0);
            }
        }
    }

    /// <summary>
    /// <para>Used as the event parameter of ::LV_EVENT_COVER_CHECK to check if an area is covered by the object or not.</para>
    /// <para>In the event use `const lv_area_t * area = lv_event_get_cover_area(e)` to get the area to check</para>
    /// <para>and `lv_event_set_cover_res(e, res)` to set the result.</para>
    /// </summary>
    public unsafe partial class LvCoverCheckInfoT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal global::lvgl.LvCoverResT res;
            internal __IntPtr area;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_cover_check_info_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvCoverCheckInfoT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvCoverCheckInfoT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvCoverCheckInfoT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvCoverCheckInfoT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvCoverCheckInfoT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvCoverCheckInfoT(native.ToPointer(), skipVTables);
        }

        internal static LvCoverCheckInfoT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvCoverCheckInfoT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvCoverCheckInfoT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvCoverCheckInfoT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvCoverCheckInfoT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvCoverCheckInfoT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvCoverCheckInfoT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvCoverCheckInfoT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvCoverCheckInfoT(global::lvgl.LvCoverCheckInfoT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvCoverCheckInfoT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvCoverCheckInfoT.__Internal*) __Instance) = *((global::lvgl.LvCoverCheckInfoT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvCoverResT Res
        {
            get
            {
                return ((__Internal*)__Instance)->res;
            }

            set
            {
                ((__Internal*)__Instance)->res = value;
            }
        }

        public global::lvgl.LvAreaT Area
        {
            get
            {
                var __result0 = global::lvgl.LvAreaT.__GetOrCreateInstance(((__Internal*)__Instance)->area, false);
                return __result0;
            }
        }
    }

    public unsafe partial class lv_obj_event
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_send_event", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvObjSendEvent(__IntPtr obj, global::lvgl.LvEventCodeT event_code, __IntPtr param);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_event_base", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvObjEventBase(__IntPtr class_p, __IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_current_target_obj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventGetCurrentTargetObj(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_target_obj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventGetTargetObj(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_add_event_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjAddEventCb(__IntPtr obj, __IntPtr event_cb, global::lvgl.LvEventCodeT filter, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_event_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvObjGetEventCount(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_get_event_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjGetEventDsc(__IntPtr obj, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_remove_event", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjRemoveEvent(__IntPtr obj, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_remove_event_cb", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjRemoveEventCb(__IntPtr obj, __IntPtr event_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_remove_event_dsc", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvObjRemoveEventDsc(__IntPtr obj, __IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_remove_event_cb_with_user_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvObjRemoveEventCbWithUserData(__IntPtr obj, __IntPtr event_cb, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_indev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventGetIndev(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_layer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventGetLayer(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_old_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventGetOldSize(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_key", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvEventGetKey(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_rotary_diff", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvEventGetRotaryDiff(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_scroll_anim", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventGetScrollAnim(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_set_ext_draw_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvEventSetExtDrawSize(__IntPtr e, int size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_self_size_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventGetSelfSizeInfo(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_hit_test_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventGetHitTestInfo(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_cover_area", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventGetCoverArea(__IntPtr e);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_set_cover_res", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvEventSetCoverRes(__IntPtr e, global::lvgl.LvCoverResT res);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_event_get_draw_task", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvEventGetDrawTask(__IntPtr e);
        }

        /// <summary>Send an event to the object</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="event_code">the type of the event from `lv_event_t`</param>
        /// <param name="param">arbitrary data depending on the widget type and the event. (Usually `NULL`)</param>
        /// <returns>LV_RESULT_OK: `obj` was not deleted in the event; LV_RESULT_INVALID: `obj` was deleted in the event_code</returns>
        public static byte LvObjSendEvent(global::lvgl.LvObjT obj, global::lvgl.LvEventCodeT event_code, __IntPtr param)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjSendEvent(__arg0, event_code, param);
            return ___ret;
        }

        /// <summary>Used by the widgets internally to call the ancestor widget types's event handler</summary>
        /// <param name="class_p">pointer to the class of the widget (NOT the ancestor class)</param>
        /// <param name="e">pointer to the event descriptor</param>
        /// <returns>LV_RESULT_OK: the target object was not deleted in the event; LV_RESULT_INVALID: it was deleted in the event_code</returns>
        public static byte LvObjEventBase(global::lvgl.LvObjClassT class_p, global::lvgl.LvEventT e)
        {
            var __arg0 = class_p is null ? __IntPtr.Zero : class_p.__Instance;
            var __arg1 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvObjEventBase(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>
        /// <para>Get the current target of the event. It's the object which event handler being called.</para>
        /// <para>If the event is not bubbled it's the same as &quot;original&quot; target.</para>
        /// </summary>
        /// <param name="e">pointer to the event descriptor</param>
        /// <returns>the target of the event_code</returns>
        public static global::lvgl.LvObjT LvEventGetCurrentTargetObj(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventGetCurrentTargetObj(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the object originally targeted by the event. It's the same even if the event is bubbled.</summary>
        /// <param name="e">pointer to the event descriptor</param>
        /// <returns>pointer to the original target of the event_code</returns>
        public static global::lvgl.LvObjT LvEventGetTargetObj(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventGetTargetObj(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Add an event handler function for an object.</para>
        /// <para>Used by the user to react on event which happens with the object.</para>
        /// <para>An object can have multiple event handler. They will be called in the same order as they were added.</para>
        /// </summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="filter">an event code (e.g. `LV_EVENT_CLICKED`) on which the event should be called. `LV_EVENT_ALL` can be used to receive all the events.</param>
        /// <param name="event_cb">the new event function</param>
        /// <param name="user_data">custom data data will be available in `event_cb`</param>
        /// <returns>handler to the event. It can be used in `lv_obj_remove_event_dsc`.</returns>
        public static global::lvgl.LvEventDscT LvObjAddEventCb(global::lvgl.LvObjT obj, global::lvgl.LvEventCbT event_cb, global::lvgl.LvEventCodeT filter, __IntPtr user_data)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = event_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(event_cb);
            var ___ret = __Internal.LvObjAddEventCb(__arg0, __arg1, filter, user_data);
            var __result0 = global::lvgl.LvEventDscT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static uint LvObjGetEventCount(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetEventCount(__arg0);
            return ___ret;
        }

        public static global::lvgl.LvEventDscT LvObjGetEventDsc(global::lvgl.LvObjT obj, uint index)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjGetEventDsc(__arg0, index);
            var __result0 = global::lvgl.LvEventDscT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static bool LvObjRemoveEvent(global::lvgl.LvObjT obj, uint index)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvObjRemoveEvent(__arg0, index);
            return ___ret;
        }

        public static bool LvObjRemoveEventCb(global::lvgl.LvObjT obj, global::lvgl.LvEventCbT event_cb)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = event_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(event_cb);
            var ___ret = __Internal.LvObjRemoveEventCb(__arg0, __arg1);
            return ___ret;
        }

        public static bool LvObjRemoveEventDsc(global::lvgl.LvObjT obj, global::lvgl.LvEventDscT dsc)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var ___ret = __Internal.LvObjRemoveEventDsc(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Remove an event_cb with user_data</summary>
        /// <param name="obj">pointer to a obj</param>
        /// <param name="event_cb">the event_cb of the event to remove</param>
        /// <param name="user_data">user_data</param>
        /// <returns>the count of the event removed</returns>
        public static uint LvObjRemoveEventCbWithUserData(global::lvgl.LvObjT obj, global::lvgl.LvEventCbT event_cb, __IntPtr user_data)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = event_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(event_cb);
            var ___ret = __Internal.LvObjRemoveEventCbWithUserData(__arg0, __arg1, user_data);
            return ___ret;
        }

        /// <summary>Get the input device passed as parameter to indev related events.</summary>
        /// <param name="e">pointer to an event</param>
        /// <returns>the indev that triggered the event or NULL if called on a not indev related event</returns>
        public static global::lvgl.LvIndevT LvEventGetIndev(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventGetIndev(__arg0);
            var __result0 = global::lvgl.LvIndevT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get the draw context which should be the first parameter of the draw functions.</para>
        /// <para>Namely: `LV_EVENT_DRAW_MAIN/POST`, `LV_EVENT_DRAW_MAIN/POST_BEGIN`, `LV_EVENT_DRAW_MAIN/POST_END`</para>
        /// </summary>
        /// <param name="e">pointer to an event</param>
        /// <returns>pointer to a draw context or NULL if called on an unrelated event</returns>
        public static global::lvgl.LvLayerT LvEventGetLayer(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventGetLayer(__arg0);
            var __result0 = global::lvgl.LvLayerT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the old area of the object before its size was changed. Can be used in `LV_EVENT_SIZE_CHANGED`</summary>
        /// <param name="e">pointer to an event</param>
        /// <returns>the old absolute area of the object or NULL if called on an unrelated event</returns>
        public static global::lvgl.LvAreaT LvEventGetOldSize(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventGetOldSize(__arg0);
            var __result0 = global::lvgl.LvAreaT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the key passed as parameter to an event. Can be used in `LV_EVENT_KEY`</summary>
        /// <param name="e">pointer to an event</param>
        /// <returns>the triggering key or NULL if called on an unrelated event</returns>
        public static uint LvEventGetKey(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventGetKey(__arg0);
            return ___ret;
        }

        /// <summary>Get the signed rotary encoder diff. passed as parameter to an event. Can be used in `LV_EVENT_ROTARY`</summary>
        /// <param name="e">pointer to an event</param>
        /// <returns>the triggering key or NULL if called on an unrelated event</returns>
        public static int LvEventGetRotaryDiff(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventGetRotaryDiff(__arg0);
            return ___ret;
        }

        /// <summary>Get the animation descriptor of a scrolling. Can be used in `LV_EVENT_SCROLL_BEGIN`</summary>
        /// <param name="e">pointer to an event</param>
        /// <returns>the animation that will scroll the object. (can be modified as required)</returns>
        public static global::lvgl.LvAnimT LvEventGetScrollAnim(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventGetScrollAnim(__arg0);
            var __result0 = global::lvgl.LvAnimT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the new extra draw size. Can be used in `LV_EVENT_REFR_EXT_DRAW_SIZE`</summary>
        /// <param name="e">pointer to an event</param>
        /// <param name="size">The new extra draw size</param>
        public static void LvEventSetExtDrawSize(global::lvgl.LvEventT e, int size)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            __Internal.LvEventSetExtDrawSize(__arg0, size);
        }

        /// <summary>
        /// <para>Get a pointer to an `lv_point_t` variable in which the self size should be saved (width in `point-&gt;x` and height `point-&gt;y`).</para>
        /// <para>Can be used in `LV_EVENT_GET_SELF_SIZE`</para>
        /// </summary>
        /// <param name="e">pointer to an event</param>
        /// <returns>pointer to `lv_point_t` or NULL if called on an unrelated event</returns>
        public static global::lvgl.LvPointT LvEventGetSelfSizeInfo(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventGetSelfSizeInfo(__arg0);
            var __result0 = global::lvgl.LvPointT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get a pointer to an `lv_hit_test_info_t` variable in which the hit test result should be saved. Can be used in `LV_EVENT_HIT_TEST`</summary>
        /// <param name="e">pointer to an event</param>
        /// <returns>pointer to `lv_hit_test_info_t` or NULL if called on an unrelated event</returns>
        public static global::lvgl.LvHitTestInfoT LvEventGetHitTestInfo(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventGetHitTestInfo(__arg0);
            var __result0 = global::lvgl.LvHitTestInfoT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get a pointer to an area which should be examined whether the object fully covers it or not.</para>
        /// <para>Can be used in `LV_EVENT_HIT_TEST`</para>
        /// </summary>
        /// <param name="e">pointer to an event</param>
        /// <returns>an area with absolute coordinates to check</returns>
        public static global::lvgl.LvAreaT LvEventGetCoverArea(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventGetCoverArea(__arg0);
            var __result0 = global::lvgl.LvAreaT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the result of cover checking. Can be used in `LV_EVENT_COVER_CHECK`</summary>
        /// <param name="e">pointer to an event</param>
        /// <param name="res">an element of ::lv_cover_check_info_t</param>
        public static void LvEventSetCoverRes(global::lvgl.LvEventT e, global::lvgl.LvCoverResT res)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            __Internal.LvEventSetCoverRes(__arg0, res);
        }

        /// <summary>
        /// <para>Get the draw task which was just added.</para>
        /// <para>Can be used in `LV_EVENT_DRAW_TASK_ADDED event`</para>
        /// </summary>
        /// <param name="e">pointer to an event</param>
        /// <returns>the added draw task</returns>
        public static global::lvgl.LvDrawTaskT LvEventGetDrawTask(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            var ___ret = __Internal.LvEventGetDrawTask(__arg0);
            var __result0 = global::lvgl.LvDrawTaskT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>Possible input device types</summary>
    public enum LvIndevTypeT
    {
        /// <summary>Uninitialized state</summary>
        LV_INDEV_TYPE_NONE = 0,
        /// <summary>Touch pad, mouse, external button</summary>
        LV_INDEV_TYPE_POINTER = 1,
        /// <summary>Keypad or keyboard</summary>
        LV_INDEV_TYPE_KEYPAD = 2,
        /// <summary>External (hardware button) which is assigned to a specific point of the screen</summary>
        LV_INDEV_TYPE_BUTTON = 3,
        /// <summary>Encoder with only Left, Right turn and a Button</summary>
        LV_INDEV_TYPE_ENCODER = 4
    }

    /// <summary>States for input devices</summary>
    public enum LvIndevStateT
    {
        LV_INDEV_STATE_RELEASED = 0,
        LV_INDEV_STATE_PRESSED = 1
    }

    public enum LvIndevModeT
    {
        LV_INDEV_MODE_NONE = 0,
        LV_INDEV_MODE_TIMER = 1,
        LV_INDEV_MODE_EVENT = 2
    }

    /// <summary>Possible input device types</summary>
    /// <summary>States for input devices</summary>
    /// <summary>Data structure passed to an input driver to fill</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvIndevReadCbT(__IntPtr indev, __IntPtr data);

    /// <summary>Data structure passed to an input driver to fill</summary>
    public unsafe partial class LvIndevDataT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal global::lvgl.LvPointT.__Internal point;
            internal uint key;
            internal uint btn_id;
            internal short enc_diff;
            internal global::lvgl.LvIndevStateT state;
            internal byte continue_reading;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_indev_data_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvIndevDataT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvIndevDataT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvIndevDataT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvIndevDataT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvIndevDataT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvIndevDataT(native.ToPointer(), skipVTables);
        }

        internal static LvIndevDataT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvIndevDataT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvIndevDataT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvIndevDataT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvIndevDataT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvIndevDataT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvIndevDataT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvIndevDataT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvIndevDataT(global::lvgl.LvIndevDataT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvIndevDataT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvIndevDataT.__Internal*) __Instance) = *((global::lvgl.LvIndevDataT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>For LV_INDEV_TYPE_POINTER the currently pressed point</summary>
        public global::lvgl.LvPointT Point
        {
            get
            {
                return global::lvgl.LvPointT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->point));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->point = *(global::lvgl.LvPointT.__Internal*) value.__Instance;
            }
        }

        /// <summary>For LV_INDEV_TYPE_KEYPAD the currently pressed key</summary>
        public uint Key
        {
            get
            {
                return ((__Internal*)__Instance)->key;
            }

            set
            {
                ((__Internal*)__Instance)->key = value;
            }
        }

        /// <summary>For LV_INDEV_TYPE_BUTTON the currently pressed button</summary>
        public uint BtnId
        {
            get
            {
                return ((__Internal*)__Instance)->btn_id;
            }

            set
            {
                ((__Internal*)__Instance)->btn_id = value;
            }
        }

        /// <summary>For LV_INDEV_TYPE_ENCODER number of steps since the previous read</summary>
        public short EncDiff
        {
            get
            {
                return ((__Internal*)__Instance)->enc_diff;
            }

            set
            {
                ((__Internal*)__Instance)->enc_diff = value;
            }
        }

        /// <summary>LV_INDEV_STATE_RELEASED or LV_INDEV_STATE_PRESSED</summary>
        public global::lvgl.LvIndevStateT State
        {
            get
            {
                return ((__Internal*)__Instance)->state;
            }

            set
            {
                ((__Internal*)__Instance)->state = value;
            }
        }

        /// <summary>If set to true, the read callback is invoked again, unless the device is in event-driven mode</summary>
        public bool ContinueReading
        {
            get
            {
                return ((__Internal*)__Instance)->continue_reading != 0;
            }

            set
            {
                ((__Internal*)__Instance)->continue_reading = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class lv_indev
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvIndevCreate();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_delete", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevDelete(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_next", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvIndevGetNext(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_read", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevRead(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_read_timer_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevReadTimerCb(__IntPtr timer);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_enable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevEnable(__IntPtr indev, bool enable);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_active", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvIndevActive();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_set_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevSetType(__IntPtr indev, global::lvgl.LvIndevTypeT indev_type);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_set_read_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevSetReadCb(__IntPtr indev, __IntPtr read_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_set_user_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevSetUserData(__IntPtr indev, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_set_driver_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevSetDriverData(__IntPtr indev, __IntPtr driver_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_set_display", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevSetDisplay(__IntPtr indev, __IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::lvgl.LvIndevTypeT LvIndevGetType(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_read_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvIndevGetReadCb(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_state", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::lvgl.LvIndevStateT LvIndevGetState(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_group", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvIndevGetGroup(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_display", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvIndevGetDisplay(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_user_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvIndevGetUserData(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_driver_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvIndevGetDriverData(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_reset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevReset(__IntPtr indev, __IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_reset_long_press", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevResetLongPress(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_set_cursor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevSetCursor(__IntPtr indev, __IntPtr cur_obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_set_group", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevSetGroup(__IntPtr indev, __IntPtr group);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_set_button_points", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevSetButtonPoints(__IntPtr indev, global::lvgl.LvPointT.__Internal[] points);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_point", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevGetPoint(__IntPtr indev, __IntPtr point);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_gesture_dir", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvIndevGetGestureDir(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_key", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvIndevGetKey(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_scroll_dir", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvIndevGetScrollDir(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_scroll_obj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvIndevGetScrollObj(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_vect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevGetVect(__IntPtr indev, __IntPtr point);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_wait_release", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevWaitRelease(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_active_obj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvIndevGetActiveObj();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_read_timer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvIndevGetReadTimer(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_set_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevSetMode(__IntPtr indev, global::lvgl.LvIndevModeT mode);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::lvgl.LvIndevModeT LvIndevGetMode(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_search_obj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvIndevSearchObj(__IntPtr obj, __IntPtr point);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_add_event_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvIndevAddEventCb(__IntPtr indev, __IntPtr event_cb, global::lvgl.LvEventCodeT filter, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_event_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvIndevGetEventCount(__IntPtr indev);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_get_event_dsc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvIndevGetEventDsc(__IntPtr indev, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_remove_event", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvIndevRemoveEvent(__IntPtr indev, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_remove_event_cb_with_user_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvIndevRemoveEventCbWithUserData(__IntPtr indev, __IntPtr event_cb, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_indev_send_event", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvIndevSendEvent(__IntPtr indev, global::lvgl.LvEventCodeT code, __IntPtr param);
        }

        /// <summary>Create an indev</summary>
        /// <returns>Pointer to the created indev or NULL when allocation failed</returns>
        public static global::lvgl.LvIndevT LvIndevCreate()
        {
            var ___ret = __Internal.LvIndevCreate();
            var __result0 = global::lvgl.LvIndevT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Remove the provided input device. Make sure not to use the provided input device afterwards anymore.</summary>
        /// <param name="indev">pointer to delete</param>
        public static void LvIndevDelete(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            __Internal.LvIndevDelete(__arg0);
        }

        /// <summary>Get the next input device.</summary>
        /// <param name="indev">pointer to the current input device. NULL to initialize.</param>
        /// <returns>
        /// <para>the next input device or NULL if there are no more. Provide the first input device when</para>
        /// <para>the parameter is NULL</para>
        /// </returns>
        public static global::lvgl.LvIndevT LvIndevGetNext(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevGetNext(__arg0);
            var __result0 = global::lvgl.LvIndevT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Read data from an input device.</summary>
        /// <param name="indev">pointer to an input device</param>
        public static void LvIndevRead(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            __Internal.LvIndevRead(__arg0);
        }

        /// <summary>Called periodically to read the input devices</summary>
        /// <param name="timer">pointer to a timer to read</param>
        public static void LvIndevReadTimerCb(global::lvgl.LvTimerT timer)
        {
            var __arg0 = timer is null ? __IntPtr.Zero : timer.__Instance;
            __Internal.LvIndevReadTimerCb(__arg0);
        }

        /// <summary>Enable or disable one or all input devices (default enabled)</summary>
        /// <param name="indev">pointer to an input device or NULL to enable/disable all of them</param>
        /// <param name="enable">true to enable, false to disable</param>
        public static void LvIndevEnable(global::lvgl.LvIndevT indev, bool enable)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            __Internal.LvIndevEnable(__arg0, enable);
        }

        /// <summary>Get the currently processed input device. Can be used in action functions too.</summary>
        /// <returns>
        /// <para>pointer to the currently processed input device or NULL if no input device processing</para>
        /// <para>right now</para>
        /// </returns>
        public static global::lvgl.LvIndevT LvIndevActive()
        {
            var ___ret = __Internal.LvIndevActive();
            var __result0 = global::lvgl.LvIndevT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the type of an input device</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <param name="indev_type">the type of the input device from `lv_indev_type_t` (`LV_INDEV_TYPE_...`)</param>
        public static void LvIndevSetType(global::lvgl.LvIndevT indev, global::lvgl.LvIndevTypeT indev_type)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            __Internal.LvIndevSetType(__arg0, indev_type);
        }

        /// <summary>Set a callback function to read input device data to the indev</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <param name="read_cb">pointer to callback function to read input device data</param>
        public static void LvIndevSetReadCb(global::lvgl.LvIndevT indev, global::lvgl.LvIndevReadCbT read_cb)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var __arg1 = read_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(read_cb);
            __Internal.LvIndevSetReadCb(__arg0, __arg1);
        }

        /// <summary>Set user data to the indev</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <param name="user_data">pointer to user data</param>
        public static void LvIndevSetUserData(global::lvgl.LvIndevT indev, __IntPtr user_data)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            __Internal.LvIndevSetUserData(__arg0, user_data);
        }

        /// <summary>Set driver data to the indev</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <param name="driver_data">pointer to driver data</param>
        public static void LvIndevSetDriverData(global::lvgl.LvIndevT indev, __IntPtr driver_data)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            __Internal.LvIndevSetDriverData(__arg0, driver_data);
        }

        /// <summary>Assign a display to the indev</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <param name="disp">pointer to an display</param>
        public static void LvIndevSetDisplay(global::lvgl.LvIndevT indev, global::lvgl.LvDisplayT disp)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var __arg1 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvIndevSetDisplay(__arg0, __arg1);
        }

        /// <summary>Get the type of an input device</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <returns>the type of the input device from `lv_hal_indev_type_t` (`LV_INDEV_TYPE_...`)</returns>
        public static global::lvgl.LvIndevTypeT LvIndevGetType(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevGetType(__arg0);
            return ___ret;
        }

        /// <summary>Get the callback function to read input device data to the indev</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <returns>Pointer to callback function to read input device data or NULL if indev is NULL</returns>
        public static global::lvgl.LvIndevReadCbT LvIndevGetReadCb(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevGetReadCb(__arg0);
            var __ptr0 = ___ret;
            return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvIndevReadCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvIndevReadCbT));
        }

        /// <summary>Get the indev state</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <returns>Indev state or LV_INDEV_STATE_RELEASED if indev is NULL</returns>
        public static global::lvgl.LvIndevStateT LvIndevGetState(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevGetState(__arg0);
            return ___ret;
        }

        /// <summary>Get the indev assigned group</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <returns>Pointer to indev assigned group or NULL if indev is NULL</returns>
        public static global::lvgl.LvGroupT LvIndevGetGroup(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevGetGroup(__arg0);
            var __result0 = global::lvgl.LvGroupT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get a pointer to the assigned display of the indev</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <returns>pointer to the assigned display or NULL if indev is NULL</returns>
        public static global::lvgl.LvDisplayT LvIndevGetDisplay(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevGetDisplay(__arg0);
            var __result0 = global::lvgl.LvDisplayT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get a pointer to the user data of the indev</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <returns>pointer to the user data or NULL if indev is NULL</returns>
        public static __IntPtr LvIndevGetUserData(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevGetUserData(__arg0);
            return ___ret;
        }

        /// <summary>Get a pointer to the driver data of the indev</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <returns>pointer to the driver data or NULL if indev is NULL</returns>
        public static __IntPtr LvIndevGetDriverData(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevGetDriverData(__arg0);
            return ___ret;
        }

        /// <summary>Reset one or all input devices</summary>
        /// <param name="indev">pointer to an input device to reset or NULL to reset all of them</param>
        /// <param name="obj">pointer to an object which triggers the reset.</param>
        public static void LvIndevReset(global::lvgl.LvIndevT indev, global::lvgl.LvObjT obj)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var __arg1 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvIndevReset(__arg0, __arg1);
        }

        /// <summary>Reset the long press state of an input device</summary>
        /// <param name="indev">pointer to an input device</param>
        public static void LvIndevResetLongPress(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            __Internal.LvIndevResetLongPress(__arg0);
        }

        /// <summary>Set a cursor for a pointer input device (for LV_INPUT_TYPE_POINTER and LV_INPUT_TYPE_BUTTON)</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <param name="cur_obj">pointer to an object to be used as cursor</param>
        public static void LvIndevSetCursor(global::lvgl.LvIndevT indev, global::lvgl.LvObjT cur_obj)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var __arg1 = cur_obj is null ? __IntPtr.Zero : cur_obj.__Instance;
            __Internal.LvIndevSetCursor(__arg0, __arg1);
        }

        /// <summary>Set a destination group for a keypad input device (for LV_INDEV_TYPE_KEYPAD)</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <param name="group">pointer to a group</param>
        public static void LvIndevSetGroup(global::lvgl.LvIndevT indev, global::lvgl.LvGroupT group)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var __arg1 = group is null ? __IntPtr.Zero : group.__Instance;
            __Internal.LvIndevSetGroup(__arg0, __arg1);
        }

        /// <summary>
        /// <para>Set the an array of points for LV_INDEV_TYPE_BUTTON.</para>
        /// <para>These points will be assigned to the buttons to press a specific point on the screen</para>
        /// </summary>
        /// <param name="indev">pointer to an input device</param>
        /// <param name="points">array of points</param>
        public static void LvIndevSetButtonPoints(global::lvgl.LvIndevT indev, global::lvgl.LvPointT[] points)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            global::lvgl.LvPointT.__Internal[] __points;
            if (points == null)
                __points = null;
            else
            {
                __points = new global::lvgl.LvPointT.__Internal[points.Length];
                for (int i = 0; i < __points.Length; i++)
                {
                    var __element = points[i];
                    __points[i] = __element is null ? new global::lvgl.LvPointT.__Internal() : *(global::lvgl.LvPointT.__Internal*) __element.__Instance;
                }
            }
            var __arg1 = __points;
            __Internal.LvIndevSetButtonPoints(__arg0, __arg1);
        }

        /// <summary>Get the last point of an input device (for LV_INDEV_TYPE_POINTER and LV_INDEV_TYPE_BUTTON)</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <param name="point">pointer to a point to store the result</param>
        public static void LvIndevGetPoint(global::lvgl.LvIndevT indev, global::lvgl.LvPointT point)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var __arg1 = point is null ? __IntPtr.Zero : point.__Instance;
            __Internal.LvIndevGetPoint(__arg0, __arg1);
        }

        /// <summary>Get the current gesture direct</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <returns>current gesture direct</returns>
        public static byte LvIndevGetGestureDir(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevGetGestureDir(__arg0);
            return ___ret;
        }

        /// <summary>Get the last pressed key of an input device (for LV_INDEV_TYPE_KEYPAD)</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <returns>the last pressed key (0 on error)</returns>
        public static uint LvIndevGetKey(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevGetKey(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Check the current scroll direction of an input device (for LV_INDEV_TYPE_POINTER and</para>
        /// <para>LV_INDEV_TYPE_BUTTON)</para>
        /// </summary>
        /// <param name="indev">pointer to an input device</param>
        /// <returns>
        /// <para>LV_DIR_NONE: no scrolling now</para>
        /// <para>LV_DIR_HOR/VER</para>
        /// </returns>
        public static byte LvIndevGetScrollDir(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevGetScrollDir(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Get the currently scrolled object (for LV_INDEV_TYPE_POINTER and</para>
        /// <para>LV_INDEV_TYPE_BUTTON)</para>
        /// </summary>
        /// <param name="indev">pointer to an input device</param>
        /// <returns>pointer to the currently scrolled object or NULL if no scrolling by this indev</returns>
        public static global::lvgl.LvObjT LvIndevGetScrollObj(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevGetScrollObj(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get the movement vector of an input device (for LV_INDEV_TYPE_POINTER and</para>
        /// <para>LV_INDEV_TYPE_BUTTON)</para>
        /// </summary>
        /// <param name="indev">pointer to an input device</param>
        /// <param name="point">pointer to a point to store the types.pointer.vector</param>
        public static void LvIndevGetVect(global::lvgl.LvIndevT indev, global::lvgl.LvPointT point)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var __arg1 = point is null ? __IntPtr.Zero : point.__Instance;
            __Internal.LvIndevGetVect(__arg0, __arg1);
        }

        /// <summary>Do nothing until the next release</summary>
        /// <param name="indev">pointer to an input device</param>
        public static void LvIndevWaitRelease(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            __Internal.LvIndevWaitRelease(__arg0);
        }

        /// <summary>Gets a pointer to the currently active object in the currently processed input device.</summary>
        /// <returns>pointer to currently active object or NULL if no active object</returns>
        public static global::lvgl.LvObjT LvIndevGetActiveObj()
        {
            var ___ret = __Internal.LvIndevGetActiveObj();
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get a pointer to the indev read timer to</para>
        /// <para>modify its parameters with `lv_timer_...` functions.</para>
        /// </summary>
        /// <param name="indev">pointer to an input device</param>
        /// <returns>pointer to the indev read refresher timer. (NULL on error)</returns>
        public static global::lvgl.LvTimerT LvIndevGetReadTimer(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevGetReadTimer(__arg0);
            var __result0 = global::lvgl.LvTimerT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the input device's event model: event-driven mode or timer mode.</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <param name="mode">the mode of input device</param>
        public static void LvIndevSetMode(global::lvgl.LvIndevT indev, global::lvgl.LvIndevModeT mode)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            __Internal.LvIndevSetMode(__arg0, mode);
        }

        /// <summary>Get the input device's running mode.</summary>
        /// <param name="indev">pointer to an input device</param>
        /// <returns>the running mode for the specified input device.</returns>
        public static global::lvgl.LvIndevModeT LvIndevGetMode(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevGetMode(__arg0);
            return ___ret;
        }

        /// <summary>Search the most top, clickable object by a point</summary>
        /// <param name="obj">pointer to a start object, typically the screen</param>
        /// <param name="point">pointer to a point for searching the most top child</param>
        /// <returns>pointer to the found object or NULL if there was no suitable object</returns>
        public static global::lvgl.LvObjT LvIndevSearchObj(global::lvgl.LvObjT obj, global::lvgl.LvPointT point)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = point is null ? __IntPtr.Zero : point.__Instance;
            var ___ret = __Internal.LvIndevSearchObj(__arg0, __arg1);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Add an event handler to the indev</summary>
        /// <param name="indev">pointer to an indev</param>
        /// <param name="event_cb">an event callback</param>
        /// <param name="filter">event code to react or `LV_EVENT_ALL`</param>
        /// <param name="user_data">optional user_data</param>
        public static void LvIndevAddEventCb(global::lvgl.LvIndevT indev, global::lvgl.LvEventCbT event_cb, global::lvgl.LvEventCodeT filter, __IntPtr user_data)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var __arg1 = event_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(event_cb);
            __Internal.LvIndevAddEventCb(__arg0, __arg1, filter, user_data);
        }

        /// <summary>Get the number of event attached to an indev</summary>
        /// <param name="indev">pointer to an indev</param>
        /// <returns>number of events</returns>
        public static uint LvIndevGetEventCount(global::lvgl.LvIndevT indev)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevGetEventCount(__arg0);
            return ___ret;
        }

        /// <summary>Get an event descriptor for an event</summary>
        /// <param name="indev">pointer to an indev</param>
        /// <param name="index">the index of the event</param>
        /// <returns>the event descriptor</returns>
        public static global::lvgl.LvEventDscT LvIndevGetEventDsc(global::lvgl.LvIndevT indev, uint index)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevGetEventDsc(__arg0, index);
            var __result0 = global::lvgl.LvEventDscT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Remove an event</summary>
        /// <param name="indev">pointer to an indev</param>
        /// <param name="index">the index of the event to remove</param>
        /// <returns>true: and event was removed; false: no event was removed</returns>
        public static bool LvIndevRemoveEvent(global::lvgl.LvIndevT indev, uint index)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevRemoveEvent(__arg0, index);
            return ___ret;
        }

        /// <summary>Remove an event_cb with user_data</summary>
        /// <param name="indev">pointer to a indev</param>
        /// <param name="event_cb">the event_cb of the event to remove</param>
        /// <param name="user_data">user_data</param>
        /// <returns>the count of the event removed</returns>
        public static uint LvIndevRemoveEventCbWithUserData(global::lvgl.LvIndevT indev, global::lvgl.LvEventCbT event_cb, __IntPtr user_data)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var __arg1 = event_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(event_cb);
            var ___ret = __Internal.LvIndevRemoveEventCbWithUserData(__arg0, __arg1, user_data);
            return ___ret;
        }

        /// <summary>Send an event to an indev</summary>
        /// <param name="indev">pointer to an indev</param>
        /// <param name="code">an event code. LV_EVENT_...</param>
        /// <param name="param">optional param</param>
        /// <returns>LV_RESULT_OK: indev wasn't deleted in the event.</returns>
        public static byte LvIndevSendEvent(global::lvgl.LvIndevT indev, global::lvgl.LvEventCodeT code, __IntPtr param)
        {
            var __arg0 = indev is null ? __IntPtr.Zero : indev.__Instance;
            var ___ret = __Internal.LvIndevSendEvent(__arg0, code, param);
            return ___ret;
        }
    }

    /// <summary>
    /// <para>*******************</para>
    /// <para>DEFINES</para>
    /// <para>*******************</para>
    /// </summary>
    public enum LvKeyT
    {
        LV_KEY_UP = 17,
        LV_KEY_DOWN = 18,
        LV_KEY_RIGHT = 19,
        LV_KEY_LEFT = 20,
        LV_KEY_ESC = 27,
        LV_KEY_DEL = 127,
        LV_KEY_BACKSPACE = 8,
        LV_KEY_ENTER = 10,
        LV_KEY_NEXT = 9,
        LV_KEY_PREV = 11,
        LV_KEY_HOME = 2,
        LV_KEY_END = 3
    }

    public enum LvGroupRefocusPolicyT
    {
        LV_GROUP_REFOCUS_POLICY_NEXT = 0,
        LV_GROUP_REFOCUS_POLICY_PREV = 1
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvGroupFocusCbT(__IntPtr __0);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvGroupEdgeCbT(__IntPtr __0, [MarshalAs(UnmanagedType.I1)] bool __1);

    /// <summary>
    /// <para>Groups can be used to logically hold objects so that they can be individually focused.</para>
    /// <para>They are NOT for laying out objects on a screen (try layouts for that).</para>
    /// </summary>
    public unsafe partial class LvGroupT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvLlT.__Internal obj_ll;

            [FieldOffset(24)]
            internal __IntPtr obj_focus;

            [FieldOffset(32)]
            internal __IntPtr focus_cb;

            [FieldOffset(40)]
            internal __IntPtr edge_cb;

            [FieldOffset(48)]
            internal __IntPtr user_data;

            [FieldOffset(56)]
            internal byte frozen;

            [FieldOffset(56)]
            internal byte editing;

            [FieldOffset(56)]
            internal byte refocus_policy;

            [FieldOffset(56)]
            internal byte wrap;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_group_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvGroupT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvGroupT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvGroupT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvGroupT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvGroupT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvGroupT(native.ToPointer(), skipVTables);
        }

        internal static LvGroupT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvGroupT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvGroupT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvGroupT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvGroupT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvGroupT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvGroupT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvGroupT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvGroupT(global::lvgl.LvGroupT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvGroupT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvGroupT.__Internal*) __Instance) = *((global::lvgl.LvGroupT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Linked list to store the objects in the group</summary>
        public global::lvgl.LvLlT ObjLl
        {
            get
            {
                return global::lvgl.LvLlT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj_ll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj_ll = *(global::lvgl.LvLlT.__Internal*) value.__Instance;
            }
        }

        /// <summary>The object in focus</summary>
        public global::lvgl.LvObjT ObjFocus
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->obj_focus, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->obj_focus = new __IntPtr(&__value);
            }
        }

        /// <summary>A function to call when a new object is focused (optional)</summary>
        public global::lvgl.LvGroupFocusCbT FocusCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->focus_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvGroupFocusCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvGroupFocusCbT));
            }

            set
            {
                ((__Internal*)__Instance)->focus_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>
        /// <para>A function to call when an edge is reached, no more focus</para>
        /// <para>targets are available in this direction (to allow edge feedback</para>
        /// <para>like a sound or a scroll bounce)</para>
        /// </summary>
        public global::lvgl.LvGroupEdgeCbT EdgeCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->edge_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvGroupEdgeCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvGroupEdgeCbT));
            }

            set
            {
                ((__Internal*)__Instance)->edge_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }

        /// <summary>1: can't focus to new object</summary>
        public byte Frozen
        {
            get
            {
                return ((__Internal*)__Instance)->frozen;
            }

            set
            {
                ((__Internal*)__Instance)->frozen = value;
            }
        }

        /// <summary>1: Edit mode, 0: Navigate mode</summary>
        public byte Editing
        {
            get
            {
                return ((__Internal*)__Instance)->editing;
            }

            set
            {
                ((__Internal*)__Instance)->editing = value;
            }
        }

        /// <summary>
        /// <para>1: Focus prev if focused on deletion. 0: Focus next if focused on</para>
        /// <para>deletion.</para>
        /// </summary>
        public byte RefocusPolicy
        {
            get
            {
                return ((__Internal*)__Instance)->refocus_policy;
            }

            set
            {
                ((__Internal*)__Instance)->refocus_policy = value;
            }
        }

        /// <summary>
        /// <para>1: Focus next/prev can wrap at end of list. 0: Focus next/prev stops at end</para>
        /// <para>of list.</para>
        /// </summary>
        public byte Wrap
        {
            get
            {
                return ((__Internal*)__Instance)->wrap;
            }

            set
            {
                ((__Internal*)__Instance)->wrap = value;
            }
        }
    }

    public unsafe partial class lv_group
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_group_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGroupInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_group_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGroupDeinit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvGroupCreate();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_delete", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGroupDelete(__IntPtr group);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_set_default", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGroupSetDefault(__IntPtr group);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_get_default", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvGroupGetDefault();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_add_obj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGroupAddObj(__IntPtr group, __IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_swap_obj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGroupSwapObj(__IntPtr obj1, __IntPtr obj2);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_remove_obj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGroupRemoveObj(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_remove_all_objs", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGroupRemoveAllObjs(__IntPtr group);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_focus_obj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGroupFocusObj(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_focus_next", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGroupFocusNext(__IntPtr group);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_focus_prev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGroupFocusPrev(__IntPtr group);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_focus_freeze", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGroupFocusFreeze(__IntPtr group, bool en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_send_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvGroupSendData(__IntPtr group, uint c);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_set_focus_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGroupSetFocusCb(__IntPtr group, __IntPtr focus_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_set_edge_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGroupSetEdgeCb(__IntPtr group, __IntPtr edge_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_set_refocus_policy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGroupSetRefocusPolicy(__IntPtr group, global::lvgl.LvGroupRefocusPolicyT policy);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_set_editing", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGroupSetEditing(__IntPtr group, bool edit);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_set_wrap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvGroupSetWrap(__IntPtr group, bool en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_get_focused", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvGroupGetFocused(__IntPtr group);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_get_focus_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvGroupGetFocusCb(__IntPtr group);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_get_edge_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvGroupGetEdgeCb(__IntPtr group);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_get_editing", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvGroupGetEditing(__IntPtr group);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_get_wrap", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvGroupGetWrap(__IntPtr group);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_get_obj_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvGroupGetObjCount(__IntPtr group);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_get_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvGroupGetCount();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_group_by_index", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvGroupByIndex(uint index);
        }

        /// <summary>Init the group module</summary>
        /// <remarks>Internal function, do not call directly.</remarks>
        public static void LvGroupInit()
        {
            __Internal.LvGroupInit();
        }

        /// <summary>Deinit the group module</summary>
        /// <remarks>Internal function, do not call directly.</remarks>
        public static void LvGroupDeinit()
        {
            __Internal.LvGroupDeinit();
        }

        /// <summary>Create a new object group</summary>
        /// <returns>pointer to the new object group</returns>
        public static global::lvgl.LvGroupT LvGroupCreate()
        {
            var ___ret = __Internal.LvGroupCreate();
            var __result0 = global::lvgl.LvGroupT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Delete a group object</summary>
        /// <param name="group">pointer to a group</param>
        public static void LvGroupDelete(global::lvgl.LvGroupT group)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            __Internal.LvGroupDelete(__arg0);
        }

        /// <summary>Set a default group. New object are added to this group if it's enabled in their class with `add_to_def_group = true`</summary>
        /// <param name="group">pointer to a group (can be `NULL`)</param>
        public static void LvGroupSetDefault(global::lvgl.LvGroupT group)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            __Internal.LvGroupSetDefault(__arg0);
        }

        /// <summary>Get the default group</summary>
        /// <returns>pointer to the default group</returns>
        public static global::lvgl.LvGroupT LvGroupGetDefault()
        {
            var ___ret = __Internal.LvGroupGetDefault();
            var __result0 = global::lvgl.LvGroupT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Add an object to a group</summary>
        /// <param name="group">pointer to a group</param>
        /// <param name="obj">pointer to an object to add</param>
        public static void LvGroupAddObj(global::lvgl.LvGroupT group, global::lvgl.LvObjT obj)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            var __arg1 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvGroupAddObj(__arg0, __arg1);
        }

        /// <summary>Swap 2 object in a group. The object must be in the same group</summary>
        /// <param name="obj1">pointer to an object</param>
        /// <param name="obj2">pointer to an other object</param>
        public static void LvGroupSwapObj(global::lvgl.LvObjT obj1, global::lvgl.LvObjT obj2)
        {
            var __arg0 = obj1 is null ? __IntPtr.Zero : obj1.__Instance;
            var __arg1 = obj2 is null ? __IntPtr.Zero : obj2.__Instance;
            __Internal.LvGroupSwapObj(__arg0, __arg1);
        }

        /// <summary>Remove an object from its group</summary>
        /// <param name="obj">pointer to an object to remove</param>
        public static void LvGroupRemoveObj(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvGroupRemoveObj(__arg0);
        }

        /// <summary>Remove all objects from a group</summary>
        /// <param name="group">pointer to a group</param>
        public static void LvGroupRemoveAllObjs(global::lvgl.LvGroupT group)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            __Internal.LvGroupRemoveAllObjs(__arg0);
        }

        /// <summary>Focus on an object (defocus the current)</summary>
        /// <param name="obj">pointer to an object to focus on</param>
        public static void LvGroupFocusObj(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvGroupFocusObj(__arg0);
        }

        /// <summary>Focus the next object in a group (defocus the current)</summary>
        /// <param name="group">pointer to a group</param>
        public static void LvGroupFocusNext(global::lvgl.LvGroupT group)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            __Internal.LvGroupFocusNext(__arg0);
        }

        /// <summary>Focus the previous object in a group (defocus the current)</summary>
        /// <param name="group">pointer to a group</param>
        public static void LvGroupFocusPrev(global::lvgl.LvGroupT group)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            __Internal.LvGroupFocusPrev(__arg0);
        }

        /// <summary>Do not let to change the focus from the current object</summary>
        /// <param name="group">pointer to a group</param>
        /// <param name="en">true: freeze, false: release freezing (normal mode)</param>
        public static void LvGroupFocusFreeze(global::lvgl.LvGroupT group, bool en)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            __Internal.LvGroupFocusFreeze(__arg0, en);
        }

        /// <summary>Send a control character to the focuses object of a group</summary>
        /// <param name="group">pointer to a group</param>
        /// <param name="c">a character (use LV_KEY_.. to navigate)</param>
        /// <returns>result of focused object in group.</returns>
        public static byte LvGroupSendData(global::lvgl.LvGroupT group, uint c)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            var ___ret = __Internal.LvGroupSendData(__arg0, c);
            return ___ret;
        }

        /// <summary>Set a function for a group which will be called when a new object is focused</summary>
        /// <param name="group">pointer to a group</param>
        /// <param name="focus_cb">the call back function or NULL if unused</param>
        public static void LvGroupSetFocusCb(global::lvgl.LvGroupT group, global::lvgl.LvGroupFocusCbT focus_cb)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            var __arg1 = focus_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(focus_cb);
            __Internal.LvGroupSetFocusCb(__arg0, __arg1);
        }

        /// <summary>Set a function for a group which will be called when a focus edge is reached</summary>
        /// <param name="group">pointer to a group</param>
        /// <param name="edge_cb">the call back function or NULL if unused</param>
        public static void LvGroupSetEdgeCb(global::lvgl.LvGroupT group, global::lvgl.LvGroupEdgeCbT edge_cb)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            var __arg1 = edge_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(edge_cb);
            __Internal.LvGroupSetEdgeCb(__arg0, __arg1);
        }

        /// <summary>
        /// <para>Set whether the next or previous item in a group is focused if the currently focused obj is</para>
        /// <para>deleted.</para>
        /// </summary>
        /// <param name="group">pointer to a group</param>
        /// <param name="policy">new refocus policy enum</param>
        public static void LvGroupSetRefocusPolicy(global::lvgl.LvGroupT group, global::lvgl.LvGroupRefocusPolicyT policy)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            __Internal.LvGroupSetRefocusPolicy(__arg0, policy);
        }

        /// <summary>Manually set the current mode (edit or navigate).</summary>
        /// <param name="group">pointer to group</param>
        /// <param name="edit">true: edit mode; false: navigate mode</param>
        public static void LvGroupSetEditing(global::lvgl.LvGroupT group, bool edit)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            __Internal.LvGroupSetEditing(__arg0, edit);
        }

        /// <summary>Set whether focus next/prev will allow wrapping from first-&gt;last or last-&gt;first object.</summary>
        /// <param name="group">pointer to group</param>
        /// <param name="en">true: wrapping enabled; false: wrapping disabled</param>
        public static void LvGroupSetWrap(global::lvgl.LvGroupT group, bool en)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            __Internal.LvGroupSetWrap(__arg0, en);
        }

        /// <summary>Get the focused object or NULL if there isn't one</summary>
        /// <param name="group">pointer to a group</param>
        /// <returns>pointer to the focused object</returns>
        public static global::lvgl.LvObjT LvGroupGetFocused(global::lvgl.LvGroupT group)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            var ___ret = __Internal.LvGroupGetFocused(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the focus callback function of a group</summary>
        /// <param name="group">pointer to a group</param>
        /// <returns>the call back function or NULL if not set</returns>
        public static global::lvgl.LvGroupFocusCbT LvGroupGetFocusCb(global::lvgl.LvGroupT group)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            var ___ret = __Internal.LvGroupGetFocusCb(__arg0);
            var __ptr0 = ___ret;
            return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvGroupFocusCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvGroupFocusCbT));
        }

        /// <summary>Get the edge callback function of a group</summary>
        /// <param name="group">pointer to a group</param>
        /// <returns>the call back function or NULL if not set</returns>
        public static global::lvgl.LvGroupEdgeCbT LvGroupGetEdgeCb(global::lvgl.LvGroupT group)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            var ___ret = __Internal.LvGroupGetEdgeCb(__arg0);
            var __ptr0 = ___ret;
            return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvGroupEdgeCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvGroupEdgeCbT));
        }

        /// <summary>Get the current mode (edit or navigate).</summary>
        /// <param name="group">pointer to group</param>
        /// <returns>true: edit mode; false: navigate mode</returns>
        public static bool LvGroupGetEditing(global::lvgl.LvGroupT group)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            var ___ret = __Internal.LvGroupGetEditing(__arg0);
            return ___ret;
        }

        /// <summary>Get whether focus next/prev will allow wrapping from first-&gt;last or last-&gt;first object.</summary>
        /// <param name="group">pointer to group</param>
        /// <param name="en">true: wrapping enabled; false: wrapping disabled</param>
        public static bool LvGroupGetWrap(global::lvgl.LvGroupT group)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            var ___ret = __Internal.LvGroupGetWrap(__arg0);
            return ___ret;
        }

        /// <summary>Get the number of object in the group</summary>
        /// <param name="group">pointer to a group</param>
        /// <returns>number of objects in the group</returns>
        public static uint LvGroupGetObjCount(global::lvgl.LvGroupT group)
        {
            var __arg0 = group is null ? __IntPtr.Zero : group.__Instance;
            var ___ret = __Internal.LvGroupGetObjCount(__arg0);
            return ___ret;
        }

        /// <summary>Get the number of groups</summary>
        /// <returns>number of groups</returns>
        public static uint LvGroupGetCount()
        {
            var ___ret = __Internal.LvGroupGetCount();
            return ___ret;
        }

        /// <summary>Get a group by its index</summary>
        /// <returns>pointer to the group</returns>
        public static global::lvgl.LvGroupT LvGroupByIndex(uint index)
        {
            var ___ret = __Internal.LvGroupByIndex(index);
            var __result0 = global::lvgl.LvGroupT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class lv_refr
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_refr_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvRefrInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_refr_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvRefrDeinit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_refr_now", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvRefrNow(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_redraw", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObjRedraw(__IntPtr layer, __IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_inv_area", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvInvArea(__IntPtr disp, __IntPtr area_p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_refr_get_disp_refreshing", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvRefrGetDispRefreshing();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_refr_set_disp_refreshing", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvRefrSetDispRefreshing(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_display_refr_timer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDisplayRefrTimer(__IntPtr timer);
        }

        /// <summary>Initialize the screen refresh subsystem</summary>
        public static void LvRefrInit()
        {
            __Internal.LvRefrInit();
        }

        /// <summary>Deinitialize the screen refresh subsystem</summary>
        public static void LvRefrDeinit()
        {
            __Internal.LvRefrDeinit();
        }

        /// <summary>
        /// <para>Redraw the invalidated areas now.</para>
        /// <para>Normally the redrawing is periodically executed in `lv_timer_handler` but a long blocking process</para>
        /// <para>can prevent the call of `lv_timer_handler`. In this case if the GUI is updated in the process</para>
        /// <para>(e.g. progress bar) this function can be called when the screen should be updated.</para>
        /// </summary>
        /// <param name="disp">pointer to display to refresh. NULL to refresh all displays.</param>
        public static void LvRefrNow(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvRefrNow(__arg0);
        }

        /// <summary>Redrawn on object and all its children using the passed draw context</summary>
        /// <param name="layer">pointer to a layer where to draw.</param>
        /// <param name="obj">the start object from the redraw should start</param>
        public static void LvObjRedraw(global::lvgl.LvLayerT layer, global::lvgl.LvObjT obj)
        {
            var __arg0 = layer is null ? __IntPtr.Zero : layer.__Instance;
            var __arg1 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvObjRedraw(__arg0, __arg1);
        }

        /// <summary>Invalidate an area on display to redraw it</summary>
        /// <param name="area_p">pointer to area which should be invalidated (NULL: delete the invalidated areas)</param>
        /// <param name="disp">
        /// <para>pointer to display where the area should be invalidated (NULL can be used if there is</para>
        /// <para>only one display)</para>
        /// </param>
        public static void LvInvArea(global::lvgl.LvDisplayT disp, global::lvgl.LvAreaT area_p)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var __arg1 = area_p is null ? __IntPtr.Zero : area_p.__Instance;
            __Internal.LvInvArea(__arg0, __arg1);
        }

        /// <summary>Get the display which is being refreshed</summary>
        /// <returns>the display being refreshed</returns>
        public static global::lvgl.LvDisplayT LvRefrGetDispRefreshing()
        {
            var ___ret = __Internal.LvRefrGetDispRefreshing();
            var __result0 = global::lvgl.LvDisplayT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the display which is being refreshed</summary>
        /// <param name="disp">the display being refreshed</param>
        public static void LvRefrSetDispRefreshing(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            __Internal.LvRefrSetDispRefreshing(__arg0);
        }

        /// <summary>Called periodically to handle the refreshing</summary>
        /// <param name="timer">pointer to the timer itself</param>
        public static void LvDisplayRefrTimer(global::lvgl.LvTimerT timer)
        {
            var __arg0 = timer is null ? __IntPtr.Zero : timer.__Instance;
            __Internal.LvDisplayRefrTimer(__arg0);
        }
    }

    public unsafe partial class lv_binfont_loader
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_binfont_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvBinfontCreate([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string font_name);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_binfont_destroy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvBinfontDestroy(__IntPtr font);
        }

        /// <summary>Loads a `lv_font_t` object from a binary font file</summary>
        /// <param name="path">path where the font file is located</param>
        /// <returns>pointer to font where to load</returns>
        public static global::lvgl.LvFontT LvBinfontCreate(string font_name)
        {
            var ___ret = __Internal.LvBinfontCreate(font_name);
            var __result0 = global::lvgl.LvFontT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Frees the memory allocated by the `lv_binfont_create()` function</summary>
        /// <param name="font">lv_font_t object created by the lv_binfont_create function</param>
        public static void LvBinfontDestroy(global::lvgl.LvFontT font)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            __Internal.LvBinfontDestroy(__arg0);
        }
    }

    /// <summary>Format of font character map.</summary>
    public enum LvFontFmtTxtCmapTypeT
    {
        LV_FONT_FMT_TXT_CMAP_FORMAT0FULL = 0,
        LV_FONT_FMT_TXT_CMAP_SPARSE_FULL = 1,
        LV_FONT_FMT_TXT_CMAP_FORMAT0TINY = 2,
        LV_FONT_FMT_TXT_CMAP_SPARSE_TINY = 3
    }

    /// <summary>Bitmap formats</summary>
    public enum LvFontFmtTxtBitmapFormatT
    {
        LV_FONT_FMT_TXT_PLAIN = 0,
        LV_FONT_FMT_TXT_COMPRESSED = 1,
        LV_FONT_FMT_TXT_COMPRESSED_NO_PREFILTER = 1
    }

    /// <summary>This describes a glyph.</summary>
    /// <summary>
    /// <para>Map codepoints to a `glyph_dsc`s</para>
    /// <para>Several formats are supported to optimize memory usage</para>
    /// <para>See https://github.com/lvgl/lv_font_conv/blob/master/doc/font_spec.md</para>
    /// </summary>
    /// <summary>A simple mapping of kern values from pairs</summary>
    /// <summary>More complex but more optimal class based kern value storage</summary>
    /// <summary>Bitmap formats</summary>
    /// <summary>This describes a glyph.</summary>
    public unsafe partial class LvFontFmtTxtGlyphDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal uint bitmap_index;
            internal uint adv_w;
            internal byte box_w;
            internal byte box_h;
            internal sbyte ofs_x;
            internal sbyte ofs_y;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_font_fmt_txt_glyph_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFontFmtTxtGlyphDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFontFmtTxtGlyphDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvFontFmtTxtGlyphDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvFontFmtTxtGlyphDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvFontFmtTxtGlyphDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvFontFmtTxtGlyphDscT(native.ToPointer(), skipVTables);
        }

        internal static LvFontFmtTxtGlyphDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvFontFmtTxtGlyphDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvFontFmtTxtGlyphDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvFontFmtTxtGlyphDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvFontFmtTxtGlyphDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvFontFmtTxtGlyphDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvFontFmtTxtGlyphDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFontFmtTxtGlyphDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvFontFmtTxtGlyphDscT(global::lvgl.LvFontFmtTxtGlyphDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFontFmtTxtGlyphDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvFontFmtTxtGlyphDscT.__Internal*) __Instance) = *((global::lvgl.LvFontFmtTxtGlyphDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Start index of the bitmap. A font can be max 1 MB.</summary>
        public uint BitmapIndex
        {
            get
            {
                return ((__Internal*)__Instance)->bitmap_index;
            }

            set
            {
                ((__Internal*)__Instance)->bitmap_index = value;
            }
        }

        /// <summary>Draw the next glyph after this width. 8.4 format (real_value * 16 is stored).</summary>
        public uint AdvW
        {
            get
            {
                return ((__Internal*)__Instance)->adv_w;
            }

            set
            {
                ((__Internal*)__Instance)->adv_w = value;
            }
        }

        /// <summary>Width of the glyph's bounding box</summary>
        public byte BoxW
        {
            get
            {
                return ((__Internal*)__Instance)->box_w;
            }

            set
            {
                ((__Internal*)__Instance)->box_w = value;
            }
        }

        /// <summary>Height of the glyph's bounding box</summary>
        public byte BoxH
        {
            get
            {
                return ((__Internal*)__Instance)->box_h;
            }

            set
            {
                ((__Internal*)__Instance)->box_h = value;
            }
        }

        /// <summary>x offset of the bounding box</summary>
        public sbyte OfsX
        {
            get
            {
                return ((__Internal*)__Instance)->ofs_x;
            }

            set
            {
                ((__Internal*)__Instance)->ofs_x = value;
            }
        }

        /// <summary>y offset of the bounding box. Measured from the top of the line</summary>
        public sbyte OfsY
        {
            get
            {
                return ((__Internal*)__Instance)->ofs_y;
            }

            set
            {
                ((__Internal*)__Instance)->ofs_y = value;
            }
        }
    }

    /// <summary>
    /// <para>Map codepoints to a `glyph_dsc`s</para>
    /// <para>Several formats are supported to optimize memory usage</para>
    /// <para>See https://github.com/lvgl/lv_font_conv/blob/master/doc/font_spec.md</para>
    /// </summary>
    public unsafe partial class LvFontFmtTxtCmapT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal uint range_start;
            internal ushort range_length;
            internal ushort glyph_id_start;
            internal __IntPtr unicode_list;
            internal __IntPtr glyph_id_ofs_list;
            internal ushort list_length;
            internal byte type;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_font_fmt_txt_cmap_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFontFmtTxtCmapT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFontFmtTxtCmapT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvFontFmtTxtCmapT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvFontFmtTxtCmapT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvFontFmtTxtCmapT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvFontFmtTxtCmapT(native.ToPointer(), skipVTables);
        }

        internal static LvFontFmtTxtCmapT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvFontFmtTxtCmapT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvFontFmtTxtCmapT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvFontFmtTxtCmapT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvFontFmtTxtCmapT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvFontFmtTxtCmapT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvFontFmtTxtCmapT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFontFmtTxtCmapT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvFontFmtTxtCmapT(global::lvgl.LvFontFmtTxtCmapT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFontFmtTxtCmapT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvFontFmtTxtCmapT.__Internal*) __Instance) = *((global::lvgl.LvFontFmtTxtCmapT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>First Unicode character for this range</summary>
        public uint RangeStart
        {
            get
            {
                return ((__Internal*)__Instance)->range_start;
            }

            set
            {
                ((__Internal*)__Instance)->range_start = value;
            }
        }

        /// <summary>
        /// <para>Number of Unicode characters related to this range.</para>
        /// <para>Last Unicode character = range_start + range_length - 1</para>
        /// </summary>
        public ushort RangeLength
        {
            get
            {
                return ((__Internal*)__Instance)->range_length;
            }

            set
            {
                ((__Internal*)__Instance)->range_length = value;
            }
        }

        /// <summary>First glyph ID (array index of `glyph_dsc`) for this range</summary>
        public ushort GlyphIdStart
        {
            get
            {
                return ((__Internal*)__Instance)->glyph_id_start;
            }

            set
            {
                ((__Internal*)__Instance)->glyph_id_start = value;
            }
        }

        public ushort* UnicodeList
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->unicode_list;
            }
        }

        /// <summary>
        /// <para>if(type == LV_FONT_FMT_TXT_CMAP_FORMAT0_...) it's `uint8_t *`</para>
        /// <para>if(type == LV_FONT_FMT_TXT_CMAP_SPARSE_...)  it's `uint16_t *`</para>
        /// </summary>
        public __IntPtr GlyphIdOfsList
        {
            get
            {
                return ((__Internal*)__Instance)->glyph_id_ofs_list;
            }
        }

        /// <summary>Length of `unicode_list` and/or `glyph_id_ofs_list`</summary>
        public ushort ListLength
        {
            get
            {
                return ((__Internal*)__Instance)->list_length;
            }

            set
            {
                ((__Internal*)__Instance)->list_length = value;
            }
        }

        /// <summary>Type of this character map</summary>
        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }
    }

    /// <summary>A simple mapping of kern values from pairs</summary>
    public unsafe partial class LvFontFmtTxtKernPairT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr glyph_ids;
            internal __IntPtr values;
            internal uint pair_cnt;
            internal uint glyph_ids_size;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_font_fmt_txt_kern_pair_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFontFmtTxtKernPairT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFontFmtTxtKernPairT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvFontFmtTxtKernPairT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvFontFmtTxtKernPairT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvFontFmtTxtKernPairT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvFontFmtTxtKernPairT(native.ToPointer(), skipVTables);
        }

        internal static LvFontFmtTxtKernPairT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvFontFmtTxtKernPairT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvFontFmtTxtKernPairT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvFontFmtTxtKernPairT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvFontFmtTxtKernPairT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvFontFmtTxtKernPairT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvFontFmtTxtKernPairT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFontFmtTxtKernPairT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvFontFmtTxtKernPairT(global::lvgl.LvFontFmtTxtKernPairT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFontFmtTxtKernPairT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvFontFmtTxtKernPairT.__Internal*) __Instance) = *((global::lvgl.LvFontFmtTxtKernPairT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr GlyphIds
        {
            get
            {
                return ((__Internal*)__Instance)->glyph_ids;
            }
        }

        public sbyte* Values
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->values;
            }
        }

        public uint PairCnt
        {
            get
            {
                return ((__Internal*)__Instance)->pair_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->pair_cnt = value;
            }
        }

        public uint GlyphIdsSize
        {
            get
            {
                return ((__Internal*)__Instance)->glyph_ids_size;
            }

            set
            {
                ((__Internal*)__Instance)->glyph_ids_size = value;
            }
        }
    }

    /// <summary>More complex but more optimal class based kern value storage</summary>
    public unsafe partial class LvFontFmtTxtKernClassesT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr class_pair_values;
            internal __IntPtr left_class_mapping;
            internal __IntPtr right_class_mapping;
            internal byte left_class_cnt;
            internal byte right_class_cnt;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_font_fmt_txt_kern_classes_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFontFmtTxtKernClassesT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFontFmtTxtKernClassesT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvFontFmtTxtKernClassesT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvFontFmtTxtKernClassesT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvFontFmtTxtKernClassesT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvFontFmtTxtKernClassesT(native.ToPointer(), skipVTables);
        }

        internal static LvFontFmtTxtKernClassesT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvFontFmtTxtKernClassesT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvFontFmtTxtKernClassesT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvFontFmtTxtKernClassesT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvFontFmtTxtKernClassesT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvFontFmtTxtKernClassesT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvFontFmtTxtKernClassesT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFontFmtTxtKernClassesT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvFontFmtTxtKernClassesT(global::lvgl.LvFontFmtTxtKernClassesT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFontFmtTxtKernClassesT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvFontFmtTxtKernClassesT.__Internal*) __Instance) = *((global::lvgl.LvFontFmtTxtKernClassesT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* ClassPairValues
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->class_pair_values;
            }
        }

        public byte* LeftClassMapping
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->left_class_mapping;
            }
        }

        public byte* RightClassMapping
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->right_class_mapping;
            }
        }

        public byte LeftClassCnt
        {
            get
            {
                return ((__Internal*)__Instance)->left_class_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->left_class_cnt = value;
            }
        }

        public byte RightClassCnt
        {
            get
            {
                return ((__Internal*)__Instance)->right_class_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->right_class_cnt = value;
            }
        }
    }

    public unsafe partial class LvFontFmtTxtDscT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr glyph_bitmap;

            [FieldOffset(8)]
            internal __IntPtr glyph_dsc;

            [FieldOffset(16)]
            internal __IntPtr cmaps;

            [FieldOffset(24)]
            internal __IntPtr kern_dsc;

            [FieldOffset(32)]
            internal ushort kern_scale;

            [FieldOffset(34)]
            internal ushort cmap_num;

            [FieldOffset(35)]
            internal ushort bpp;

            [FieldOffset(35)]
            internal ushort kern_classes;

            [FieldOffset(35)]
            internal ushort bitmap_format;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_font_fmt_txt_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFontFmtTxtDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvFontFmtTxtDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvFontFmtTxtDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvFontFmtTxtDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvFontFmtTxtDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvFontFmtTxtDscT(native.ToPointer(), skipVTables);
        }

        internal static LvFontFmtTxtDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvFontFmtTxtDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvFontFmtTxtDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvFontFmtTxtDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvFontFmtTxtDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvFontFmtTxtDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvFontFmtTxtDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFontFmtTxtDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvFontFmtTxtDscT(global::lvgl.LvFontFmtTxtDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvFontFmtTxtDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvFontFmtTxtDscT.__Internal*) __Instance) = *((global::lvgl.LvFontFmtTxtDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte* GlyphBitmap
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->glyph_bitmap;
            }
        }

        public global::lvgl.LvFontFmtTxtGlyphDscT GlyphDsc
        {
            get
            {
                var __result0 = global::lvgl.LvFontFmtTxtGlyphDscT.__GetOrCreateInstance(((__Internal*)__Instance)->glyph_dsc, false);
                return __result0;
            }
        }

        public global::lvgl.LvFontFmtTxtCmapT Cmaps
        {
            get
            {
                var __result0 = global::lvgl.LvFontFmtTxtCmapT.__GetOrCreateInstance(((__Internal*)__Instance)->cmaps, false);
                return __result0;
            }
        }

        /// <summary>
        /// <para>Store kerning values.</para>
        /// <para>Can be `lv_font_fmt_txt_kern_pair_t *  or `lv_font_kern_classes_fmt_txt_t *`</para>
        /// <para>depending on `kern_classes`</para>
        /// </summary>
        public __IntPtr KernDsc
        {
            get
            {
                return ((__Internal*)__Instance)->kern_dsc;
            }
        }

        public ushort KernScale
        {
            get
            {
                return ((__Internal*)__Instance)->kern_scale;
            }

            set
            {
                ((__Internal*)__Instance)->kern_scale = value;
            }
        }

        public ushort CmapNum
        {
            get
            {
                return ((__Internal*)__Instance)->cmap_num;
            }

            set
            {
                ((__Internal*)__Instance)->cmap_num = value;
            }
        }

        public ushort Bpp
        {
            get
            {
                return ((__Internal*)__Instance)->bpp;
            }

            set
            {
                ((__Internal*)__Instance)->bpp = value;
            }
        }

        public ushort KernClasses
        {
            get
            {
                return ((__Internal*)__Instance)->kern_classes;
            }

            set
            {
                ((__Internal*)__Instance)->kern_classes = value;
            }
        }

        public ushort BitmapFormat
        {
            get
            {
                return ((__Internal*)__Instance)->bitmap_format;
            }

            set
            {
                ((__Internal*)__Instance)->bitmap_format = value;
            }
        }
    }

    public unsafe partial class lv_font_fmt_txt
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_font_get_bitmap_fmt_txt", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvFontGetBitmapFmtTxt(__IntPtr g_dsc, __IntPtr draw_buf);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_font_get_glyph_dsc_fmt_txt", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvFontGetGlyphDscFmtTxt(__IntPtr font, __IntPtr dsc_out, uint unicode_letter, uint unicode_letter_next);
        }

        /// <summary>Used as `get_glyph_bitmap` callback in lvgl's native font format if the font is uncompressed.</summary>
        /// <param name="g_dsc">the glyph descriptor including which font to use, which supply the glyph_index and format.</param>
        /// <param name="draw_buf">a draw buffer that can be used to store the bitmap of the glyph, it's OK not to use it.</param>
        /// <returns>pointer to an A8 bitmap (not necessarily bitmap_out) or NULL if `unicode_letter` not found</returns>
        public static __IntPtr LvFontGetBitmapFmtTxt(global::lvgl.LvFontGlyphDscT g_dsc, global::lvgl.LvDrawBufT draw_buf)
        {
            var __arg0 = g_dsc is null ? __IntPtr.Zero : g_dsc.__Instance;
            var __arg1 = draw_buf is null ? __IntPtr.Zero : draw_buf.__Instance;
            var ___ret = __Internal.LvFontGetBitmapFmtTxt(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Used as `get_glyph_dsc` callback in lvgl's native font format if the font is uncompressed.</summary>
        /// <param name="font">pointer to font</param>
        /// <param name="dsc_out">store the result descriptor here</param>
        /// <param name="unicode_letter">a UNICODE letter code</param>
        /// <param name="unicode_letter_next">the unicode letter succeeding the letter under test</param>
        /// <returns>
        /// <para>true: descriptor is successfully loaded into `dsc_out`.</para>
        /// <para>false: the letter was not found, no data is loaded to `dsc_out`</para>
        /// </returns>
        public static bool LvFontGetGlyphDscFmtTxt(global::lvgl.LvFontT font, global::lvgl.LvFontGlyphDscT dsc_out, uint unicode_letter, uint unicode_letter_next)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            var __arg1 = dsc_out is null ? __IntPtr.Zero : dsc_out.__Instance;
            var ___ret = __Internal.LvFontGetGlyphDscFmtTxt(__arg0, __arg1, unicode_letter, unicode_letter_next);
            return ___ret;
        }
    }

    public enum LvAnimimgPartT
    {
        LV_ANIM_IMAGE_PART_MAIN = 0
    }

    public unsafe partial class LvAnimimgT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 264)]
        public partial struct __Internal
        {
            internal global::lvgl.LvImageT.__Internal img;
            internal global::lvgl.LvAnimT.__Internal anim;
            internal __IntPtr dsc;
            internal sbyte pic_count;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_animimg_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvAnimimgT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvAnimimgT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvAnimimgT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvAnimimgT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvAnimimgT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvAnimimgT(native.ToPointer(), skipVTables);
        }

        internal static LvAnimimgT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvAnimimgT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvAnimimgT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvAnimimgT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvAnimimgT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvAnimimgT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvAnimimgT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvAnimimgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvAnimimgT(global::lvgl.LvAnimimgT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvAnimimgT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvAnimimgT.__Internal*) __Instance) = *((global::lvgl.LvAnimimgT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvImageT Img
        {
            get
            {
                return global::lvgl.LvImageT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->img));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->img = *(global::lvgl.LvImageT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvAnimT Anim
        {
            get
            {
                return global::lvgl.LvAnimT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->anim));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->anim = *(global::lvgl.LvAnimT.__Internal*) value.__Instance;
            }
        }

        public sbyte PicCount
        {
            get
            {
                return ((__Internal*)__Instance)->pic_count;
            }

            set
            {
                ((__Internal*)__Instance)->pic_count = value;
            }
        }
    }

    public unsafe partial class lv_animimage
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_animimg_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvAnimimgCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_animimg_set_src", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAnimimgSetSrc(__IntPtr img, __IntPtr[] dsc, ulong num);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_animimg_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAnimimgStart(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_animimg_set_duration", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAnimimgSetDuration(__IntPtr img, uint duration);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_animimg_set_repeat_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvAnimimgSetRepeatCount(__IntPtr img, uint count);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_animimg_get_src", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr* LvAnimimgGetSrc(__IntPtr img);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_animimg_get_src_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvAnimimgGetSrcCount(__IntPtr img);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_animimg_get_duration", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvAnimimgGetDuration(__IntPtr img);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_animimg_get_repeat_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvAnimimgGetRepeatCount(__IntPtr img);
        }

        /// <summary>Create an animation image objects</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new button</param>
        /// <returns>pointer to the created animation image object</returns>
        public static global::lvgl.LvObjT LvAnimimgCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvAnimimgCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the image animation images source.</summary>
        /// <param name="img">pointer to an animation image object</param>
        /// <param name="dsc">pointer to a series images</param>
        /// <param name="num">images' number</param>
        public static void LvAnimimgSetSrc(global::lvgl.LvObjT img, __IntPtr[] dsc, ulong num)
        {
            var __arg0 = img is null ? __IntPtr.Zero : img.__Instance;
            __Internal.LvAnimimgSetSrc(__arg0, dsc, num);
        }

        /// <summary>Startup the image animation.</summary>
        /// <param name="obj">pointer to an animation image object</param>
        public static void LvAnimimgStart(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvAnimimgStart(__arg0);
        }

        /// <summary>Set the image animation duration time. unit:ms</summary>
        /// <param name="img">pointer to an animation image object</param>
        /// <param name="duration">the duration in milliseconds</param>
        public static void LvAnimimgSetDuration(global::lvgl.LvObjT img, uint duration)
        {
            var __arg0 = img is null ? __IntPtr.Zero : img.__Instance;
            __Internal.LvAnimimgSetDuration(__arg0, duration);
        }

        /// <summary>Set the image animation repeatedly play times.</summary>
        /// <param name="img">pointer to an animation image object</param>
        /// <param name="count">the number of times to repeat the animation</param>
        public static void LvAnimimgSetRepeatCount(global::lvgl.LvObjT img, uint count)
        {
            var __arg0 = img is null ? __IntPtr.Zero : img.__Instance;
            __Internal.LvAnimimgSetRepeatCount(__arg0, count);
        }

        /// <summary>Get the image animation images source.</summary>
        /// <param name="img">pointer to an animation image object</param>
        /// <returns>a    pointer that will point to a series images</returns>
        public static __IntPtr* LvAnimimgGetSrc(global::lvgl.LvObjT img)
        {
            var __arg0 = img is null ? __IntPtr.Zero : img.__Instance;
            var ___ret = __Internal.LvAnimimgGetSrc(__arg0);
            return ___ret;
        }

        /// <summary>Get the image animation images source.</summary>
        /// <param name="img">pointer to an animation image object</param>
        /// <returns>the number of source images</returns>
        public static byte LvAnimimgGetSrcCount(global::lvgl.LvObjT img)
        {
            var __arg0 = img is null ? __IntPtr.Zero : img.__Instance;
            var ___ret = __Internal.LvAnimimgGetSrcCount(__arg0);
            return ___ret;
        }

        /// <summary>Get the image animation duration time. unit:ms</summary>
        /// <param name="img">pointer to an animation image object</param>
        /// <returns>the animation duration time</returns>
        public static uint LvAnimimgGetDuration(global::lvgl.LvObjT img)
        {
            var __arg0 = img is null ? __IntPtr.Zero : img.__Instance;
            var ___ret = __Internal.LvAnimimgGetDuration(__arg0);
            return ___ret;
        }

        /// <summary>Get the image animation repeat play times.</summary>
        /// <param name="img">pointer to an animation image object</param>
        /// <returns>the repeat count</returns>
        public static uint LvAnimimgGetRepeatCount(global::lvgl.LvObjT img)
        {
            var __arg0 = img is null ? __IntPtr.Zero : img.__Instance;
            var ___ret = __Internal.LvAnimimgGetRepeatCount(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>********************</para>
        /// <para>TYPEDEFS</para>
        /// <para>********************</para>
        /// </summary>
        public static global::lvgl.LvObjClassT LvAnimimgClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_animimg_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>Image size mode, when image size and object size is different</summary>
    public enum LvImageAlignT
    {
        LV_IMAGE_ALIGN_DEFAULT = 0,
        LV_IMAGE_ALIGN_TOP_LEFT = 1,
        LV_IMAGE_ALIGN_TOP_MID = 2,
        LV_IMAGE_ALIGN_TOP_RIGHT = 3,
        LV_IMAGE_ALIGN_BOTTOM_LEFT = 4,
        LV_IMAGE_ALIGN_BOTTOM_MID = 5,
        LV_IMAGE_ALIGN_BOTTOM_RIGHT = 6,
        LV_IMAGE_ALIGN_LEFT_MID = 7,
        LV_IMAGE_ALIGN_RIGHT_MID = 8,
        LV_IMAGE_ALIGN_CENTER = 9,
        LV_IMAGE_ALIGN_AUTO_TRANSFORM = 10,
        LV_IMAGE_ALIGN_STRETCH = 11,
        LV_IMAGE_ALIGN_TILE = 12
    }

    /// <summary>Data of image</summary>
    /// <summary>Data of image</summary>
    public unsafe partial class LvImageT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 120)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvObjT.__Internal obj;

            [FieldOffset(64)]
            internal __IntPtr src;

            [FieldOffset(72)]
            internal __IntPtr bitmap_mask_src;

            [FieldOffset(80)]
            internal global::lvgl.LvPointT.__Internal offset;

            [FieldOffset(88)]
            internal int w;

            [FieldOffset(92)]
            internal int h;

            [FieldOffset(96)]
            internal uint rotation;

            [FieldOffset(100)]
            internal uint scale_x;

            [FieldOffset(104)]
            internal uint scale_y;

            [FieldOffset(108)]
            internal global::lvgl.LvPointT.__Internal pivot;

            [FieldOffset(116)]
            internal uint src_type;

            [FieldOffset(116)]
            internal uint cf;

            [FieldOffset(116)]
            internal uint antialias;

            [FieldOffset(117)]
            internal uint align;

            [FieldOffset(117)]
            internal uint blend_mode;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_image_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImageT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImageT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvImageT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvImageT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvImageT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvImageT(native.ToPointer(), skipVTables);
        }

        internal static LvImageT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvImageT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvImageT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvImageT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvImageT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvImageT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvImageT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImageT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvImageT(global::lvgl.LvImageT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImageT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvImageT.__Internal*) __Instance) = *((global::lvgl.LvImageT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Image source: Pointer to an array or a file or a symbol</summary>
        public __IntPtr Src
        {
            get
            {
                return ((__Internal*)__Instance)->src;
            }
        }

        /// <summary>Pointer to an A8 bitmap mask</summary>
        public global::lvgl.LvImageDscT BitmapMaskSrc
        {
            get
            {
                var __result0 = global::lvgl.LvImageDscT.__GetOrCreateInstance(((__Internal*)__Instance)->bitmap_mask_src, false);
                return __result0;
            }
        }

        public global::lvgl.LvPointT Offset
        {
            get
            {
                return global::lvgl.LvPointT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->offset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->offset = *(global::lvgl.LvPointT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Width of the image (Handled by the library)</summary>
        public int W
        {
            get
            {
                return ((__Internal*)__Instance)->w;
            }

            set
            {
                ((__Internal*)__Instance)->w = value;
            }
        }

        /// <summary>Height of the image (Handled by the library)</summary>
        public int H
        {
            get
            {
                return ((__Internal*)__Instance)->h;
            }

            set
            {
                ((__Internal*)__Instance)->h = value;
            }
        }

        /// <summary>Rotation angle of the image</summary>
        public uint Rotation
        {
            get
            {
                return ((__Internal*)__Instance)->rotation;
            }

            set
            {
                ((__Internal*)__Instance)->rotation = value;
            }
        }

        /// <summary>256 means no zoom, 512 double size, 128 half size</summary>
        public uint ScaleX
        {
            get
            {
                return ((__Internal*)__Instance)->scale_x;
            }

            set
            {
                ((__Internal*)__Instance)->scale_x = value;
            }
        }

        /// <summary>256 means no zoom, 512 double size, 128 half size</summary>
        public uint ScaleY
        {
            get
            {
                return ((__Internal*)__Instance)->scale_y;
            }

            set
            {
                ((__Internal*)__Instance)->scale_y = value;
            }
        }

        /// <summary>Rotation center of the image</summary>
        public global::lvgl.LvPointT Pivot
        {
            get
            {
                return global::lvgl.LvPointT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->pivot));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->pivot = *(global::lvgl.LvPointT.__Internal*) value.__Instance;
            }
        }

        /// <summary>See: lv_image_src_t</summary>
        public uint SrcType
        {
            get
            {
                return ((__Internal*)__Instance)->src_type;
            }

            set
            {
                ((__Internal*)__Instance)->src_type = value;
            }
        }

        /// <summary>Color format from `lv_color_format_t`</summary>
        public uint Cf
        {
            get
            {
                return ((__Internal*)__Instance)->cf;
            }

            set
            {
                ((__Internal*)__Instance)->cf = value;
            }
        }

        /// <summary>Apply anti-aliasing in transformations (rotate, zoom)</summary>
        public uint Antialias
        {
            get
            {
                return ((__Internal*)__Instance)->antialias;
            }

            set
            {
                ((__Internal*)__Instance)->antialias = value;
            }
        }

        /// <summary>Image size mode when image size and object size is different. See `lv_image_align_t`</summary>
        public uint Align
        {
            get
            {
                return ((__Internal*)__Instance)->align;
            }

            set
            {
                ((__Internal*)__Instance)->align = value;
            }
        }

        /// <summary>Element of `lv_blend_mode_t`</summary>
        public uint BlendMode
        {
            get
            {
                return ((__Internal*)__Instance)->blend_mode;
            }

            set
            {
                ((__Internal*)__Instance)->blend_mode = value;
            }
        }
    }

    public unsafe partial class lv_image
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvImageCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_set_src", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageSetSrc(__IntPtr obj, __IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_set_offset_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageSetOffsetX(__IntPtr obj, int x);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_set_offset_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageSetOffsetY(__IntPtr obj, int y);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_set_rotation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageSetRotation(__IntPtr obj, int angle);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_set_pivot", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageSetPivot(__IntPtr obj, int x, int y);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_set_scale", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageSetScale(__IntPtr obj, uint zoom);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_set_scale_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageSetScaleX(__IntPtr obj, uint zoom);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_set_scale_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageSetScaleY(__IntPtr obj, uint zoom);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_set_blend_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageSetBlendMode(__IntPtr obj, byte blend_mode);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_set_antialias", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageSetAntialias(__IntPtr obj, bool antialias);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_set_inner_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageSetInnerAlign(__IntPtr obj, byte align);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_set_bitmap_map_src", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageSetBitmapMapSrc(__IntPtr obj, __IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_get_src", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvImageGetSrc(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_get_offset_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvImageGetOffsetX(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_get_offset_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvImageGetOffsetY(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_get_rotation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvImageGetRotation(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_get_pivot", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImageGetPivot(__IntPtr obj, __IntPtr pivot);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_get_scale", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvImageGetScale(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_get_scale_x", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvImageGetScaleX(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_get_scale_y", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvImageGetScaleY(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_get_blend_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvImageGetBlendMode(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_get_antialias", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvImageGetAntialias(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_get_inner_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvImageGetInnerAlign(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_image_get_bitmap_map_src", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvImageGetBitmapMapSrc(__IntPtr obj);
        }

        /// <summary>Create an image object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new image</param>
        /// <returns>pointer to the created image</returns>
        public static global::lvgl.LvObjT LvImageCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvImageCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the image data to display on the object</summary>
        /// <param name="obj">pointer to an image object</param>
        /// <param name="src">
        /// <para>1) pointer to an ::lv_image_dsc_t descriptor (converted by LVGL's image converter) (e.g.&amp;my_img) or</para>
        /// <para>2) path to an image file (e.g. &quot;S:/dir/img.bin&quot;)or</para>
        /// <para>3) a SYMBOL (e.g. LV_SYMBOL_OK)</para>
        /// </param>
        public static void LvImageSetSrc(global::lvgl.LvObjT obj, __IntPtr src)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvImageSetSrc(__arg0, src);
        }

        /// <summary>Set an offset for the source of an image so the image will be displayed from the new origin.</summary>
        /// <param name="obj">pointer to an image</param>
        /// <param name="x">the new offset along x axis.</param>
        public static void LvImageSetOffsetX(global::lvgl.LvObjT obj, int x)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvImageSetOffsetX(__arg0, x);
        }

        /// <summary>
        /// <para>Set an offset for the source of an image.</para>
        /// <para>so the image will be displayed from the new origin.</para>
        /// </summary>
        /// <param name="obj">pointer to an image</param>
        /// <param name="y">the new offset along y axis.</param>
        public static void LvImageSetOffsetY(global::lvgl.LvObjT obj, int y)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvImageSetOffsetY(__arg0, y);
        }

        /// <summary>
        /// <para>Set the rotation angle of the image.</para>
        /// <para>The image will be rotated around the set pivot set by `lv_image_set_pivot()`</para>
        /// <para>Note that indexed and alpha only images can't be transformed.</para>
        /// </summary>
        /// <param name="obj">pointer to an image object</param>
        /// <param name="angle">rotation in degree with 0.1 degree resolution (0..3600: clock wise)</param>
        /// <remarks>
        /// <para>if image_align is `LV_IMAGE_ALIGN_STRETCH` or `LV_IMAGE_ALIGN_FIT`</para>
        /// <para>rotation will be set to 0 automatically.</para>
        /// </remarks>
        public static void LvImageSetRotation(global::lvgl.LvObjT obj, int angle)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvImageSetRotation(__arg0, angle);
        }

        /// <summary>
        /// <para>Set the rotation center of the image.</para>
        /// <para>The image will be rotated around this point.</para>
        /// <para>x, y can be set with value of LV_PCT, lv_image_get_pivot will return the true pixel coordinate of pivot in this case.</para>
        /// </summary>
        /// <param name="obj">pointer to an image object</param>
        /// <param name="x">rotation center x of the image</param>
        /// <param name="y">rotation center y of the image</param>
        public static void LvImageSetPivot(global::lvgl.LvObjT obj, int x, int y)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvImageSetPivot(__arg0, x, y);
        }

        /// <summary>
        /// <para>Set the zoom factor of the image.</para>
        /// <para>Note that indexed and alpha only images can't be transformed.</para>
        /// </summary>
        /// <param name="img">pointer to an image object</param>
        /// <param name="zoom">the zoom factor.</param>
        public static void LvImageSetScale(global::lvgl.LvObjT obj, uint zoom)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvImageSetScale(__arg0, zoom);
        }

        /// <summary>
        /// <para>Set the horizontal zoom factor of the image.</para>
        /// <para>Note that indexed and alpha only images can't be transformed.</para>
        /// </summary>
        /// <param name="img">pointer to an image object</param>
        /// <param name="zoom">the zoom factor.</param>
        public static void LvImageSetScaleX(global::lvgl.LvObjT obj, uint zoom)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvImageSetScaleX(__arg0, zoom);
        }

        /// <summary>
        /// <para>Set the vertical zoom factor of the image.</para>
        /// <para>Note that indexed and alpha only images can't be transformed.</para>
        /// </summary>
        /// <param name="img">pointer to an image object</param>
        /// <param name="zoom">the zoom factor.</param>
        public static void LvImageSetScaleY(global::lvgl.LvObjT obj, uint zoom)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvImageSetScaleY(__arg0, zoom);
        }

        /// <summary>Set the blend mode of an image.</summary>
        /// <param name="obj">pointer to an image object</param>
        /// <param name="blend_mode">the new blend mode</param>
        public static void LvImageSetBlendMode(global::lvgl.LvObjT obj, byte blend_mode)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvImageSetBlendMode(__arg0, blend_mode);
        }

        /// <summary>
        /// <para>Enable/disable anti-aliasing for the transformations (rotate, zoom) or not.</para>
        /// <para>The quality is better with anti-aliasing looks better but slower.</para>
        /// </summary>
        /// <param name="obj">pointer to an image object</param>
        /// <param name="antialias">true: anti-aliased; false: not anti-aliased</param>
        public static void LvImageSetAntialias(global::lvgl.LvObjT obj, bool antialias)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvImageSetAntialias(__arg0, antialias);
        }

        /// <summary>Set the image object size mode.</summary>
        /// <param name="obj">pointer to an image object</param>
        /// <param name="align">the new align mode.</param>
        /// <remarks>
        /// <para>if image_align is `LV_IMAGE_ALIGN_STRETCH` or `LV_IMAGE_ALIGN_FIT`</para>
        /// <para>rotation, scale and pivot will be overwritten and controlled internally.</para>
        /// </remarks>
        public static void LvImageSetInnerAlign(global::lvgl.LvObjT obj, byte align)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvImageSetInnerAlign(__arg0, align);
        }

        /// <summary>Set an A8 bitmap mask for the image.</summary>
        /// <param name="obj">pointer to an image object</param>
        /// <param name="src">an lv_image_dsc_t bitmap mask source.</param>
        public static void LvImageSetBitmapMapSrc(global::lvgl.LvObjT obj, global::lvgl.LvImageDscT src)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = src is null ? __IntPtr.Zero : src.__Instance;
            __Internal.LvImageSetBitmapMapSrc(__arg0, __arg1);
        }

        /// <summary>Get the source of the image</summary>
        /// <param name="obj">pointer to an image object</param>
        /// <returns>the image source (symbol, file name or ::lv-img_dsc_t for C arrays)</returns>
        public static __IntPtr LvImageGetSrc(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvImageGetSrc(__arg0);
            return ___ret;
        }

        /// <summary>Get the offset's x attribute of the image object.</summary>
        /// <param name="obj">pointer to an image</param>
        /// <returns>offset X value.</returns>
        public static int LvImageGetOffsetX(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvImageGetOffsetX(__arg0);
            return ___ret;
        }

        /// <summary>Get the offset's y attribute of the image object.</summary>
        /// <param name="obj">pointer to an image</param>
        /// <returns>offset Y value.</returns>
        public static int LvImageGetOffsetY(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvImageGetOffsetY(__arg0);
            return ___ret;
        }

        /// <summary>Get the rotation of the image.</summary>
        /// <param name="obj">pointer to an image object</param>
        /// <returns>rotation in 0.1 degrees (0..3600)</returns>
        /// <remarks>
        /// <para>if image_align is `LV_IMAGE_ALIGN_STRETCH` or  `LV_IMAGE_ALIGN_FIT`</para>
        /// <para>rotation will be set to 0 automatically.</para>
        /// </remarks>
        public static int LvImageGetRotation(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvImageGetRotation(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Get the pivot (rotation center) of the image.</para>
        /// <para>If pivot is set with LV_PCT, convert it to px before return.</para>
        /// </summary>
        /// <param name="obj">pointer to an image object</param>
        /// <param name="pivot">store the rotation center here</param>
        public static void LvImageGetPivot(global::lvgl.LvObjT obj, global::lvgl.LvPointT pivot)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = pivot is null ? __IntPtr.Zero : pivot.__Instance;
            __Internal.LvImageGetPivot(__arg0, __arg1);
        }

        /// <summary>Get the zoom factor of the image.</summary>
        /// <param name="obj">pointer to an image object</param>
        /// <returns>zoom factor (256: no zoom)</returns>
        public static int LvImageGetScale(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvImageGetScale(__arg0);
            return ___ret;
        }

        /// <summary>Get the horizontal zoom factor of the image.</summary>
        /// <param name="obj">pointer to an image object</param>
        /// <returns>zoom factor (256: no zoom)</returns>
        public static int LvImageGetScaleX(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvImageGetScaleX(__arg0);
            return ___ret;
        }

        /// <summary>Get the vertical zoom factor of the image.</summary>
        /// <param name="obj">pointer to an image object</param>
        /// <returns>zoom factor (256: no zoom)</returns>
        public static int LvImageGetScaleY(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvImageGetScaleY(__arg0);
            return ___ret;
        }

        /// <summary>Get the current blend mode of the image</summary>
        /// <param name="obj">pointer to an image object</param>
        /// <returns>the current blend mode</returns>
        public static byte LvImageGetBlendMode(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvImageGetBlendMode(__arg0);
            return ___ret;
        }

        /// <summary>Get whether the transformations (rotate, zoom) are anti-aliased or not</summary>
        /// <param name="obj">pointer to an image object</param>
        /// <returns>true: anti-aliased; false: not anti-aliased</returns>
        public static bool LvImageGetAntialias(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvImageGetAntialias(__arg0);
            return ___ret;
        }

        /// <summary>Get the size mode of the image</summary>
        /// <param name="obj">pointer to an image object</param>
        /// <returns>element of</returns>
        public static byte LvImageGetInnerAlign(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvImageGetInnerAlign(__arg0);
            return ___ret;
        }

        /// <summary>Get the bitmap mask source.</summary>
        /// <param name="obj">pointer to an image object</param>
        /// <returns>an lv_image_dsc_t bitmap mask source.</returns>
        public static global::lvgl.LvImageDscT LvImageGetBitmapMapSrc(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvImageGetBitmapMapSrc(__arg0);
            var __result0 = global::lvgl.LvImageDscT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::lvgl.LvObjClassT LvImageClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_image_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public enum LvArcModeT
    {
        LV_ARC_MODE_NORMAL = 0,
        LV_ARC_MODE_SYMMETRICAL = 1,
        LV_ARC_MODE_REVERSE = 2
    }

    public unsafe partial class LvArcT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 120)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvObjT.__Internal obj;

            [FieldOffset(64)]
            internal int rotation;

            [FieldOffset(68)]
            internal int indic_angle_start;

            [FieldOffset(72)]
            internal int indic_angle_end;

            [FieldOffset(76)]
            internal int bg_angle_start;

            [FieldOffset(80)]
            internal int bg_angle_end;

            [FieldOffset(84)]
            internal int value;

            [FieldOffset(88)]
            internal int min_value;

            [FieldOffset(92)]
            internal int max_value;

            [FieldOffset(96)]
            internal uint dragging;

            [FieldOffset(96)]
            internal uint type;

            [FieldOffset(96)]
            internal uint min_close;

            [FieldOffset(96)]
            internal uint in_out;

            [FieldOffset(100)]
            internal uint chg_rate;

            [FieldOffset(104)]
            internal uint last_tick;

            [FieldOffset(108)]
            internal int last_angle;

            [FieldOffset(112)]
            internal short knob_offset;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_arc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvArcT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvArcT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvArcT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvArcT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvArcT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvArcT(native.ToPointer(), skipVTables);
        }

        internal static LvArcT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvArcT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvArcT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvArcT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvArcT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvArcT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvArcT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvArcT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvArcT(global::lvgl.LvArcT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvArcT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvArcT.__Internal*) __Instance) = *((global::lvgl.LvArcT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        public int Rotation
        {
            get
            {
                return ((__Internal*)__Instance)->rotation;
            }

            set
            {
                ((__Internal*)__Instance)->rotation = value;
            }
        }

        public int IndicAngleStart
        {
            get
            {
                return ((__Internal*)__Instance)->indic_angle_start;
            }

            set
            {
                ((__Internal*)__Instance)->indic_angle_start = value;
            }
        }

        public int IndicAngleEnd
        {
            get
            {
                return ((__Internal*)__Instance)->indic_angle_end;
            }

            set
            {
                ((__Internal*)__Instance)->indic_angle_end = value;
            }
        }

        public int BgAngleStart
        {
            get
            {
                return ((__Internal*)__Instance)->bg_angle_start;
            }

            set
            {
                ((__Internal*)__Instance)->bg_angle_start = value;
            }
        }

        public int BgAngleEnd
        {
            get
            {
                return ((__Internal*)__Instance)->bg_angle_end;
            }

            set
            {
                ((__Internal*)__Instance)->bg_angle_end = value;
            }
        }

        public int Value
        {
            get
            {
                return ((__Internal*)__Instance)->value;
            }

            set
            {
                ((__Internal*)__Instance)->value = value;
            }
        }

        public int MinValue
        {
            get
            {
                return ((__Internal*)__Instance)->min_value;
            }

            set
            {
                ((__Internal*)__Instance)->min_value = value;
            }
        }

        public int MaxValue
        {
            get
            {
                return ((__Internal*)__Instance)->max_value;
            }

            set
            {
                ((__Internal*)__Instance)->max_value = value;
            }
        }

        public uint Dragging
        {
            get
            {
                return ((__Internal*)__Instance)->dragging;
            }

            set
            {
                ((__Internal*)__Instance)->dragging = value;
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint MinClose
        {
            get
            {
                return ((__Internal*)__Instance)->min_close;
            }

            set
            {
                ((__Internal*)__Instance)->min_close = value;
            }
        }

        public uint InOut
        {
            get
            {
                return ((__Internal*)__Instance)->in_out;
            }

            set
            {
                ((__Internal*)__Instance)->in_out = value;
            }
        }

        public uint ChgRate
        {
            get
            {
                return ((__Internal*)__Instance)->chg_rate;
            }

            set
            {
                ((__Internal*)__Instance)->chg_rate = value;
            }
        }

        public uint LastTick
        {
            get
            {
                return ((__Internal*)__Instance)->last_tick;
            }

            set
            {
                ((__Internal*)__Instance)->last_tick = value;
            }
        }

        public int LastAngle
        {
            get
            {
                return ((__Internal*)__Instance)->last_angle;
            }

            set
            {
                ((__Internal*)__Instance)->last_angle = value;
            }
        }

        public short KnobOffset
        {
            get
            {
                return ((__Internal*)__Instance)->knob_offset;
            }

            set
            {
                ((__Internal*)__Instance)->knob_offset = value;
            }
        }
    }

    public unsafe partial class lv_arc
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvArcCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_set_start_angle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArcSetStartAngle(__IntPtr obj, int start);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_set_end_angle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArcSetEndAngle(__IntPtr obj, int end);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_set_angles", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArcSetAngles(__IntPtr obj, int start, int end);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_set_bg_start_angle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArcSetBgStartAngle(__IntPtr obj, int start);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_set_bg_end_angle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArcSetBgEndAngle(__IntPtr obj, int end);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_set_bg_angles", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArcSetBgAngles(__IntPtr obj, int start, int end);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_set_rotation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArcSetRotation(__IntPtr obj, int rotation);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_set_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArcSetMode(__IntPtr obj, byte type);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_set_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArcSetValue(__IntPtr obj, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_set_range", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArcSetRange(__IntPtr obj, int min, int max);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_set_change_rate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArcSetChangeRate(__IntPtr obj, uint rate);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_set_knob_offset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArcSetKnobOffset(__IntPtr obj, int offset);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_get_angle_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvArcGetAngleStart(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_get_angle_end", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvArcGetAngleEnd(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_get_bg_angle_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvArcGetBgAngleStart(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_get_bg_angle_end", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvArcGetBgAngleEnd(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_get_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvArcGetValue(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_get_min_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvArcGetMinValue(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_get_max_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvArcGetMaxValue(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_get_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvArcGetMode(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_get_rotation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvArcGetRotation(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_get_knob_offset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvArcGetKnobOffset(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_align_obj_to_angle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArcAlignObjToAngle(__IntPtr obj, __IntPtr obj_to_align, int r_offset);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_rotate_obj_to_angle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvArcRotateObjToAngle(__IntPtr obj, __IntPtr obj_to_rotate, int r_offset);
        }

        /// <summary>Create an arc object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new arc</param>
        /// <returns>pointer to the created arc</returns>
        public static global::lvgl.LvObjT LvArcCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvArcCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the start angle of an arc. 0 deg: right, 90 bottom, etc.</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <param name="start">the start angle. (if `LV_USE_FLOAT` is enabled it can be fractional too.)</param>
        public static void LvArcSetStartAngle(global::lvgl.LvObjT obj, int start)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvArcSetStartAngle(__arg0, start);
        }

        /// <summary>Set the end angle of an arc. 0 deg: right, 90 bottom, etc.</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <param name="end">the end angle  (if `LV_USE_FLOAT` is enabled it can be fractional too.)</param>
        public static void LvArcSetEndAngle(global::lvgl.LvObjT obj, int end)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvArcSetEndAngle(__arg0, end);
        }

        /// <summary>Set the start and end angles</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <param name="start">the start angle  (if `LV_USE_FLOAT` is enabled it can be fractional too.)</param>
        /// <param name="end">the end angle  (if `LV_USE_FLOAT` is enabled it can be fractional too.)</param>
        public static void LvArcSetAngles(global::lvgl.LvObjT obj, int start, int end)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvArcSetAngles(__arg0, start, end);
        }

        /// <summary>Set the start angle of an arc background. 0 deg: right, 90 bottom, etc.</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <param name="start">the start angle  (if `LV_USE_FLOAT` is enabled it can be fractional too.)</param>
        public static void LvArcSetBgStartAngle(global::lvgl.LvObjT obj, int start)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvArcSetBgStartAngle(__arg0, start);
        }

        /// <summary>Set the start angle of an arc background. 0 deg: right, 90 bottom etc.</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <param name="end">the end angle  (if `LV_USE_FLOAT` is enabled it can be fractional too.)</param>
        public static void LvArcSetBgEndAngle(global::lvgl.LvObjT obj, int end)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvArcSetBgEndAngle(__arg0, end);
        }

        /// <summary>Set the start and end angles of the arc background</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <param name="start">the start angle  (if `LV_USE_FLOAT` is enabled it can be fractional too.)</param>
        /// <param name="end">the end angle  (if `LV_USE_FLOAT` is enabled it can be fractional too.)</param>
        public static void LvArcSetBgAngles(global::lvgl.LvObjT obj, int start, int end)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvArcSetBgAngles(__arg0, start, end);
        }

        /// <summary>Set the rotation for the whole arc</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <param name="rotation">rotation angle</param>
        public static void LvArcSetRotation(global::lvgl.LvObjT obj, int rotation)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvArcSetRotation(__arg0, rotation);
        }

        /// <summary>Set the type of arc.</summary>
        /// <param name="obj">pointer to arc object</param>
        /// <param name="type">arc's mode</param>
        public static void LvArcSetMode(global::lvgl.LvObjT obj, byte type)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvArcSetMode(__arg0, type);
        }

        /// <summary>Set a new value on the arc</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <param name="value">new value</param>
        public static void LvArcSetValue(global::lvgl.LvObjT obj, int value)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvArcSetValue(__arg0, value);
        }

        /// <summary>Set minimum and the maximum values of an arc</summary>
        /// <param name="obj">pointer to the arc object</param>
        /// <param name="min">minimum value</param>
        /// <param name="max">maximum value</param>
        public static void LvArcSetRange(global::lvgl.LvObjT obj, int min, int max)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvArcSetRange(__arg0, min, max);
        }

        /// <summary>Set a change rate to limit the speed how fast the arc should reach the pressed point.</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <param name="rate">the change rate</param>
        public static void LvArcSetChangeRate(global::lvgl.LvObjT obj, uint rate)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvArcSetChangeRate(__arg0, rate);
        }

        /// <summary>Set an offset angle for the knob</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <param name="offset">knob offset from main arc in degrees</param>
        public static void LvArcSetKnobOffset(global::lvgl.LvObjT obj, int offset)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvArcSetKnobOffset(__arg0, offset);
        }

        /// <summary>Get the start angle of an arc.</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <returns>the start angle [0..360]  (if `LV_USE_FLOAT` is enabled it can be fractional too.)</returns>
        public static int LvArcGetAngleStart(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvArcGetAngleStart(__arg0);
            return ___ret;
        }

        /// <summary>Get the end angle of an arc.</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <returns>the end angle [0..360]  (if `LV_USE_FLOAT` is enabled it can be fractional too.)</returns>
        public static int LvArcGetAngleEnd(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvArcGetAngleEnd(__arg0);
            return ___ret;
        }

        /// <summary>Get the start angle of an arc background.</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <returns>the  start angle [0..360]  (if `LV_USE_FLOAT` is enabled it can be fractional too.)</returns>
        public static int LvArcGetBgAngleStart(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvArcGetBgAngleStart(__arg0);
            return ___ret;
        }

        /// <summary>Get the end angle of an arc background.</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <returns>the end angle [0..360]  (if `LV_USE_FLOAT` is enabled it can be fractional too.)</returns>
        public static int LvArcGetBgAngleEnd(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvArcGetBgAngleEnd(__arg0);
            return ___ret;
        }

        /// <summary>Get the value of an arc</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <returns>the value of the arc</returns>
        public static int LvArcGetValue(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvArcGetValue(__arg0);
            return ___ret;
        }

        /// <summary>Get the minimum value of an arc</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <returns>the minimum value of the arc</returns>
        public static int LvArcGetMinValue(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvArcGetMinValue(__arg0);
            return ___ret;
        }

        /// <summary>Get the maximum value of an arc</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <returns>the maximum value of the arc</returns>
        public static int LvArcGetMaxValue(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvArcGetMaxValue(__arg0);
            return ___ret;
        }

        /// <summary>Get whether the arc is type or not.</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <returns>arc's mode</returns>
        public static byte LvArcGetMode(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvArcGetMode(__arg0);
            return ___ret;
        }

        /// <summary>Get the rotation for the whole arc</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <returns>arc's current rotation</returns>
        public static int LvArcGetRotation(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvArcGetRotation(__arg0);
            return ___ret;
        }

        /// <summary>Get the current knob angle offset</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <returns>arc's current knob offset</returns>
        public static int LvArcGetKnobOffset(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvArcGetKnobOffset(__arg0);
            return ___ret;
        }

        /// <summary>Align an object to the current position of the arc (knob)</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <param name="obj_to_align">pointer to an object to align</param>
        /// <param name="r_offset">consider the radius larger with this value (&lt;0: for smaller radius)</param>
        public static void LvArcAlignObjToAngle(global::lvgl.LvObjT obj, global::lvgl.LvObjT obj_to_align, int r_offset)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = obj_to_align is null ? __IntPtr.Zero : obj_to_align.__Instance;
            __Internal.LvArcAlignObjToAngle(__arg0, __arg1, r_offset);
        }

        /// <summary>Rotate an object to the current position of the arc (knob)</summary>
        /// <param name="obj">pointer to an arc object</param>
        /// <param name="obj_to_rotate">pointer to an object to rotate</param>
        /// <param name="r_offset">consider the radius larger with this value (&lt;0: for smaller radius)</param>
        public static void LvArcRotateObjToAngle(global::lvgl.LvObjT obj, global::lvgl.LvObjT obj_to_rotate, int r_offset)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = obj_to_rotate is null ? __IntPtr.Zero : obj_to_rotate.__Instance;
            __Internal.LvArcRotateObjToAngle(__arg0, __arg1, r_offset);
        }

        public static global::lvgl.LvObjClassT LvArcClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_arc_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public enum LvBarModeT
    {
        LV_BAR_MODE_NORMAL = 0,
        LV_BAR_MODE_SYMMETRICAL = 1,
        LV_BAR_MODE_RANGE = 2
    }

    public unsafe partial class LvBarAnimT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr bar;
            internal int anim_start;
            internal int anim_end;
            internal int anim_state;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_bar_anim_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvBarAnimT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvBarAnimT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvBarAnimT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvBarAnimT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvBarAnimT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvBarAnimT(native.ToPointer(), skipVTables);
        }

        internal static LvBarAnimT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvBarAnimT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvBarAnimT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvBarAnimT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvBarAnimT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvBarAnimT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvBarAnimT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvBarAnimT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvBarAnimT(global::lvgl.LvBarAnimT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvBarAnimT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvBarAnimT.__Internal*) __Instance) = *((global::lvgl.LvBarAnimT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Bar
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->bar, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->bar = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public int AnimStart
        {
            get
            {
                return ((__Internal*)__Instance)->anim_start;
            }

            set
            {
                ((__Internal*)__Instance)->anim_start = value;
            }
        }

        public int AnimEnd
        {
            get
            {
                return ((__Internal*)__Instance)->anim_end;
            }

            set
            {
                ((__Internal*)__Instance)->anim_end = value;
            }
        }

        public int AnimState
        {
            get
            {
                return ((__Internal*)__Instance)->anim_state;
            }

            set
            {
                ((__Internal*)__Instance)->anim_state = value;
            }
        }
    }

    public unsafe partial class LvBarT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 160)]
        public partial struct __Internal
        {
            internal global::lvgl.LvObjT.__Internal obj;
            internal int cur_value;
            internal int min_value;
            internal int max_value;
            internal int start_value;
            internal global::lvgl.LvAreaT.__Internal indic_area;
            internal byte val_reversed;
            internal global::lvgl.LvBarAnimT.__Internal cur_value_anim;
            internal global::lvgl.LvBarAnimT.__Internal start_value_anim;
            internal byte mode;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_bar_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvBarT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvBarT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvBarT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvBarT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvBarT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvBarT(native.ToPointer(), skipVTables);
        }

        internal static LvBarT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvBarT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvBarT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvBarT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvBarT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvBarT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvBarT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvBarT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvBarT(global::lvgl.LvBarT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvBarT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvBarT.__Internal*) __Instance) = *((global::lvgl.LvBarT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Current value of the bar</summary>
        public int CurValue
        {
            get
            {
                return ((__Internal*)__Instance)->cur_value;
            }

            set
            {
                ((__Internal*)__Instance)->cur_value = value;
            }
        }

        /// <summary>Minimum value of the bar</summary>
        public int MinValue
        {
            get
            {
                return ((__Internal*)__Instance)->min_value;
            }

            set
            {
                ((__Internal*)__Instance)->min_value = value;
            }
        }

        /// <summary>Maximum value of the bar</summary>
        public int MaxValue
        {
            get
            {
                return ((__Internal*)__Instance)->max_value;
            }

            set
            {
                ((__Internal*)__Instance)->max_value = value;
            }
        }

        /// <summary>Start value of the bar</summary>
        public int StartValue
        {
            get
            {
                return ((__Internal*)__Instance)->start_value;
            }

            set
            {
                ((__Internal*)__Instance)->start_value = value;
            }
        }

        /// <summary>Save the indicator area. Might be used by derived types</summary>
        public global::lvgl.LvAreaT IndicArea
        {
            get
            {
                return global::lvgl.LvAreaT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->indic_area));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->indic_area = *(global::lvgl.LvAreaT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Whether value been reversed</summary>
        public bool ValReversed
        {
            get
            {
                return ((__Internal*)__Instance)->val_reversed != 0;
            }

            set
            {
                ((__Internal*)__Instance)->val_reversed = (byte) (value ? 1 : 0);
            }
        }

        public global::lvgl.LvBarAnimT CurValueAnim
        {
            get
            {
                return global::lvgl.LvBarAnimT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->cur_value_anim));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->cur_value_anim = *(global::lvgl.LvBarAnimT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvBarAnimT StartValueAnim
        {
            get
            {
                return global::lvgl.LvBarAnimT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->start_value_anim));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->start_value_anim = *(global::lvgl.LvBarAnimT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Type of bar</summary>
        public byte Mode
        {
            get
            {
                return ((__Internal*)__Instance)->mode;
            }

            set
            {
                ((__Internal*)__Instance)->mode = value;
            }
        }
    }

    public unsafe partial class lv_bar
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_bar_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvBarCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_bar_set_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvBarSetValue(__IntPtr obj, int value, global::lvgl.LvAnimEnableT anim);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_bar_set_start_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvBarSetStartValue(__IntPtr obj, int start_value, global::lvgl.LvAnimEnableT anim);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_bar_set_range", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvBarSetRange(__IntPtr obj, int min, int max);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_bar_set_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvBarSetMode(__IntPtr obj, byte mode);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_bar_get_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvBarGetValue(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_bar_get_start_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvBarGetStartValue(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_bar_get_min_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvBarGetMinValue(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_bar_get_max_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvBarGetMaxValue(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_bar_get_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvBarGetMode(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_bar_is_symmetrical", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvBarIsSymmetrical(__IntPtr obj);
        }

        /// <summary>Create a bar object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new bar</param>
        /// <returns>pointer to the created bar</returns>
        public static global::lvgl.LvObjT LvBarCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvBarCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set a new value on the bar</summary>
        /// <param name="obj">pointer to a bar object</param>
        /// <param name="value">new value</param>
        /// <param name="anim">LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately</param>
        public static void LvBarSetValue(global::lvgl.LvObjT obj, int value, global::lvgl.LvAnimEnableT anim)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvBarSetValue(__arg0, value, anim);
        }

        /// <summary>Set a new start value on the bar</summary>
        /// <param name="obj">pointer to a bar object</param>
        /// <param name="start_value">new start value</param>
        /// <param name="anim">LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately</param>
        public static void LvBarSetStartValue(global::lvgl.LvObjT obj, int start_value, global::lvgl.LvAnimEnableT anim)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvBarSetStartValue(__arg0, start_value, anim);
        }

        /// <summary>Set minimum and the maximum values of a bar</summary>
        /// <param name="obj">pointer to the bar object</param>
        /// <param name="min">minimum value</param>
        /// <param name="max">maximum value</param>
        /// <remarks>If min is greater than max, the drawing direction becomes to the oppsite direction.</remarks>
        public static void LvBarSetRange(global::lvgl.LvObjT obj, int min, int max)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvBarSetRange(__arg0, min, max);
        }

        /// <summary>Set the type of bar.</summary>
        /// <param name="obj">pointer to bar object</param>
        /// <param name="mode">bar type from ::lv_bar_mode_t</param>
        public static void LvBarSetMode(global::lvgl.LvObjT obj, byte mode)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvBarSetMode(__arg0, mode);
        }

        /// <summary>Get the value of a bar</summary>
        /// <param name="obj">pointer to a bar object</param>
        /// <returns>the value of the bar</returns>
        public static int LvBarGetValue(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvBarGetValue(__arg0);
            return ___ret;
        }

        /// <summary>Get the start value of a bar</summary>
        /// <param name="obj">pointer to a bar object</param>
        /// <returns>the start value of the bar</returns>
        public static int LvBarGetStartValue(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvBarGetStartValue(__arg0);
            return ___ret;
        }

        /// <summary>Get the minimum value of a bar</summary>
        /// <param name="obj">pointer to a bar object</param>
        /// <returns>the minimum value of the bar</returns>
        public static int LvBarGetMinValue(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvBarGetMinValue(__arg0);
            return ___ret;
        }

        /// <summary>Get the maximum value of a bar</summary>
        /// <param name="obj">pointer to a bar object</param>
        /// <returns>the maximum value of the bar</returns>
        public static int LvBarGetMaxValue(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvBarGetMaxValue(__arg0);
            return ___ret;
        }

        /// <summary>Get the type of bar.</summary>
        /// <param name="obj">pointer to bar object</param>
        /// <returns>bar type from ::lv_bar_mode_t</returns>
        public static byte LvBarGetMode(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvBarGetMode(__arg0);
            return ___ret;
        }

        /// <summary>Give the bar is in symmetrical mode or not</summary>
        /// <param name="obj">pointer to bar object</param>
        /// <returns>true: in symmetrical mode false : not in</returns>
        public static bool LvBarIsSymmetrical(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvBarIsSymmetrical(__arg0);
            return ___ret;
        }

        public static global::lvgl.LvObjClassT LvBarClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_bar_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>Long mode behaviors. Used in 'lv_label_ext_t'</summary>
    public enum LvLabelLongModeT
    {
        /// <summary>Keep the object width, wrap lines longer than object width and expand the object height</summary>
        LV_LABEL_LONG_WRAP = 0,
        /// <summary>Keep the size and write dots at the end if the text is too long</summary>
        LV_LABEL_LONG_DOT = 1,
        /// <summary>Keep the size and roll the text back and forth</summary>
        LV_LABEL_LONG_SCROLL = 2,
        /// <summary>Keep the size and roll the text circularly</summary>
        LV_LABEL_LONG_SCROLL_CIRCULAR = 3,
        /// <summary>Keep the size and clip the text out of it</summary>
        LV_LABEL_LONG_CLIP = 4
    }

    public unsafe partial class lv_label
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_label_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvLabelCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_label_set_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLabelSetText(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_label_set_text_fmt", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLabelSetTextFmt(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_label_set_long_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLabelSetLongMode(__IntPtr obj, byte long_mode);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_label_set_text_selection_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLabelSetTextSelectionStart(__IntPtr obj, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_label_set_text_selection_end", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLabelSetTextSelectionEnd(__IntPtr obj, uint index);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_label_get_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* LvLabelGetText(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_label_get_long_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvLabelGetLongMode(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_label_get_letter_pos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLabelGetLetterPos(__IntPtr obj, uint char_id, __IntPtr pos);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_label_get_letter_on", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvLabelGetLetterOn(__IntPtr obj, __IntPtr pos_in, bool bidi);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_label_is_char_under_pos", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvLabelIsCharUnderPos(__IntPtr obj, __IntPtr pos);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_label_get_text_selection_start", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvLabelGetTextSelectionStart(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_label_get_text_selection_end", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvLabelGetTextSelectionEnd(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_label_ins_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLabelInsText(__IntPtr obj, uint pos, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string txt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_label_cut_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLabelCutText(__IntPtr obj, uint pos, uint cnt);
        }

        /// <summary>Create a label object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new label.</param>
        /// <returns>pointer to the created button</returns>
        public static global::lvgl.LvObjT LvLabelCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvLabelCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set a new text for a label. Memory will be allocated to store the text by the label.</summary>
        /// <param name="obj">pointer to a label object</param>
        /// <param name="text">'\0' terminated character string. NULL to refresh with the current text.</param>
        public static void LvLabelSetText(global::lvgl.LvObjT obj, string text)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvLabelSetText(__arg0, text);
        }

        /// <summary>Set a new formatted text for a label. Memory will be allocated to store the text by the label.</summary>
        /// <param name="obj">pointer to a label object</param>
        /// <param name="fmt">`printf`-like format</param>
        public static void LvLabelSetTextFmt(global::lvgl.LvObjT obj, string fmt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvLabelSetTextFmt(__arg0, fmt);
        }

        /// <summary>Set the behavior of the label with text longer than the object size</summary>
        /// <param name="obj">pointer to a label object</param>
        /// <param name="long_mode">
        /// <para>the new mode from 'lv_label_long_mode' enum.</para>
        /// <para>In LV_LONG_WRAP/DOT/SCROLL/SCROLL_CIRC the size of the label should be set AFTER this function</para>
        /// </param>
        public static void LvLabelSetLongMode(global::lvgl.LvObjT obj, byte long_mode)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvLabelSetLongMode(__arg0, long_mode);
        }

        /// <summary>Set where text selection should start</summary>
        /// <param name="obj">pointer to a label object</param>
        /// <param name="index">character index from where selection should start. `LV_LABEL_TEXT_SELECTION_OFF` for no selection</param>
        public static void LvLabelSetTextSelectionStart(global::lvgl.LvObjT obj, uint index)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvLabelSetTextSelectionStart(__arg0, index);
        }

        /// <summary>Set where text selection should end</summary>
        /// <param name="obj">pointer to a label object</param>
        /// <param name="index">character index where selection should end. `LV_LABEL_TEXT_SELECTION_OFF` for no selection</param>
        public static void LvLabelSetTextSelectionEnd(global::lvgl.LvObjT obj, uint index)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvLabelSetTextSelectionEnd(__arg0, index);
        }

        /// <summary>Get the text of a label</summary>
        /// <param name="obj">pointer to a label object</param>
        /// <returns>the text of the label</returns>
        public static sbyte* LvLabelGetText(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvLabelGetText(__arg0);
            return ___ret;
        }

        /// <summary>Get the long mode of a label</summary>
        /// <param name="obj">pointer to a label object</param>
        /// <returns>the current long mode</returns>
        public static byte LvLabelGetLongMode(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvLabelGetLongMode(__arg0);
            return ___ret;
        }

        /// <summary>Get the relative x and y coordinates of a letter</summary>
        /// <param name="obj">pointer to a label object</param>
        /// <param name="char_id">
        /// <para>index of the character [0 ... text length - 1].</para>
        /// <para>Expressed in character index, not byte index (different in UTF-8)</para>
        /// </param>
        /// <param name="pos">store the result here (E.g. index = 0 gives 0;0 coordinates if the text if aligned to the left)</param>
        public static void LvLabelGetLetterPos(global::lvgl.LvObjT obj, uint char_id, global::lvgl.LvPointT pos)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg2 = pos is null ? __IntPtr.Zero : pos.__Instance;
            __Internal.LvLabelGetLetterPos(__arg0, char_id, __arg2);
        }

        /// <summary>Get the index of letter on a relative point of a label.</summary>
        /// <param name="obj">pointer to label object</param>
        /// <param name="pos_in">pointer to point with coordinates on a the label</param>
        /// <param name="bidi">whether to use bidi processed</param>
        /// <returns>
        /// <para>The index of the letter on the 'pos_p' point (E.g. on 0;0 is the 0. letter if aligned to the left)</para>
        /// <para>Expressed in character index and not byte index (different in UTF-8)</para>
        /// </returns>
        public static uint LvLabelGetLetterOn(global::lvgl.LvObjT obj, global::lvgl.LvPointT pos_in, bool bidi)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = pos_in is null ? __IntPtr.Zero : pos_in.__Instance;
            var ___ret = __Internal.LvLabelGetLetterOn(__arg0, __arg1, bidi);
            return ___ret;
        }

        /// <summary>Check if a character is drawn under a point.</summary>
        /// <param name="obj">pointer to a label object</param>
        /// <param name="pos">Point to check for character under</param>
        /// <returns>whether a character is drawn under the point</returns>
        public static bool LvLabelIsCharUnderPos(global::lvgl.LvObjT obj, global::lvgl.LvPointT pos)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = pos is null ? __IntPtr.Zero : pos.__Instance;
            var ___ret = __Internal.LvLabelIsCharUnderPos(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Get the selection start index.</summary>
        /// <param name="obj">pointer to a label object.</param>
        /// <returns>selection start index. `LV_LABEL_TEXT_SELECTION_OFF` if nothing is selected.</returns>
        public static uint LvLabelGetTextSelectionStart(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvLabelGetTextSelectionStart(__arg0);
            return ___ret;
        }

        /// <summary>Get the selection end index.</summary>
        /// <param name="obj">pointer to a label object.</param>
        /// <returns>selection end index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected.</returns>
        public static uint LvLabelGetTextSelectionEnd(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvLabelGetTextSelectionEnd(__arg0);
            return ___ret;
        }

        /// <summary>Insert a text to a label. The label text can not be static.</summary>
        /// <param name="obj">pointer to a label object</param>
        /// <param name="pos">
        /// <para>character index to insert. Expressed in character index and not byte index.</para>
        /// <para>0: before first char. LV_LABEL_POS_LAST: after last char.</para>
        /// </param>
        /// <param name="txt">pointer to the text to insert</param>
        public static void LvLabelInsText(global::lvgl.LvObjT obj, uint pos, string txt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvLabelInsText(__arg0, pos, txt);
        }

        /// <summary>Delete characters from a label. The label text can not be static.</summary>
        /// <param name="obj">pointer to a label object</param>
        /// <param name="pos">
        /// <para>character index from where to cut. Expressed in character index and not byte index.</para>
        /// <para>0: start in from of the first character</para>
        /// </param>
        /// <param name="cnt">number of characters to cut</param>
        public static void LvLabelCutText(global::lvgl.LvObjT obj, uint pos, uint cnt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvLabelCutText(__arg0, pos, cnt);
        }

        public static global::lvgl.LvObjClassT LvLabelClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_label_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvButtonT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal global::lvgl.LvObjT.__Internal obj;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_button_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvButtonT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvButtonT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvButtonT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvButtonT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvButtonT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvButtonT(native.ToPointer(), skipVTables);
        }

        internal static LvButtonT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvButtonT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvButtonT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvButtonT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvButtonT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvButtonT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvButtonT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvButtonT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvButtonT(global::lvgl.LvButtonT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvButtonT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvButtonT.__Internal*) __Instance) = *((global::lvgl.LvButtonT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class lv_button
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_button_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvButtonCreate(__IntPtr parent);
        }

        /// <summary>Create a button object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new button</param>
        /// <returns>pointer to the created button</returns>
        public static global::lvgl.LvObjT LvButtonCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvButtonCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::lvgl.LvObjClassT LvButtonClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_button_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>Type to store button control bits (disabled, hidden etc.)</para>
    /// <para>The first 3 bits are used to store the width</para>
    /// </summary>
    public enum LvButtonmatrixCtrlT
    {
        /// <summary>Reserved to store the size units</summary>
        LV_BUTTONMATRIX_WIDTH = 15,
        /// <summary>Button hidden</summary>
        LV_BUTTONMATRIX_CTRL_HIDDEN = 16,
        /// <summary>Do not repeat press this button.</summary>
        LV_BUTTONMATRIX_CTRL_NO_REPEAT = 32,
        /// <summary>Disable this button.</summary>
        LV_BUTTONMATRIX_CTRL_DISABLED = 64,
        /// <summary>The button can be toggled.</summary>
        LV_BUTTONMATRIX_CTRL_CHECKABLE = 128,
        /// <summary>Button is currently toggled (e.g. checked).</summary>
        LV_BUTTONMATRIX_CTRL_CHECKED = 256,
        /// <summary>1: Send LV_EVENT_VALUE_CHANGE on CLICK, 0: Send LV_EVENT_VALUE_CHANGE on PRESS</summary>
        LV_BUTTONMATRIX_CTRL_CLICK_TRIG = 512,
        /// <summary>Show a popover when pressing this key</summary>
        LV_BUTTONMATRIX_CTRL_POPOVER = 1024,
        /// <summary>Reserved for later use</summary>
        LV_BUTTONMATRIX_CTRL_RESERVED_1 = 2048,
        /// <summary>Reserved for later use</summary>
        LV_BUTTONMATRIX_CTRL_RESERVED_2 = 4096,
        /// <summary>Reserved for later use</summary>
        LV_BUTTONMATRIX_CTRL_RESERVED_3 = 8192,
        /// <summary>Custom free to use flag</summary>
        LV_BUTTONMATRIX_CTRL_CUSTOM_1 = 16384,
        /// <summary>Custom free to use flag</summary>
        LV_BUTTONMATRIX_CTRL_CUSTOM_2 = 32768
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool LvButtonmatrixButtonDrawCbT(__IntPtr btnm, uint btn_id, __IntPtr draw_area, __IntPtr clip_area);

    public unsafe partial class LvButtonmatrixT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 104)]
        public partial struct __Internal
        {
            internal global::lvgl.LvObjT.__Internal obj;
            internal __IntPtr map_p;
            internal __IntPtr button_areas;
            internal __IntPtr ctrl_bits;
            internal uint btn_cnt;
            internal uint row_cnt;
            internal uint btn_id_sel;
            internal uint one_check;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_buttonmatrix_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvButtonmatrixT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvButtonmatrixT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvButtonmatrixT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvButtonmatrixT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvButtonmatrixT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvButtonmatrixT(native.ToPointer(), skipVTables);
        }

        internal static LvButtonmatrixT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvButtonmatrixT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvButtonmatrixT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvButtonmatrixT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvButtonmatrixT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvButtonmatrixT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvButtonmatrixT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvButtonmatrixT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvButtonmatrixT(global::lvgl.LvButtonmatrixT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvButtonmatrixT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvButtonmatrixT.__Internal*) __Instance) = *((global::lvgl.LvButtonmatrixT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvAreaT ButtonAreas
        {
            get
            {
                var __result0 = global::lvgl.LvAreaT.__GetOrCreateInstance(((__Internal*)__Instance)->button_areas, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->button_areas = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint* CtrlBits
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->ctrl_bits;
            }

            set
            {
                ((__Internal*)__Instance)->ctrl_bits = (__IntPtr) value;
            }
        }

        public uint BtnCnt
        {
            get
            {
                return ((__Internal*)__Instance)->btn_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->btn_cnt = value;
            }
        }

        public uint RowCnt
        {
            get
            {
                return ((__Internal*)__Instance)->row_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->row_cnt = value;
            }
        }

        public uint BtnIdSel
        {
            get
            {
                return ((__Internal*)__Instance)->btn_id_sel;
            }

            set
            {
                ((__Internal*)__Instance)->btn_id_sel = value;
            }
        }

        public uint OneCheck
        {
            get
            {
                return ((__Internal*)__Instance)->one_check;
            }

            set
            {
                ((__Internal*)__Instance)->one_check = value;
            }
        }
    }

    public unsafe partial class lv_buttonmatrix
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_buttonmatrix_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvButtonmatrixCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_buttonmatrix_set_map", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvButtonmatrixSetMap(__IntPtr obj, [MarshalAs(UnmanagedType.LPArray)] string[] map);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_buttonmatrix_set_ctrl_map", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvButtonmatrixSetCtrlMap(__IntPtr obj, uint[] ctrl_map);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_buttonmatrix_set_selected_button", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvButtonmatrixSetSelectedButton(__IntPtr obj, uint btn_id);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_buttonmatrix_set_button_ctrl", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvButtonmatrixSetButtonCtrl(__IntPtr obj, uint btn_id, uint ctrl);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_buttonmatrix_clear_button_ctrl", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvButtonmatrixClearButtonCtrl(__IntPtr obj, uint btn_id, uint ctrl);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_buttonmatrix_set_button_ctrl_all", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvButtonmatrixSetButtonCtrlAll(__IntPtr obj, uint ctrl);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_buttonmatrix_clear_button_ctrl_all", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvButtonmatrixClearButtonCtrlAll(__IntPtr obj, uint ctrl);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_buttonmatrix_set_button_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvButtonmatrixSetButtonWidth(__IntPtr obj, uint btn_id, uint width);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_buttonmatrix_set_one_checked", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvButtonmatrixSetOneChecked(__IntPtr obj, bool en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_buttonmatrix_get_map", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte** LvButtonmatrixGetMap(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_buttonmatrix_get_selected_button", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvButtonmatrixGetSelectedButton(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_buttonmatrix_get_button_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvButtonmatrixGetButtonText(__IntPtr obj, uint btn_id);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_buttonmatrix_has_button_ctrl", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvButtonmatrixHasButtonCtrl(__IntPtr obj, uint btn_id, uint ctrl);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_buttonmatrix_get_one_checked", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvButtonmatrixGetOneChecked(__IntPtr obj);
        }

        /// <summary>Create a button matrix object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new button matrix</param>
        /// <returns>pointer to the created button matrix</returns>
        public static global::lvgl.LvObjT LvButtonmatrixCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvButtonmatrixCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Set a new map. Buttons will be created/deleted according to the map. The</para>
        /// <para>button matrix keeps a reference to the map and so the string array must not</para>
        /// <para>be deallocated during the life of the matrix.</para>
        /// </summary>
        /// <param name="obj">pointer to a button matrix object</param>
        /// <param name="map">pointer a string array. The last string has to be: &quot;&quot;. Use &quot;\n&quot; to make a line break.</param>
        public static void LvButtonmatrixSetMap(global::lvgl.LvObjT obj, string[] map)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvButtonmatrixSetMap(__arg0, map);
        }

        /// <summary>
        /// <para>Set the button control map (hidden, disabled etc.) for a button matrix.</para>
        /// <para>The control map array will be copied and so may be deallocated after this</para>
        /// <para>function returns.</para>
        /// </summary>
        /// <param name="obj">pointer to a button matrix object</param>
        /// <param name="ctrl_map">
        /// <para>pointer to an array of `lv_button_ctrl_t` control bytes. The</para>
        /// <para>length of the array and position of the elements must match</para>
        /// <para>the number and order of the individual buttons (i.e. excludes</para>
        /// <para>newline entries).</para>
        /// <para>An element of the map should look like e.g.:</para>
        /// <para>`ctrl_map[0] = width | LV_BUTTONMATRIX_CTRL_NO_REPEAT |  LV_BUTTONMATRIX_CTRL_TGL_ENABLE`</para>
        /// </param>
        public static void LvButtonmatrixSetCtrlMap(global::lvgl.LvObjT obj, uint[] ctrl_map)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvButtonmatrixSetCtrlMap(__arg0, ctrl_map);
        }

        /// <summary>Set the selected buttons</summary>
        /// <param name="obj">pointer to button matrix object</param>
        /// <param name="btn_id">0 based index of the button to modify. (Not counting new lines)</param>
        public static void LvButtonmatrixSetSelectedButton(global::lvgl.LvObjT obj, uint btn_id)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvButtonmatrixSetSelectedButton(__arg0, btn_id);
        }

        /// <summary>Set the attributes of a button of the button matrix</summary>
        /// <param name="obj">pointer to button matrix object</param>
        /// <param name="btn_id">0 based index of the button to modify. (Not counting new lines)</param>
        /// <param name="ctrl">OR-ed attributes. E.g. `LV_BUTTONMATRIX_CTRL_NO_REPEAT | LV_BUTTONMATRIX_CTRL_CHECKABLE`</param>
        public static void LvButtonmatrixSetButtonCtrl(global::lvgl.LvObjT obj, uint btn_id, uint ctrl)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvButtonmatrixSetButtonCtrl(__arg0, btn_id, ctrl);
        }

        /// <summary>Clear the attributes of a button of the button matrix</summary>
        /// <param name="obj">pointer to button matrix object</param>
        /// <param name="btn_id">0 based index of the button to modify. (Not counting new lines)</param>
        /// <param name="ctrl">OR-ed attributes. E.g. `LV_BUTTONMATRIX_CTRL_NO_REPEAT | LV_BUTTONMATRIX_CTRL_CHECKABLE`</param>
        public static void LvButtonmatrixClearButtonCtrl(global::lvgl.LvObjT obj, uint btn_id, uint ctrl)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvButtonmatrixClearButtonCtrl(__arg0, btn_id, ctrl);
        }

        /// <summary>Set attributes of all buttons of a button matrix</summary>
        /// <param name="obj">pointer to a button matrix object</param>
        /// <param name="ctrl">attribute(s) to set from `lv_buttonmatrix_ctrl_t`. Values can be ORed.</param>
        public static void LvButtonmatrixSetButtonCtrlAll(global::lvgl.LvObjT obj, uint ctrl)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvButtonmatrixSetButtonCtrlAll(__arg0, ctrl);
        }

        /// <summary>Clear the attributes of all buttons of a button matrix</summary>
        /// <param name="obj">pointer to a button matrix object</param>
        /// <param name="ctrl">attribute(s) to set from `lv_buttonmatrix_ctrl_t`. Values can be ORed.</param>
        /// <param name="en">true: set the attributes; false: clear the attributes</param>
        public static void LvButtonmatrixClearButtonCtrlAll(global::lvgl.LvObjT obj, uint ctrl)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvButtonmatrixClearButtonCtrlAll(__arg0, ctrl);
        }

        /// <summary>
        /// <para>Set a single button's relative width.</para>
        /// <para>This method will cause the matrix be regenerated and is a relatively</para>
        /// <para>expensive operation. It is recommended that initial width be specified using</para>
        /// <para>`lv_buttonmatrix_set_ctrl_map` and this method only be used for dynamic changes.</para>
        /// </summary>
        /// <param name="obj">pointer to button matrix object</param>
        /// <param name="btn_id">0 based index of the button to modify.</param>
        /// <param name="width">relative width compared to the buttons in the same row. [1..15]</param>
        public static void LvButtonmatrixSetButtonWidth(global::lvgl.LvObjT obj, uint btn_id, uint width)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvButtonmatrixSetButtonWidth(__arg0, btn_id, width);
        }

        /// <summary>
        /// <para>Make the button matrix like a selector widget (only one button may be checked at a time).</para>
        /// <para>`LV_BUTTONMATRIX_CTRL_CHECKABLE` must be enabled on the buttons to be selected using</para>
        /// <para>`lv_buttonmatrix_set_ctrl()` or `lv_buttonmatrix_set_button_ctrl_all()`.</para>
        /// </summary>
        /// <param name="obj">pointer to a button matrix object</param>
        /// <param name="en">whether &quot;one check&quot; mode is enabled</param>
        public static void LvButtonmatrixSetOneChecked(global::lvgl.LvObjT obj, bool en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvButtonmatrixSetOneChecked(__arg0, en);
        }

        /// <summary>Get the current map of a button matrix</summary>
        /// <param name="obj">pointer to a button matrix object</param>
        /// <returns>the current map</returns>
        public static sbyte** LvButtonmatrixGetMap(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvButtonmatrixGetMap(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Get the index of the lastly &quot;activated&quot; button by the user (pressed, released, focused etc)</para>
        /// <para>Useful in the `event_cb` to get the text of the button, check if hidden etc.</para>
        /// </summary>
        /// <param name="obj">pointer to button matrix object</param>
        /// <returns>index of the last released button (LV_BUTTONMATRIX_BUTTON_NONE: if unset)</returns>
        public static uint LvButtonmatrixGetSelectedButton(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvButtonmatrixGetSelectedButton(__arg0);
            return ___ret;
        }

        /// <summary>Get the button's text</summary>
        /// <param name="obj">pointer to button matrix object</param>
        /// <param name="btn_id">the index a button not counting new line characters.</param>
        /// <returns>text of btn_index` button</returns>
        public static string LvButtonmatrixGetButtonText(global::lvgl.LvObjT obj, uint btn_id)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvButtonmatrixGetButtonText(__arg0, btn_id);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the whether a control value is enabled or disabled for button of a button matrix</summary>
        /// <param name="obj">pointer to a button matrix object</param>
        /// <param name="btn_id">the index of a button not counting new line characters.</param>
        /// <param name="ctrl">control values to check (ORed value can be used)</param>
        /// <returns>true: the control attribute is enabled false: disabled</returns>
        public static bool LvButtonmatrixHasButtonCtrl(global::lvgl.LvObjT obj, uint btn_id, uint ctrl)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvButtonmatrixHasButtonCtrl(__arg0, btn_id, ctrl);
            return ___ret;
        }

        /// <summary>Tell whether &quot;one check&quot; mode is enabled or not.</summary>
        /// <param name="obj">Button matrix object</param>
        /// <returns>true: &quot;one check&quot; mode is enabled; false: disabled</returns>
        public static bool LvButtonmatrixGetOneChecked(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvButtonmatrixGetOneChecked(__arg0);
            return ___ret;
        }

        public static global::lvgl.LvObjClassT LvButtonmatrixClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_buttonmatrix_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>Represents a date on the calendar object (platform-agnostic).</summary>
    /// <summary>Represents a date on the calendar object (platform-agnostic).</summary>
    public unsafe partial class LvCalendarDateT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal ushort year;
            internal sbyte month;
            internal sbyte day;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_calendar_date_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvCalendarDateT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvCalendarDateT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvCalendarDateT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvCalendarDateT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvCalendarDateT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvCalendarDateT(native.ToPointer(), skipVTables);
        }

        internal static LvCalendarDateT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvCalendarDateT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvCalendarDateT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvCalendarDateT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvCalendarDateT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvCalendarDateT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvCalendarDateT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvCalendarDateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvCalendarDateT(global::lvgl.LvCalendarDateT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvCalendarDateT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvCalendarDateT.__Internal*) __Instance) = *((global::lvgl.LvCalendarDateT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Year
        {
            get
            {
                return ((__Internal*)__Instance)->year;
            }

            set
            {
                ((__Internal*)__Instance)->year = value;
            }
        }

        public sbyte Month
        {
            get
            {
                return ((__Internal*)__Instance)->month;
            }

            set
            {
                ((__Internal*)__Instance)->month = value;
            }
        }

        /// <summary>1..12</summary>
        public sbyte Day
        {
            get
            {
                return ((__Internal*)__Instance)->day;
            }

            set
            {
                ((__Internal*)__Instance)->day = value;
            }
        }
    }

    public unsafe partial class LvCalendarT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1392)]
        public partial struct __Internal
        {
            internal global::lvgl.LvObjT.__Internal obj;
            internal __IntPtr btnm;
            internal global::lvgl.LvCalendarDateT.__Internal today;
            internal global::lvgl.LvCalendarDateT.__Internal showed_date;
            internal __IntPtr highlighted_dates;
            internal ulong highlighted_dates_num;
            internal __IntPtr map;
            internal byte use_chinese_calendar;
            internal fixed sbyte nums[840];

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_calendar_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvCalendarT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvCalendarT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvCalendarT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvCalendarT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvCalendarT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvCalendarT(native.ToPointer(), skipVTables);
        }

        internal static LvCalendarT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvCalendarT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvCalendarT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvCalendarT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvCalendarT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvCalendarT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvCalendarT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvCalendarT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvCalendarT(global::lvgl.LvCalendarT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvCalendarT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvCalendarT.__Internal*) __Instance) = *((global::lvgl.LvCalendarT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvObjT Btnm
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->btnm, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->btnm = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Date of today</summary>
        public global::lvgl.LvCalendarDateT Today
        {
            get
            {
                return global::lvgl.LvCalendarDateT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->today));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->today = *(global::lvgl.LvCalendarDateT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Currently visible month (day is ignored)</summary>
        public global::lvgl.LvCalendarDateT ShowedDate
        {
            get
            {
                return global::lvgl.LvCalendarDateT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->showed_date));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->showed_date = *(global::lvgl.LvCalendarDateT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Apply different style on these days (pointer to user-defined array)</summary>
        public global::lvgl.LvCalendarDateT HighlightedDates
        {
            get
            {
                var __result0 = global::lvgl.LvCalendarDateT.__GetOrCreateInstance(((__Internal*)__Instance)->highlighted_dates, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->highlighted_dates = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Number of elements in `highlighted_days`</summary>
        public ulong HighlightedDatesNum
        {
            get
            {
                return ((__Internal*)__Instance)->highlighted_dates_num;
            }

            set
            {
                ((__Internal*)__Instance)->highlighted_dates_num = value;
            }
        }

        private string[] __map;

        private bool __mapInitialised;
        public string[] Map
        {
            get
            {
                if (!__mapInitialised)
                {
                    __map = null;
                    __mapInitialised = true;
                }
                return __map;
            }

            set
            {
                __map = value;
                if (!__mapInitialised)
                {
                    __mapInitialised = true;
                }
            }
        }

        public bool UseChineseCalendar
        {
            get
            {
                return ((__Internal*)__Instance)->use_chinese_calendar != 0;
            }

            set
            {
                ((__Internal*)__Instance)->use_chinese_calendar = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class lv_calendar
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_calendar_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCalendarCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_calendar_set_today_date", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCalendarSetTodayDate(__IntPtr obj, uint year, uint month, uint day);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_calendar_set_showed_date", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCalendarSetShowedDate(__IntPtr obj, uint year, uint month);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_calendar_set_highlighted_dates", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCalendarSetHighlightedDates(__IntPtr obj, global::lvgl.LvCalendarDateT.__Internal[] highlighted, ulong date_num);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_calendar_set_day_names", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCalendarSetDayNames(__IntPtr obj, sbyte** day_names);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_calendar_get_btnmatrix", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCalendarGetBtnmatrix(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_calendar_get_today_date", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCalendarGetTodayDate(__IntPtr calendar);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_calendar_get_showed_date", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCalendarGetShowedDate(__IntPtr calendar);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_calendar_get_highlighted_dates", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCalendarGetHighlightedDates(__IntPtr calendar);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_calendar_get_highlighted_dates_num", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong LvCalendarGetHighlightedDatesNum(__IntPtr calendar);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_calendar_get_pressed_date", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvCalendarGetPressedDate(__IntPtr calendar, __IntPtr date);
        }

        /// <summary>Create a calendar widget</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new calendar</param>
        /// <returns>pointer the created calendar</returns>
        public static global::lvgl.LvObjT LvCalendarCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvCalendarCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the today's date</summary>
        /// <param name="obj">pointer to a calendar object</param>
        /// <param name="year">today's year</param>
        /// <param name="month">today's month [1..12]</param>
        /// <param name="day">today's day [1..31]</param>
        public static void LvCalendarSetTodayDate(global::lvgl.LvObjT obj, uint year, uint month, uint day)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvCalendarSetTodayDate(__arg0, year, month, day);
        }

        /// <summary>Set the currently showed</summary>
        /// <param name="obj">pointer to a calendar object</param>
        /// <param name="year">today's year</param>
        /// <param name="month">today's month [1..12]</param>
        public static void LvCalendarSetShowedDate(global::lvgl.LvObjT obj, uint year, uint month)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvCalendarSetShowedDate(__arg0, year, month);
        }

        /// <summary>Set the highlighted dates</summary>
        /// <param name="obj">pointer to a calendar object</param>
        /// <param name="highlighted">
        /// <para>pointer to an `lv_calendar_date_t` array containing the dates.</para>
        /// <para>Only the pointer will be saved so this variable can't be local which will be destroyed later.</para>
        /// </param>
        /// <param name="date_num">number of dates in the array</param>
        public static void LvCalendarSetHighlightedDates(global::lvgl.LvObjT obj, global::lvgl.LvCalendarDateT[] highlighted, ulong date_num)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            global::lvgl.LvCalendarDateT.__Internal[] __highlighted;
            if (highlighted == null)
                __highlighted = null;
            else
            {
                __highlighted = new global::lvgl.LvCalendarDateT.__Internal[highlighted.Length];
                for (int i = 0; i < __highlighted.Length; i++)
                {
                    var __element = highlighted[i];
                    __highlighted[i] = __element is null ? new global::lvgl.LvCalendarDateT.__Internal() : *(global::lvgl.LvCalendarDateT.__Internal*) __element.__Instance;
                }
            }
            var __arg1 = __highlighted;
            __Internal.LvCalendarSetHighlightedDates(__arg0, __arg1, date_num);
        }

        /// <summary>Set the name of the days</summary>
        /// <param name="obj">pointer to a calendar object</param>
        /// <param name="day_names">
        /// <para>pointer to an array with the names.</para>
        /// <para>E.g. `const char * days[7] = {&quot;Sun&quot;, &quot;Mon&quot;, ...}`</para>
        /// <para>Only the pointer will be saved so this variable can't be local which will be destroyed later.</para>
        /// </param>
        public static void LvCalendarSetDayNames(global::lvgl.LvObjT obj, sbyte** day_names)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvCalendarSetDayNames(__arg0, day_names);
        }

        /// <summary>
        /// <para>Get the button matrix object of the calendar.</para>
        /// <para>It shows the dates and day names.</para>
        /// </summary>
        /// <param name="obj">pointer to a calendar object</param>
        /// <returns>pointer to a the button matrix</returns>
        public static global::lvgl.LvObjT LvCalendarGetBtnmatrix(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvCalendarGetBtnmatrix(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the today's date</summary>
        /// <param name="calendar">pointer to a calendar object</param>
        /// <returns>return pointer to an `lv_calendar_date_t` variable containing the date of today.</returns>
        public static global::lvgl.LvCalendarDateT LvCalendarGetTodayDate(global::lvgl.LvObjT calendar)
        {
            var __arg0 = calendar is null ? __IntPtr.Zero : calendar.__Instance;
            var ___ret = __Internal.LvCalendarGetTodayDate(__arg0);
            var __result0 = global::lvgl.LvCalendarDateT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the currently showed</summary>
        /// <param name="calendar">pointer to a calendar object</param>
        /// <returns>pointer to an `lv_calendar_date_t` variable containing the date is being shown.</returns>
        public static global::lvgl.LvCalendarDateT LvCalendarGetShowedDate(global::lvgl.LvObjT calendar)
        {
            var __arg0 = calendar is null ? __IntPtr.Zero : calendar.__Instance;
            var ___ret = __Internal.LvCalendarGetShowedDate(__arg0);
            var __result0 = global::lvgl.LvCalendarDateT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the highlighted dates</summary>
        /// <param name="calendar">pointer to a calendar object</param>
        /// <returns>pointer to an `lv_calendar_date_t` array containing the dates.</returns>
        public static global::lvgl.LvCalendarDateT LvCalendarGetHighlightedDates(global::lvgl.LvObjT calendar)
        {
            var __arg0 = calendar is null ? __IntPtr.Zero : calendar.__Instance;
            var ___ret = __Internal.LvCalendarGetHighlightedDates(__arg0);
            var __result0 = global::lvgl.LvCalendarDateT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the number of the highlighted dates</summary>
        /// <param name="calendar">pointer to a calendar object</param>
        /// <returns>number of highlighted days</returns>
        public static ulong LvCalendarGetHighlightedDatesNum(global::lvgl.LvObjT calendar)
        {
            var __arg0 = calendar is null ? __IntPtr.Zero : calendar.__Instance;
            var ___ret = __Internal.LvCalendarGetHighlightedDatesNum(__arg0);
            return ___ret;
        }

        /// <summary>Get the currently pressed day</summary>
        /// <param name="calendar">pointer to a calendar object</param>
        /// <param name="date">store the pressed date here</param>
        /// <returns>
        /// <para>LV_RESULT_OK: there is a valid pressed date</para>
        /// <para>LV_RESULT_INVALID: there is no pressed data</para>
        /// </returns>
        public static byte LvCalendarGetPressedDate(global::lvgl.LvObjT calendar, global::lvgl.LvCalendarDateT date)
        {
            var __arg0 = calendar is null ? __IntPtr.Zero : calendar.__Instance;
            var __arg1 = date is null ? __IntPtr.Zero : date.__Instance;
            var ___ret = __Internal.LvCalendarGetPressedDate(__arg0, __arg1);
            return ___ret;
        }

        public static global::lvgl.LvObjClassT LvCalendarClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_calendar_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    public unsafe partial class lv_calendar_header_arrow
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_calendar_header_arrow_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCalendarHeaderArrowCreate(__IntPtr parent);
        }

        /// <summary>Create a calendar header with drop-drowns to select the year and month</summary>
        /// <param name="parent">pointer to a calendar object.</param>
        /// <returns>the created header</returns>
        public static global::lvgl.LvObjT LvCalendarHeaderArrowCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvCalendarHeaderArrowCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>********************</para>
        /// <para>TYPEDEFS</para>
        /// <para>********************</para>
        /// </summary>
        public static global::lvgl.LvObjClassT LvCalendarHeaderArrowClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_calendar_header_arrow_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    public unsafe partial class lv_calendar_header_dropdown
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_calendar_header_dropdown_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCalendarHeaderDropdownCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_calendar_header_dropdown_set_year_list", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCalendarHeaderDropdownSetYearList(__IntPtr parent, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string years_list);
        }

        /// <summary>Create a calendar header with drop-drowns to select the year and month</summary>
        /// <param name="parent">pointer to a calendar object.</param>
        /// <returns>the created header</returns>
        public static global::lvgl.LvObjT LvCalendarHeaderDropdownCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvCalendarHeaderDropdownCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Sets a custom calendar year list</summary>
        /// <param name="parent">pointer to a calendar object</param>
        /// <param name="years_list">
        /// <para>pointer to an const char array with the years list, see lv_dropdown set_options for more information.</para>
        /// <para>E.g. `const char * years = &quot;2023\n2022\n2021\n2020\n2019&quot;</para>
        /// <para>Only the pointer will be saved so this variable can't be local which will be destroyed later.</para>
        /// </param>
        public static void LvCalendarHeaderDropdownSetYearList(global::lvgl.LvObjT parent, string years_list)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            __Internal.LvCalendarHeaderDropdownSetYearList(__arg0, years_list);
        }

        /// <summary>
        /// <para>********************</para>
        /// <para>TYPEDEFS</para>
        /// <para>********************</para>
        /// </summary>
        public static global::lvgl.LvObjClassT LvCalendarHeaderDropdownClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_calendar_header_dropdown_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    public unsafe partial class lv_canvas
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_canvas_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCanvasCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_canvas_set_buffer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCanvasSetBuffer(__IntPtr obj, __IntPtr buf, int w, int h, byte cf);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_canvas_set_draw_buf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCanvasSetDrawBuf(__IntPtr obj, __IntPtr draw_buf);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_canvas_set_px", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCanvasSetPx(__IntPtr obj, int x, int y, __IntPtr color, byte opa);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_canvas_set_palette", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCanvasSetPalette(__IntPtr obj, byte index, global::lvgl.LvColor32T.__Internal color);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_canvas_get_draw_buf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCanvasGetDrawBuf(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_canvas_get_px", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::lvgl.LvColor32T.__Internal LvCanvasGetPx(__IntPtr obj, int x, int y);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_canvas_get_image", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCanvasGetImage(__IntPtr canvas);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_canvas_get_buf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCanvasGetBuf(__IntPtr canvas);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_canvas_copy_buf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCanvasCopyBuf(__IntPtr obj, __IntPtr canvas_area, __IntPtr dest_buf, __IntPtr dest_area);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_canvas_fill_bg", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCanvasFillBg(__IntPtr obj, __IntPtr color, byte opa);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_canvas_init_layer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCanvasInitLayer(__IntPtr canvas, __IntPtr layer);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_canvas_finish_layer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCanvasFinishLayer(__IntPtr canvas, __IntPtr layer);
        }

        /// <summary>Create a canvas object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new canvas</param>
        /// <returns>pointer to the created canvas</returns>
        public static global::lvgl.LvObjT LvCanvasCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvCanvasCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Set a buffer for the canvas.</para>
        /// <para>Use `lv_canvas_set_draw_buf` instead if you need to set a buffer with alignment requirement.</para>
        /// </summary>
        /// <param name="buf">
        /// <para>a buffer where the content of the canvas will be.</para>
        /// <para>The required size is (lv_image_color_format_get_px_size(cf) * w) / 8 * h)</para>
        /// <para>It can be allocated with `lv_malloc()` or</para>
        /// <para>it can be statically allocated array (e.g. static lv_color_t buf[100*50]) or</para>
        /// <para>it can be an address in RAM or external SRAM</para>
        /// </param>
        /// <param name="canvas">pointer to a canvas object</param>
        /// <param name="w">width of the canvas</param>
        /// <param name="h">height of the canvas</param>
        /// <param name="cf">color format. `LV_COLOR_FORMAT...`</param>
        public static void LvCanvasSetBuffer(global::lvgl.LvObjT obj, __IntPtr buf, int w, int h, byte cf)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvCanvasSetBuffer(__arg0, buf, w, h, cf);
        }

        /// <summary>
        /// <para>Set a draw buffer for the canvas. A draw buffer either can be allocated by `lv_draw_buf_create()`</para>
        /// <para>or defined statically by `LV_DRAW_BUF_DEFINE_STATIC`. When buffer start address and stride has alignment</para>
        /// <para>requirement, it's recommended to use `lv_draw_buf_create`.</para>
        /// </summary>
        /// <param name="obj">pointer to a canvas object</param>
        /// <param name="draw_buf">pointer to a draw buffer</param>
        public static void LvCanvasSetDrawBuf(global::lvgl.LvObjT obj, global::lvgl.LvDrawBufT draw_buf)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = draw_buf is null ? __IntPtr.Zero : draw_buf.__Instance;
            __Internal.LvCanvasSetDrawBuf(__arg0, __arg1);
        }

        /// <summary>Set a pixel's color and opacity</summary>
        /// <param name="obj">pointer to a canvas</param>
        /// <param name="x">X coordinate of the pixel</param>
        /// <param name="y">Y coordinate of the pixel</param>
        /// <param name="color">the color</param>
        /// <param name="opa">the opacity</param>
        /// <remarks>
        /// <para>The following color formats are supported</para>
        /// <para>LV_COLOR_FORMAT_I1/2/4/8, LV_COLOR_FORMAT_A8,</para>
        /// <para>LV_COLOR_FORMAT_RGB565, LV_COLOR_FORMAT_RGB888,</para>
        /// <para>LV_COLOR_FORMAT_XRGB8888, LV_COLOR_FORMAT_ARGB8888</para>
        /// </remarks>
        public static void LvCanvasSetPx(global::lvgl.LvObjT obj, int x, int y, global::lvgl.LvColorT color, byte opa)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg3 = color.__Instance;
            __Internal.LvCanvasSetPx(__arg0, x, y, __arg3, opa);
        }

        /// <summary>Set the palette color of a canvas for index format. Valid only for `LV_COLOR_FORMAT_I1/2/4/8`</summary>
        /// <param name="obj">pointer to canvas object</param>
        /// <param name="index">
        /// <para>the palette color to set:</para>
        /// <para>- for `LV_COLOR_FORMAT_I1`: 0..1</para>
        /// <para>- for `LV_COLOR_FORMAT_I2`: 0..3</para>
        /// <para>- for `LV_COLOR_FORMAT_I4`: 0..15</para>
        /// <para>- for `LV_COLOR_FORMAT_I8`: 0..255</para>
        /// </param>
        /// <param name="color">the color to set</param>
        public static void LvCanvasSetPalette(global::lvgl.LvObjT obj, byte index, global::lvgl.LvColor32T color)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            __Internal.LvCanvasSetPalette(__arg0, index, *(global::lvgl.LvColor32T.__Internal*) __arg2);
        }

        public static global::lvgl.LvDrawBufT LvCanvasGetDrawBuf(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvCanvasGetDrawBuf(__arg0);
            var __result0 = global::lvgl.LvDrawBufT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get a pixel's color and opacity</summary>
        /// <param name="obj">pointer to a canvas</param>
        /// <param name="x">X coordinate of the pixel</param>
        /// <param name="y">Y coordinate of the pixel</param>
        /// <returns>ARGB8888 color of the pixel</returns>
        public static global::lvgl.LvColor32T LvCanvasGetPx(global::lvgl.LvObjT obj, int x, int y)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvCanvasGetPx(__arg0, x, y);
            return global::lvgl.LvColor32T.__CreateInstance(___ret);
        }

        /// <summary>Get the image of the canvas as a pointer to an `lv_image_dsc_t` variable.</summary>
        /// <param name="canvas">pointer to a canvas object</param>
        /// <returns>pointer to the image descriptor.</returns>
        public static global::lvgl.LvImageDscT LvCanvasGetImage(global::lvgl.LvObjT canvas)
        {
            var __arg0 = canvas is null ? __IntPtr.Zero : canvas.__Instance;
            var ___ret = __Internal.LvCanvasGetImage(__arg0);
            var __result0 = global::lvgl.LvImageDscT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Return the pointer for the buffer.</para>
        /// <para>It's recommended to use this function instead of the buffer form the</para>
        /// <para>return value of lv_canvas_get_image() as is can be aligned</para>
        /// </summary>
        /// <param name="canvas">pointer to a canvas object</param>
        /// <returns>pointer to the buffer</returns>
        public static __IntPtr LvCanvasGetBuf(global::lvgl.LvObjT canvas)
        {
            var __arg0 = canvas is null ? __IntPtr.Zero : canvas.__Instance;
            var ___ret = __Internal.LvCanvasGetBuf(__arg0);
            return ___ret;
        }

        /// <summary>Copy a buffer to the canvas</summary>
        /// <param name="canvas">pointer to a canvas object</param>
        /// <param name="canvas_area">the area of the canvas to copy</param>
        /// <param name="dest_buf">pointer to a buffer to store the copied data</param>
        /// <param name="dest_area">the area of the destination buffer to copy to. If omitted NULL, copy to the whole `dest_buf`</param>
        public static void LvCanvasCopyBuf(global::lvgl.LvObjT obj, global::lvgl.LvAreaT canvas_area, global::lvgl.LvDrawBufT dest_buf, global::lvgl.LvAreaT dest_area)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = canvas_area is null ? __IntPtr.Zero : canvas_area.__Instance;
            var __arg2 = dest_buf is null ? __IntPtr.Zero : dest_buf.__Instance;
            var __arg3 = dest_area is null ? __IntPtr.Zero : dest_area.__Instance;
            __Internal.LvCanvasCopyBuf(__arg0, __arg1, __arg2, __arg3);
        }

        /// <summary>Fill the canvas with color</summary>
        /// <param name="canvas">pointer to a canvas</param>
        /// <param name="color">the background color</param>
        /// <param name="opa">the desired opacity</param>
        public static void LvCanvasFillBg(global::lvgl.LvObjT obj, global::lvgl.LvColorT color, byte opa)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg1 = color.__Instance;
            __Internal.LvCanvasFillBg(__arg0, __arg1, opa);
        }

        /// <summary>
        /// <para>Initialize a layer to use LVGL's generic draw functions (lv_draw_rect/label/...) on the canvas.</para>
        /// <para>Needs to be usd in pair with `lv_canvas_finish_layer`.</para>
        /// </summary>
        /// <param name="canvas">pointer to a canvas</param>
        /// <param name="layer">pointer to a layer variable to initialize</param>
        public static void LvCanvasInitLayer(global::lvgl.LvObjT canvas, global::lvgl.LvLayerT layer)
        {
            var __arg0 = canvas is null ? __IntPtr.Zero : canvas.__Instance;
            var __arg1 = layer is null ? __IntPtr.Zero : layer.__Instance;
            __Internal.LvCanvasInitLayer(__arg0, __arg1);
        }

        /// <summary>
        /// <para>Wait until all the drawings are finished on layer.</para>
        /// <para>Needs to be usd in pair with `lv_canvas_init_layer`.</para>
        /// </summary>
        /// <param name="canvas">pointer to a canvas</param>
        /// <param name="layer">pointer to a layer to finalize</param>
        public static void LvCanvasFinishLayer(global::lvgl.LvObjT canvas, global::lvgl.LvLayerT layer)
        {
            var __arg0 = canvas is null ? __IntPtr.Zero : canvas.__Instance;
            var __arg1 = layer is null ? __IntPtr.Zero : layer.__Instance;
            __Internal.LvCanvasFinishLayer(__arg0, __arg1);
        }

        /// <summary>
        /// <para>********************</para>
        /// <para>TYPEDEFS</para>
        /// <para>********************</para>
        /// </summary>
        public static global::lvgl.LvObjClassT LvCanvasClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_canvas_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>Chart types</summary>
    public enum LvChartTypeT
    {
        /// <summary>Don't draw the series</summary>
        LV_CHART_TYPE_NONE = 0,
        /// <summary>Connect the points with lines</summary>
        LV_CHART_TYPE_LINE = 1,
        /// <summary>Draw columns</summary>
        LV_CHART_TYPE_BAR = 2,
        /// <summary>Draw points and lines in 2D (x,y coordinates)</summary>
        LV_CHART_TYPE_SCATTER = 3
    }

    /// <summary>Chart update mode for `lv_chart_set_next`</summary>
    public enum LvChartUpdateModeT
    {
        /// <summary>Shift old data to the left and add the new one the right</summary>
        LV_CHART_UPDATE_MODE_SHIFT = 0,
        /// <summary>Add the new data in a circular way</summary>
        LV_CHART_UPDATE_MODE_CIRCULAR = 1
    }

    /// <summary>Enumeration of the axis'</summary>
    public enum LvChartAxisT
    {
        LV_CHART_AXIS_PRIMARY_Y = 0,
        LV_CHART_AXIS_SECONDARY_Y = 1,
        LV_CHART_AXIS_PRIMARY_X = 2,
        LV_CHART_AXIS_SECONDARY_X = 4,
        LV_CHART_AXIS_LAST = 5
    }

    /// <summary>Descriptor a chart series</summary>
    /// <summary>Descriptor a chart series</summary>
    public unsafe partial class LvChartSeriesT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr x_points;

            [FieldOffset(8)]
            internal __IntPtr y_points;

            [FieldOffset(16)]
            internal global::lvgl.LvColorT.__Internal color;

            [FieldOffset(20)]
            internal uint start_point;

            [FieldOffset(24)]
            internal uint hidden;

            [FieldOffset(24)]
            internal uint x_ext_buf_assigned;

            [FieldOffset(24)]
            internal uint y_ext_buf_assigned;

            [FieldOffset(24)]
            internal uint x_axis_sec;

            [FieldOffset(24)]
            internal uint y_axis_sec;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_chart_series_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvChartSeriesT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvChartSeriesT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvChartSeriesT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvChartSeriesT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvChartSeriesT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvChartSeriesT(native.ToPointer(), skipVTables);
        }

        internal static LvChartSeriesT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvChartSeriesT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvChartSeriesT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvChartSeriesT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvChartSeriesT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvChartSeriesT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvChartSeriesT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvChartSeriesT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvChartSeriesT(global::lvgl.LvChartSeriesT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvChartSeriesT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvChartSeriesT.__Internal*) __Instance) = *((global::lvgl.LvChartSeriesT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int* XPoints
        {
            get
            {
                return (int*) ((__Internal*)__Instance)->x_points;
            }

            set
            {
                ((__Internal*)__Instance)->x_points = (__IntPtr) value;
            }
        }

        public int* YPoints
        {
            get
            {
                return (int*) ((__Internal*)__Instance)->y_points;
            }

            set
            {
                ((__Internal*)__Instance)->y_points = (__IntPtr) value;
            }
        }

        public global::lvgl.LvColorT Color
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public uint StartPoint
        {
            get
            {
                return ((__Internal*)__Instance)->start_point;
            }

            set
            {
                ((__Internal*)__Instance)->start_point = value;
            }
        }

        public uint Hidden
        {
            get
            {
                return ((__Internal*)__Instance)->hidden;
            }

            set
            {
                ((__Internal*)__Instance)->hidden = value;
            }
        }

        public uint XExtBufAssigned
        {
            get
            {
                return ((__Internal*)__Instance)->x_ext_buf_assigned;
            }

            set
            {
                ((__Internal*)__Instance)->x_ext_buf_assigned = value;
            }
        }

        public uint YExtBufAssigned
        {
            get
            {
                return ((__Internal*)__Instance)->y_ext_buf_assigned;
            }

            set
            {
                ((__Internal*)__Instance)->y_ext_buf_assigned = value;
            }
        }

        public uint XAxisSec
        {
            get
            {
                return ((__Internal*)__Instance)->x_axis_sec;
            }

            set
            {
                ((__Internal*)__Instance)->x_axis_sec = value;
            }
        }

        public uint YAxisSec
        {
            get
            {
                return ((__Internal*)__Instance)->y_axis_sec;
            }

            set
            {
                ((__Internal*)__Instance)->y_axis_sec = value;
            }
        }
    }

    public unsafe partial class LvChartCursorT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal global::lvgl.LvPointT.__Internal pos;
            internal int point_id;
            internal global::lvgl.LvColorT.__Internal color;
            internal __IntPtr ser;
            internal byte dir;
            internal uint pos_set;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_chart_cursor_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvChartCursorT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvChartCursorT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvChartCursorT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvChartCursorT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvChartCursorT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvChartCursorT(native.ToPointer(), skipVTables);
        }

        internal static LvChartCursorT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvChartCursorT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvChartCursorT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvChartCursorT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvChartCursorT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvChartCursorT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvChartCursorT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvChartCursorT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvChartCursorT(global::lvgl.LvChartCursorT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvChartCursorT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvChartCursorT.__Internal*) __Instance) = *((global::lvgl.LvChartCursorT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvPointT Pos
        {
            get
            {
                return global::lvgl.LvPointT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->pos = *(global::lvgl.LvPointT.__Internal*) value.__Instance;
            }
        }

        public int PointId
        {
            get
            {
                return ((__Internal*)__Instance)->point_id;
            }

            set
            {
                ((__Internal*)__Instance)->point_id = value;
            }
        }

        public global::lvgl.LvColorT Color
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvChartSeriesT Ser
        {
            get
            {
                var __result0 = global::lvgl.LvChartSeriesT.__GetOrCreateInstance(((__Internal*)__Instance)->ser, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ser = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public byte Dir
        {
            get
            {
                return ((__Internal*)__Instance)->dir;
            }

            set
            {
                ((__Internal*)__Instance)->dir = value;
            }
        }

        public uint PosSet
        {
            get
            {
                return ((__Internal*)__Instance)->pos_set;
            }

            set
            {
                ((__Internal*)__Instance)->pos_set = value;
            }
        }
    }

    public unsafe partial class LvChartT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 168)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvObjT.__Internal obj;

            [FieldOffset(64)]
            internal global::lvgl.LvLlT.__Internal series_ll;

            [FieldOffset(88)]
            internal global::lvgl.LvLlT.__Internal cursor_ll;

            [FieldOffset(112)]
            internal fixed int ymin[2];

            [FieldOffset(120)]
            internal fixed int ymax[2];

            [FieldOffset(128)]
            internal fixed int xmin[2];

            [FieldOffset(136)]
            internal fixed int xmax[2];

            [FieldOffset(144)]
            internal int pressed_point_id;

            [FieldOffset(148)]
            internal uint hdiv_cnt;

            [FieldOffset(152)]
            internal uint vdiv_cnt;

            [FieldOffset(156)]
            internal uint point_cnt;

            [FieldOffset(160)]
            internal byte type;

            [FieldOffset(160)]
            internal byte update_mode;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_chart_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvChartT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvChartT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvChartT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvChartT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvChartT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvChartT(native.ToPointer(), skipVTables);
        }

        internal static LvChartT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvChartT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvChartT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvChartT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvChartT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvChartT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvChartT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvChartT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvChartT(global::lvgl.LvChartT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvChartT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvChartT.__Internal*) __Instance) = *((global::lvgl.LvChartT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Linked list for the series (stores lv_chart_series_t)</summary>
        public global::lvgl.LvLlT SeriesLl
        {
            get
            {
                return global::lvgl.LvLlT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->series_ll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->series_ll = *(global::lvgl.LvLlT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Linked list for the cursors (stores lv_chart_cursor_t)</summary>
        public global::lvgl.LvLlT CursorLl
        {
            get
            {
                return global::lvgl.LvLlT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->cursor_ll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->cursor_ll = *(global::lvgl.LvLlT.__Internal*) value.__Instance;
            }
        }

        public int[] Ymin
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->ymin, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->ymin[i] = value[i];
                }
            }
        }

        public int[] Ymax
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->ymax, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->ymax[i] = value[i];
                }
            }
        }

        public int[] Xmin
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->xmin, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->xmin[i] = value[i];
                }
            }
        }

        public int[] Xmax
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->xmax, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->xmax[i] = value[i];
                }
            }
        }

        public int PressedPointId
        {
            get
            {
                return ((__Internal*)__Instance)->pressed_point_id;
            }

            set
            {
                ((__Internal*)__Instance)->pressed_point_id = value;
            }
        }

        /// <summary>Number of horizontal division lines</summary>
        public uint HdivCnt
        {
            get
            {
                return ((__Internal*)__Instance)->hdiv_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->hdiv_cnt = value;
            }
        }

        /// <summary>Number of vertical division lines</summary>
        public uint VdivCnt
        {
            get
            {
                return ((__Internal*)__Instance)->vdiv_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->vdiv_cnt = value;
            }
        }

        /// <summary>Point number in a data line</summary>
        public uint PointCnt
        {
            get
            {
                return ((__Internal*)__Instance)->point_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->point_cnt = value;
            }
        }

        /// <summary>Line or column chart</summary>
        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public byte UpdateMode
        {
            get
            {
                return ((__Internal*)__Instance)->update_mode;
            }

            set
            {
                ((__Internal*)__Instance)->update_mode = value;
            }
        }
    }

    public unsafe partial class lv_chart
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvChartCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_set_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartSetType(__IntPtr obj, byte type);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_set_point_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartSetPointCount(__IntPtr obj, uint cnt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_set_range", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartSetRange(__IntPtr obj, byte axis, int min, int max);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_set_update_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartSetUpdateMode(__IntPtr obj, byte update_mode);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_set_div_line_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartSetDivLineCount(__IntPtr obj, byte hdiv, byte vdiv);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_get_type", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvChartGetType(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_get_point_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvChartGetPointCount(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_get_x_start_point", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvChartGetXStartPoint(__IntPtr obj, __IntPtr ser);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_get_point_pos_by_id", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartGetPointPosById(__IntPtr obj, __IntPtr ser, uint id, __IntPtr p_out);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_refresh", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartRefresh(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_add_series", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvChartAddSeries(__IntPtr obj, __IntPtr color, byte axis);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_remove_series", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartRemoveSeries(__IntPtr obj, __IntPtr series);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_hide_series", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartHideSeries(__IntPtr chart, __IntPtr series, bool hide);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_set_series_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartSetSeriesColor(__IntPtr chart, __IntPtr series, __IntPtr color);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_set_x_start_point", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartSetXStartPoint(__IntPtr obj, __IntPtr ser, uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_get_series_next", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvChartGetSeriesNext(__IntPtr chart, __IntPtr ser);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_add_cursor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvChartAddCursor(__IntPtr obj, __IntPtr color, byte dir);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_set_cursor_pos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartSetCursorPos(__IntPtr chart, __IntPtr cursor, __IntPtr pos);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_set_cursor_point", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartSetCursorPoint(__IntPtr chart, __IntPtr cursor, __IntPtr ser, uint point_id);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_get_cursor_point", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::lvgl.LvPointT.__Internal LvChartGetCursorPoint(__IntPtr chart, __IntPtr cursor);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_set_all_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartSetAllValue(__IntPtr obj, __IntPtr ser, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_set_next_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartSetNextValue(__IntPtr obj, __IntPtr ser, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_set_next_value2", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartSetNextValue2(__IntPtr obj, __IntPtr ser, int x_value, int y_value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_set_value_by_id", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartSetValueById(__IntPtr obj, __IntPtr ser, uint id, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_set_value_by_id2", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartSetValueById2(__IntPtr obj, __IntPtr ser, uint id, int x_value, int y_value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_set_ext_y_array", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartSetExtYArray(__IntPtr obj, __IntPtr ser, int[] array);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_set_ext_x_array", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvChartSetExtXArray(__IntPtr obj, __IntPtr ser, int[] array);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_get_y_array", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int* LvChartGetYArray(__IntPtr obj, __IntPtr ser);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_get_x_array", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int* LvChartGetXArray(__IntPtr obj, __IntPtr ser);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_get_pressed_point", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvChartGetPressedPoint(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_chart_get_first_point_center_offset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvChartGetFirstPointCenterOffset(__IntPtr obj);
        }

        /// <summary>Create a chart object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new chart</param>
        /// <returns>pointer to the created chart</returns>
        public static global::lvgl.LvObjT LvChartCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvChartCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set a new type for a chart</summary>
        /// <param name="obj">pointer to a chart object</param>
        /// <param name="type">new type of the chart (from 'lv_chart_type_t' enum)</param>
        public static void LvChartSetType(global::lvgl.LvObjT obj, byte type)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvChartSetType(__arg0, type);
        }

        /// <summary>Set the number of points on a data line on a chart</summary>
        /// <param name="obj">pointer to a chart object</param>
        /// <param name="cnt">new number of points on the data lines</param>
        public static void LvChartSetPointCount(global::lvgl.LvObjT obj, uint cnt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvChartSetPointCount(__arg0, cnt);
        }

        /// <summary>Set the minimal and maximal y values on an axis</summary>
        /// <param name="obj">pointer to a chart object</param>
        /// <param name="axis">`LV_CHART_AXIS_PRIMARY_Y` or `LV_CHART_AXIS_SECONDARY_Y`</param>
        /// <param name="min">minimum value of the y axis</param>
        /// <param name="max">maximum value of the y axis</param>
        public static void LvChartSetRange(global::lvgl.LvObjT obj, byte axis, int min, int max)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvChartSetRange(__arg0, axis, min, max);
        }

        /// <summary>Set update mode of the chart object. Affects</summary>
        /// <param name="obj">pointer to a chart object</param>
        /// <param name="update_mode">the update mode</param>
        public static void LvChartSetUpdateMode(global::lvgl.LvObjT obj, byte update_mode)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvChartSetUpdateMode(__arg0, update_mode);
        }

        /// <summary>Set the number of horizontal and vertical division lines</summary>
        /// <param name="obj">pointer to a chart object</param>
        /// <param name="hdiv">number of horizontal division lines</param>
        /// <param name="vdiv">number of vertical division lines</param>
        public static void LvChartSetDivLineCount(global::lvgl.LvObjT obj, byte hdiv, byte vdiv)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvChartSetDivLineCount(__arg0, hdiv, vdiv);
        }

        /// <summary>Get the type of a chart</summary>
        /// <param name="obj">pointer to chart object</param>
        /// <returns>type of the chart (from 'lv_chart_t' enum)</returns>
        public static byte LvChartGetType(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvChartGetType(__arg0);
            return ___ret;
        }

        /// <summary>Get the data point number per data line on chart</summary>
        /// <param name="obj">pointer to chart object</param>
        /// <returns>point number on each data line</returns>
        public static uint LvChartGetPointCount(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvChartGetPointCount(__arg0);
            return ___ret;
        }

        /// <summary>Get the current index of the x-axis start point in the data array</summary>
        /// <param name="obj">pointer to a chart object</param>
        /// <param name="ser">pointer to a data series on 'chart'</param>
        /// <returns>the index of the current x start point in the data array</returns>
        public static uint LvChartGetXStartPoint(global::lvgl.LvObjT obj, global::lvgl.LvChartSeriesT ser)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = ser is null ? __IntPtr.Zero : ser.__Instance;
            var ___ret = __Internal.LvChartGetXStartPoint(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Get the position of a point to the chart.</summary>
        /// <param name="obj">pointer to a chart object</param>
        /// <param name="ser">pointer to series</param>
        /// <param name="id">the index.</param>
        /// <param name="p_out">store the result position here</param>
        public static void LvChartGetPointPosById(global::lvgl.LvObjT obj, global::lvgl.LvChartSeriesT ser, uint id, global::lvgl.LvPointT p_out)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = ser is null ? __IntPtr.Zero : ser.__Instance;
            var __arg3 = p_out is null ? __IntPtr.Zero : p_out.__Instance;
            __Internal.LvChartGetPointPosById(__arg0, __arg1, id, __arg3);
        }

        /// <summary>Refresh a chart if its data line has changed</summary>
        /// <param name="obj">pointer to chart object</param>
        public static void LvChartRefresh(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvChartRefresh(__arg0);
        }

        /// <summary>Allocate and add a data series to the chart</summary>
        /// <param name="obj">pointer to a chart object</param>
        /// <param name="color">color of the data series</param>
        /// <param name="axis">the y axis to which the series should be attached (::LV_CHART_AXIS_PRIMARY_Y or ::LV_CHART_AXIS_SECONDARY_Y)</param>
        /// <returns>pointer to the allocated data series or NULL on failure</returns>
        public static global::lvgl.LvChartSeriesT LvChartAddSeries(global::lvgl.LvObjT obj, global::lvgl.LvColorT color, byte axis)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg1 = color.__Instance;
            var ___ret = __Internal.LvChartAddSeries(__arg0, __arg1, axis);
            var __result0 = global::lvgl.LvChartSeriesT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Deallocate and remove a data series from a chart</summary>
        /// <param name="obj">pointer to a chart object</param>
        /// <param name="series">pointer to a data series on 'chart'</param>
        public static void LvChartRemoveSeries(global::lvgl.LvObjT obj, global::lvgl.LvChartSeriesT series)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = series is null ? __IntPtr.Zero : series.__Instance;
            __Internal.LvChartRemoveSeries(__arg0, __arg1);
        }

        /// <summary>Hide/Unhide a single series of a chart.</summary>
        /// <param name="chart">pointer to a chart object.</param>
        /// <param name="series">pointer to a series object</param>
        /// <param name="hide">true: hide the series</param>
        public static void LvChartHideSeries(global::lvgl.LvObjT chart, global::lvgl.LvChartSeriesT series, bool hide)
        {
            var __arg0 = chart is null ? __IntPtr.Zero : chart.__Instance;
            var __arg1 = series is null ? __IntPtr.Zero : series.__Instance;
            __Internal.LvChartHideSeries(__arg0, __arg1, hide);
        }

        /// <summary>Change the color of a series</summary>
        /// <param name="chart">pointer to a chart object.</param>
        /// <param name="series">pointer to a series object</param>
        /// <param name="color">the new color of the series</param>
        public static void LvChartSetSeriesColor(global::lvgl.LvObjT chart, global::lvgl.LvChartSeriesT series, global::lvgl.LvColorT color)
        {
            var __arg0 = chart is null ? __IntPtr.Zero : chart.__Instance;
            var __arg1 = series is null ? __IntPtr.Zero : series.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg2 = color.__Instance;
            __Internal.LvChartSetSeriesColor(__arg0, __arg1, __arg2);
        }

        /// <summary>
        /// <para>Set the index of the x-axis start point in the data array.</para>
        /// <para>This point will be considers the first (left) point and the other points will be drawn after it.</para>
        /// </summary>
        /// <param name="obj">pointer to a chart object</param>
        /// <param name="ser">pointer to a data series on 'chart'</param>
        /// <param name="id">the index of the x point in the data array</param>
        public static void LvChartSetXStartPoint(global::lvgl.LvObjT obj, global::lvgl.LvChartSeriesT ser, uint id)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = ser is null ? __IntPtr.Zero : ser.__Instance;
            __Internal.LvChartSetXStartPoint(__arg0, __arg1, id);
        }

        /// <summary>Get the next series.</summary>
        /// <param name="chart">pointer to a chart</param>
        /// <param name="ser">the previous series or NULL to get the first</param>
        /// <returns>the next series or NULL if there is no more.</returns>
        public static global::lvgl.LvChartSeriesT LvChartGetSeriesNext(global::lvgl.LvObjT chart, global::lvgl.LvChartSeriesT ser)
        {
            var __arg0 = chart is null ? __IntPtr.Zero : chart.__Instance;
            var __arg1 = ser is null ? __IntPtr.Zero : ser.__Instance;
            var ___ret = __Internal.LvChartGetSeriesNext(__arg0, __arg1);
            var __result0 = global::lvgl.LvChartSeriesT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Add a cursor with a given color</summary>
        /// <param name="obj">pointer to chart object</param>
        /// <param name="color">color of the cursor</param>
        /// <param name="dir">direction of the cursor. `LV_DIR_RIGHT/LEFT/TOP/DOWN/HOR/VER/ALL`. OR-ed values are possible</param>
        /// <returns>pointer to the created cursor</returns>
        public static global::lvgl.LvChartCursorT LvChartAddCursor(global::lvgl.LvObjT obj, global::lvgl.LvColorT color, byte dir)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg1 = color.__Instance;
            var ___ret = __Internal.LvChartAddCursor(__arg0, __arg1, dir);
            var __result0 = global::lvgl.LvChartCursorT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the coordinate of the cursor with respect to the paddings</summary>
        /// <param name="chart">pointer to a chart object</param>
        /// <param name="cursor">pointer to the cursor</param>
        /// <param name="pos">the new coordinate of cursor relative to the chart</param>
        public static void LvChartSetCursorPos(global::lvgl.LvObjT chart, global::lvgl.LvChartCursorT cursor, global::lvgl.LvPointT pos)
        {
            var __arg0 = chart is null ? __IntPtr.Zero : chart.__Instance;
            var __arg1 = cursor is null ? __IntPtr.Zero : cursor.__Instance;
            var __arg2 = pos is null ? __IntPtr.Zero : pos.__Instance;
            __Internal.LvChartSetCursorPos(__arg0, __arg1, __arg2);
        }

        /// <summary>Stick the cursor to a point</summary>
        /// <param name="chart">pointer to a chart object</param>
        /// <param name="cursor">pointer to the cursor</param>
        /// <param name="ser">pointer to a series</param>
        /// <param name="point_id">the point's index or `LV_CHART_POINT_NONE` to not assign to any points.</param>
        public static void LvChartSetCursorPoint(global::lvgl.LvObjT chart, global::lvgl.LvChartCursorT cursor, global::lvgl.LvChartSeriesT ser, uint point_id)
        {
            var __arg0 = chart is null ? __IntPtr.Zero : chart.__Instance;
            var __arg1 = cursor is null ? __IntPtr.Zero : cursor.__Instance;
            var __arg2 = ser is null ? __IntPtr.Zero : ser.__Instance;
            __Internal.LvChartSetCursorPoint(__arg0, __arg1, __arg2, point_id);
        }

        /// <summary>Get the coordinate of the cursor with respect to the paddings</summary>
        /// <param name="chart">pointer to a chart object</param>
        /// <param name="cursor">pointer to cursor</param>
        /// <returns>coordinate of the cursor as lv_point_t</returns>
        public static global::lvgl.LvPointT LvChartGetCursorPoint(global::lvgl.LvObjT chart, global::lvgl.LvChartCursorT cursor)
        {
            var __arg0 = chart is null ? __IntPtr.Zero : chart.__Instance;
            var __arg1 = cursor is null ? __IntPtr.Zero : cursor.__Instance;
            var ___ret = __Internal.LvChartGetCursorPoint(__arg0, __arg1);
            return global::lvgl.LvPointT.__CreateInstance(___ret);
        }

        /// <summary>Initialize all data points of a series with a value</summary>
        /// <param name="obj">pointer to chart object</param>
        /// <param name="ser">pointer to a data series on 'chart'</param>
        /// <param name="value">the new value for all points. `LV_CHART_POINT_NONE` can be used to hide the points.</param>
        public static void LvChartSetAllValue(global::lvgl.LvObjT obj, global::lvgl.LvChartSeriesT ser, int value)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = ser is null ? __IntPtr.Zero : ser.__Instance;
            __Internal.LvChartSetAllValue(__arg0, __arg1, value);
        }

        /// <summary>Set the next point's Y value according to the update mode policy.</summary>
        /// <param name="obj">pointer to chart object</param>
        /// <param name="ser">pointer to a data series on 'chart'</param>
        /// <param name="value">the new value of the next data</param>
        public static void LvChartSetNextValue(global::lvgl.LvObjT obj, global::lvgl.LvChartSeriesT ser, int value)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = ser is null ? __IntPtr.Zero : ser.__Instance;
            __Internal.LvChartSetNextValue(__arg0, __arg1, value);
        }

        /// <summary>Set the next point's X and Y value according to the update mode policy.</summary>
        /// <param name="obj">pointer to chart object</param>
        /// <param name="ser">pointer to a data series on 'chart'</param>
        /// <param name="x_value">the new X value of the next data</param>
        /// <param name="y_value">the new Y value of the next data</param>
        public static void LvChartSetNextValue2(global::lvgl.LvObjT obj, global::lvgl.LvChartSeriesT ser, int x_value, int y_value)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = ser is null ? __IntPtr.Zero : ser.__Instance;
            __Internal.LvChartSetNextValue2(__arg0, __arg1, x_value, y_value);
        }

        /// <summary>Set an individual point's y value of a chart's series directly based on its index</summary>
        /// <param name="obj">pointer to a chart object</param>
        /// <param name="ser">pointer to a data series on 'chart'</param>
        /// <param name="id">the index of the x point in the array</param>
        /// <param name="value">value to assign to array point</param>
        public static void LvChartSetValueById(global::lvgl.LvObjT obj, global::lvgl.LvChartSeriesT ser, uint id, int value)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = ser is null ? __IntPtr.Zero : ser.__Instance;
            __Internal.LvChartSetValueById(__arg0, __arg1, id, value);
        }

        /// <summary>
        /// <para>Set an individual point's x and y value of a chart's series directly based on its index</para>
        /// <para>Can be used only with `LV_CHART_TYPE_SCATTER`.</para>
        /// </summary>
        /// <param name="obj">pointer to chart object</param>
        /// <param name="ser">pointer to a data series on 'chart'</param>
        /// <param name="id">the index of the x point in the array</param>
        /// <param name="x_value">the new X value of the next data</param>
        /// <param name="y_value">the new Y value of the next data</param>
        public static void LvChartSetValueById2(global::lvgl.LvObjT obj, global::lvgl.LvChartSeriesT ser, uint id, int x_value, int y_value)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = ser is null ? __IntPtr.Zero : ser.__Instance;
            __Internal.LvChartSetValueById2(__arg0, __arg1, id, x_value, y_value);
        }

        /// <summary>
        /// <para>Set an external array for the y data points to use for the chart</para>
        /// <para>NOTE: It is the users responsibility to make sure the `point_cnt` matches the external array size.</para>
        /// </summary>
        /// <param name="obj">pointer to a chart object</param>
        /// <param name="ser">pointer to a data series on 'chart'</param>
        /// <param name="array">external array of points for chart</param>
        public static void LvChartSetExtYArray(global::lvgl.LvObjT obj, global::lvgl.LvChartSeriesT ser, int[] array)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = ser is null ? __IntPtr.Zero : ser.__Instance;
            __Internal.LvChartSetExtYArray(__arg0, __arg1, array);
        }

        /// <summary>
        /// <para>Set an external array for the x data points to use for the chart</para>
        /// <para>NOTE: It is the users responsibility to make sure the `point_cnt` matches the external array size.</para>
        /// </summary>
        /// <param name="obj">pointer to a chart object</param>
        /// <param name="ser">pointer to a data series on 'chart'</param>
        /// <param name="array">external array of points for chart</param>
        public static void LvChartSetExtXArray(global::lvgl.LvObjT obj, global::lvgl.LvChartSeriesT ser, int[] array)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = ser is null ? __IntPtr.Zero : ser.__Instance;
            __Internal.LvChartSetExtXArray(__arg0, __arg1, array);
        }

        /// <summary>Get the array of y values of a series</summary>
        /// <param name="obj">pointer to a chart object</param>
        /// <param name="ser">pointer to a data series on 'chart'</param>
        /// <returns>the array of values with 'point_count' elements</returns>
        public static int* LvChartGetYArray(global::lvgl.LvObjT obj, global::lvgl.LvChartSeriesT ser)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = ser is null ? __IntPtr.Zero : ser.__Instance;
            var ___ret = __Internal.LvChartGetYArray(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Get the array of x values of a series</summary>
        /// <param name="obj">pointer to a chart object</param>
        /// <param name="ser">pointer to a data series on 'chart'</param>
        /// <returns>the array of values with 'point_count' elements</returns>
        public static int* LvChartGetXArray(global::lvgl.LvObjT obj, global::lvgl.LvChartSeriesT ser)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = ser is null ? __IntPtr.Zero : ser.__Instance;
            var ___ret = __Internal.LvChartGetXArray(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Get the index of the currently pressed point. It's the same for every series.</summary>
        /// <param name="obj">pointer to a chart object</param>
        /// <returns>the index of the point [0 .. point count] or LV_CHART_POINT_ID_NONE if no point is being pressed</returns>
        public static uint LvChartGetPressedPoint(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvChartGetPressedPoint(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Get the overall offset from the chart's side to the center of the first point.</para>
        /// <para>In case of a bar chart it will be the center of the first column group</para>
        /// </summary>
        /// <param name="obj">pointer to a chart object</param>
        /// <returns>the offset of the center</returns>
        public static int LvChartGetFirstPointCenterOffset(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvChartGetFirstPointCenterOffset(__arg0);
            return ___ret;
        }

        public static global::lvgl.LvObjClassT LvChartClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_chart_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    public unsafe partial class lv_checkbox
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_checkbox_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCheckboxCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_checkbox_set_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvCheckboxSetText(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string txt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_checkbox_get_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvCheckboxGetText(__IntPtr obj);
        }

        /// <summary>Create a check box object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new button</param>
        /// <returns>pointer to the created check box</returns>
        public static global::lvgl.LvObjT LvCheckboxCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvCheckboxCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Set the text of a check box. `txt` will be copied and may be deallocated</para>
        /// <para>after this function returns.</para>
        /// </summary>
        /// <param name="obj">pointer to a check box</param>
        /// <param name="txt">the text of the check box. NULL to refresh with the current text.</param>
        public static void LvCheckboxSetText(global::lvgl.LvObjT obj, string txt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvCheckboxSetText(__arg0, txt);
        }

        /// <summary>Get the text of a check box</summary>
        /// <param name="obj">pointer to check box object</param>
        /// <returns>pointer to the text of the check box</returns>
        public static string LvCheckboxGetText(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvCheckboxGetText(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        public static global::lvgl.LvObjClassT LvCheckboxClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_checkbox_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    public unsafe partial class LvDropdownListT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal global::lvgl.LvObjT.__Internal obj;
            internal __IntPtr dropdown;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_dropdown_list_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDropdownListT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDropdownListT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDropdownListT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDropdownListT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDropdownListT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDropdownListT(native.ToPointer(), skipVTables);
        }

        internal static LvDropdownListT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDropdownListT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDropdownListT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDropdownListT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDropdownListT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDropdownListT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDropdownListT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDropdownListT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDropdownListT(global::lvgl.LvDropdownListT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDropdownListT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDropdownListT.__Internal*) __Instance) = *((global::lvgl.LvDropdownListT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvObjT Dropdown
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->dropdown, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->dropdown = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class lv_dropdown
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDropdownCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_set_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDropdownSetText(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string txt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_set_options", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDropdownSetOptions(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string options);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_add_option", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDropdownAddOption(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string option, uint pos);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_clear_options", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDropdownClearOptions(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_set_selected", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDropdownSetSelected(__IntPtr obj, uint sel_opt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_set_dir", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDropdownSetDir(__IntPtr obj, byte dir);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_set_symbol", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDropdownSetSymbol(__IntPtr obj, __IntPtr symbol);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_set_selected_highlight", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDropdownSetSelectedHighlight(__IntPtr obj, bool en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_get_list", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDropdownGetList(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_get_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDropdownGetText(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_get_options", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDropdownGetOptions(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_get_selected", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvDropdownGetSelected(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_get_option_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvDropdownGetOptionCount(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_get_selected_str", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDropdownGetSelectedStr(__IntPtr obj, sbyte* buf, uint buf_size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_get_option_index", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvDropdownGetOptionIndex(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string option);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_get_symbol", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDropdownGetSymbol(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_get_selected_highlight", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvDropdownGetSelectedHighlight(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_get_dir", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvDropdownGetDir(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_open", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDropdownOpen(__IntPtr dropdown_obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_close", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDropdownClose(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_is_open", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvDropdownIsOpen(__IntPtr obj);
        }

        /// <summary>Create a drop-down list object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new drop-down list</param>
        /// <returns>pointer to the created drop-down list</returns>
        public static global::lvgl.LvObjT LvDropdownCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvDropdownCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Set text of the drop-down list's button.</para>
        /// <para>If set to `NULL` the selected option's text will be displayed on the button.</para>
        /// <para>If set to a specific text then that text will be shown regardless of the selected option.</para>
        /// </summary>
        /// <param name="obj">pointer to a drop-down list object</param>
        /// <param name="txt">the text as a string (Only its pointer is saved)</param>
        public static void LvDropdownSetText(global::lvgl.LvObjT obj, string txt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvDropdownSetText(__arg0, txt);
        }

        /// <summary>
        /// <para>Set the options in a drop-down list from a string.</para>
        /// <para>The options will be copied and saved in the object so the `options` can be destroyed after calling this function</para>
        /// </summary>
        /// <param name="obj">pointer to drop-down list object</param>
        /// <param name="options">a string with '' separated options. E.g. &quot;One\nTwo\nThree&quot;</param>
        public static void LvDropdownSetOptions(global::lvgl.LvObjT obj, string options)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvDropdownSetOptions(__arg0, options);
        }

        /// <summary>Add an options to a drop-down list from a string.  Only works for non-static options.</summary>
        /// <param name="obj">pointer to drop-down list object</param>
        /// <param name="option">a string without ''. E.g. &quot;Four&quot;</param>
        /// <param name="pos">the insert position, indexed from 0, LV_DROPDOWN_POS_LAST = end of string</param>
        public static void LvDropdownAddOption(global::lvgl.LvObjT obj, string option, uint pos)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvDropdownAddOption(__arg0, option, pos);
        }

        /// <summary>Clear all options in a drop-down list.  Works with both static and dynamic options.</summary>
        /// <param name="obj">pointer to drop-down list object</param>
        public static void LvDropdownClearOptions(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvDropdownClearOptions(__arg0);
        }

        /// <summary>Set the selected option</summary>
        /// <param name="obj">pointer to drop-down list object</param>
        /// <param name="sel_opt">id of the selected option (0 ... number of option - 1);</param>
        public static void LvDropdownSetSelected(global::lvgl.LvObjT obj, uint sel_opt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvDropdownSetSelected(__arg0, sel_opt);
        }

        /// <summary>Set the direction of the a drop-down list</summary>
        /// <param name="obj">pointer to a drop-down list object</param>
        /// <param name="dir">LV_DIR_LEFT/RIGHT/TOP/BOTTOM</param>
        public static void LvDropdownSetDir(global::lvgl.LvObjT obj, byte dir)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvDropdownSetDir(__arg0, dir);
        }

        /// <summary>Set an arrow or other symbol to display when on drop-down list's button. Typically a down caret or arrow.</summary>
        /// <param name="obj">pointer to drop-down list object</param>
        /// <param name="symbol">a text like `LV_SYMBOL_DOWN`, an image (pointer or path) or NULL to not draw symbol icon</param>
        /// <remarks>
        /// <para>angle and zoom transformation can be applied if the symbol is an image.</para>
        /// <para>E.g. when drop down is checked (opened) rotate the symbol by 180 degree</para>
        /// </remarks>
        public static void LvDropdownSetSymbol(global::lvgl.LvObjT obj, __IntPtr symbol)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvDropdownSetSymbol(__arg0, symbol);
        }

        /// <summary>Set whether the selected option in the list should be highlighted or not</summary>
        /// <param name="obj">pointer to drop-down list object</param>
        /// <param name="en">true: highlight enabled; false: disabled</param>
        public static void LvDropdownSetSelectedHighlight(global::lvgl.LvObjT obj, bool en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvDropdownSetSelectedHighlight(__arg0, en);
        }

        /// <summary>Get the list of a drop-down to allow styling or other modifications</summary>
        /// <param name="obj">pointer to a drop-down list object</param>
        /// <returns>pointer to the list of the drop-down</returns>
        public static global::lvgl.LvObjT LvDropdownGetList(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvDropdownGetList(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get text of the drop-down list's button.</summary>
        /// <param name="obj">pointer to a drop-down list object</param>
        /// <returns>the text as string, `NULL` if no text</returns>
        public static string LvDropdownGetText(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvDropdownGetText(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the options of a drop-down list</summary>
        /// <param name="obj">pointer to drop-down list object</param>
        /// <returns>the options separated by ''-s (E.g. &quot;Option1\nOption2\nOption3&quot;)</returns>
        public static string LvDropdownGetOptions(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvDropdownGetOptions(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the index of the selected option</summary>
        /// <param name="obj">pointer to drop-down list object</param>
        /// <returns>index of the selected option (0 ... number of option - 1);</returns>
        public static uint LvDropdownGetSelected(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvDropdownGetSelected(__arg0);
            return ___ret;
        }

        /// <summary>Get the total number of options</summary>
        /// <param name="obj">pointer to drop-down list object</param>
        /// <returns>the total number of options in the list</returns>
        public static uint LvDropdownGetOptionCount(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvDropdownGetOptionCount(__arg0);
            return ___ret;
        }

        /// <summary>Get the current selected option as a string</summary>
        /// <param name="obj">pointer to drop-down object</param>
        /// <param name="buf">pointer to an array to store the string</param>
        /// <param name="buf_size">size of `buf` in bytes. 0: to ignore it.</param>
        public static void LvDropdownGetSelectedStr(global::lvgl.LvObjT obj, sbyte* buf, uint buf_size)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvDropdownGetSelectedStr(__arg0, buf, buf_size);
        }

        /// <summary>Get the index of an option.</summary>
        /// <param name="obj">pointer to drop-down object</param>
        /// <param name="option">an option as string</param>
        /// <returns>index of `option` in the list of all options. -1 if not found.</returns>
        public static int LvDropdownGetOptionIndex(global::lvgl.LvObjT obj, string option)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvDropdownGetOptionIndex(__arg0, option);
            return ___ret;
        }

        /// <summary>Get the symbol on the drop-down list. Typically a down caret or arrow.</summary>
        /// <param name="obj">pointer to drop-down list object</param>
        /// <returns>the symbol or NULL if not enabled</returns>
        public static string LvDropdownGetSymbol(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvDropdownGetSymbol(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get whether the selected option in the list should be highlighted or not</summary>
        /// <param name="obj">pointer to drop-down list object</param>
        /// <returns>true: highlight enabled; false: disabled</returns>
        public static bool LvDropdownGetSelectedHighlight(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvDropdownGetSelectedHighlight(__arg0);
            return ___ret;
        }

        /// <summary>Get the direction of the drop-down list</summary>
        /// <param name="obj">pointer to a drop-down list object</param>
        /// <returns>LV_DIR_LEF/RIGHT/TOP/BOTTOM</returns>
        public static byte LvDropdownGetDir(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvDropdownGetDir(__arg0);
            return ___ret;
        }

        /// <summary>Open the drop.down list</summary>
        /// <param name="dropdown_obj">pointer to drop-down list object</param>
        public static void LvDropdownOpen(global::lvgl.LvObjT dropdown_obj)
        {
            var __arg0 = dropdown_obj is null ? __IntPtr.Zero : dropdown_obj.__Instance;
            __Internal.LvDropdownOpen(__arg0);
        }

        /// <summary>Close (Collapse) the drop-down list</summary>
        /// <param name="obj">pointer to drop-down list object</param>
        public static void LvDropdownClose(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvDropdownClose(__arg0);
        }

        /// <summary>Tells whether the list is opened or not</summary>
        /// <param name="obj">pointer to a drop-down list object</param>
        /// <returns>true if the list os opened</returns>
        public static bool LvDropdownIsOpen(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvDropdownIsOpen(__arg0);
            return ___ret;
        }

        public static global::lvgl.LvObjClassT LvDropdownClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_dropdown_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvDropdownlistClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_dropdownlist_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>*******************</para>
    /// <para>DEFINES</para>
    /// <para>*******************</para>
    /// </summary>
    public enum LvImagebuttonStateT
    {
        LV_IMAGEBUTTON_STATE_RELEASED = 0,
        LV_IMAGEBUTTON_STATE_PRESSED = 1,
        LV_IMAGEBUTTON_STATE_DISABLED = 2,
        LV_IMAGEBUTTON_STATE_CHECKED_RELEASED = 3,
        LV_IMAGEBUTTON_STATE_CHECKED_PRESSED = 4,
        LV_IMAGEBUTTON_STATE_CHECKED_DISABLED = 5,
        LV_IMAGEBUTTON_STATE_NUM = 6
    }

    /// <summary>
    /// <para>*******************</para>
    /// <para>DEFINES</para>
    /// <para>*******************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvImagebuttonSrcInfoT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr img_src;
            internal global::lvgl.LvImageHeaderT.__Internal header;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_imagebutton_src_info_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImagebuttonSrcInfoT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImagebuttonSrcInfoT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvImagebuttonSrcInfoT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvImagebuttonSrcInfoT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvImagebuttonSrcInfoT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvImagebuttonSrcInfoT(native.ToPointer(), skipVTables);
        }

        internal static LvImagebuttonSrcInfoT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvImagebuttonSrcInfoT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvImagebuttonSrcInfoT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvImagebuttonSrcInfoT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvImagebuttonSrcInfoT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvImagebuttonSrcInfoT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvImagebuttonSrcInfoT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImagebuttonSrcInfoT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvImagebuttonSrcInfoT(global::lvgl.LvImagebuttonSrcInfoT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImagebuttonSrcInfoT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvImagebuttonSrcInfoT.__Internal*) __Instance) = *((global::lvgl.LvImagebuttonSrcInfoT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr ImgSrc
        {
            get
            {
                return ((__Internal*)__Instance)->img_src;
            }
        }

        public global::lvgl.LvImageHeaderT Header
        {
            get
            {
                return global::lvgl.LvImageHeaderT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->header));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->header = *(global::lvgl.LvImageHeaderT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvImagebuttonT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 496)]
        public partial struct __Internal
        {
            internal global::lvgl.LvObjT.__Internal obj;
            internal fixed byte src_mid[144];
            internal fixed byte src_left[144];
            internal fixed byte src_right[144];

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_imagebutton_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImagebuttonT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvImagebuttonT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvImagebuttonT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvImagebuttonT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvImagebuttonT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvImagebuttonT(native.ToPointer(), skipVTables);
        }

        internal static LvImagebuttonT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvImagebuttonT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvImagebuttonT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvImagebuttonT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvImagebuttonT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvImagebuttonT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvImagebuttonT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImagebuttonT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvImagebuttonT(global::lvgl.LvImagebuttonT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvImagebuttonT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvImagebuttonT.__Internal*) __Instance) = *((global::lvgl.LvImagebuttonT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvImagebuttonSrcInfoT[] SrcMid
        {
            get
            {
                global::lvgl.LvImagebuttonSrcInfoT[] __value = null;
                if (((__Internal*)__Instance)->src_mid != null)
                {
                    __value = new global::lvgl.LvImagebuttonSrcInfoT[6];
                    for (int i = 0; i < 6; i++)
                        __value[i] = global::lvgl.LvImagebuttonSrcInfoT.__GetOrCreateInstance((IntPtr)((global::lvgl.LvImagebuttonSrcInfoT.__Internal*)&(((__Internal*)__Instance)->src_mid[i * sizeof(global::lvgl.LvImagebuttonSrcInfoT.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 6)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 6; i++)
                        *(global::lvgl.LvImagebuttonSrcInfoT.__Internal*) &((__Internal*)__Instance)->src_mid[i * sizeof(global::lvgl.LvImagebuttonSrcInfoT.__Internal)] = *(global::lvgl.LvImagebuttonSrcInfoT.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::lvgl.LvImagebuttonSrcInfoT[] SrcLeft
        {
            get
            {
                global::lvgl.LvImagebuttonSrcInfoT[] __value = null;
                if (((__Internal*)__Instance)->src_left != null)
                {
                    __value = new global::lvgl.LvImagebuttonSrcInfoT[6];
                    for (int i = 0; i < 6; i++)
                        __value[i] = global::lvgl.LvImagebuttonSrcInfoT.__GetOrCreateInstance((IntPtr)((global::lvgl.LvImagebuttonSrcInfoT.__Internal*)&(((__Internal*)__Instance)->src_left[i * sizeof(global::lvgl.LvImagebuttonSrcInfoT.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 6)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 6; i++)
                        *(global::lvgl.LvImagebuttonSrcInfoT.__Internal*) &((__Internal*)__Instance)->src_left[i * sizeof(global::lvgl.LvImagebuttonSrcInfoT.__Internal)] = *(global::lvgl.LvImagebuttonSrcInfoT.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::lvgl.LvImagebuttonSrcInfoT[] SrcRight
        {
            get
            {
                global::lvgl.LvImagebuttonSrcInfoT[] __value = null;
                if (((__Internal*)__Instance)->src_right != null)
                {
                    __value = new global::lvgl.LvImagebuttonSrcInfoT[6];
                    for (int i = 0; i < 6; i++)
                        __value[i] = global::lvgl.LvImagebuttonSrcInfoT.__GetOrCreateInstance((IntPtr)((global::lvgl.LvImagebuttonSrcInfoT.__Internal*)&(((__Internal*)__Instance)->src_right[i * sizeof(global::lvgl.LvImagebuttonSrcInfoT.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 6)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 6; i++)
                        *(global::lvgl.LvImagebuttonSrcInfoT.__Internal*) &((__Internal*)__Instance)->src_right[i * sizeof(global::lvgl.LvImagebuttonSrcInfoT.__Internal)] = *(global::lvgl.LvImagebuttonSrcInfoT.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class lv_imagebutton
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_imagebutton_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvImagebuttonCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_imagebutton_set_src", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImagebuttonSetSrc(__IntPtr imagebutton, global::lvgl.LvImagebuttonStateT state, __IntPtr src_left, __IntPtr src_mid, __IntPtr src_right);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_imagebutton_set_state", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvImagebuttonSetState(__IntPtr imagebutton, global::lvgl.LvImagebuttonStateT state);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_imagebutton_get_src_left", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvImagebuttonGetSrcLeft(__IntPtr imagebutton, global::lvgl.LvImagebuttonStateT state);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_imagebutton_get_src_middle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvImagebuttonGetSrcMiddle(__IntPtr imagebutton, global::lvgl.LvImagebuttonStateT state);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_imagebutton_get_src_right", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvImagebuttonGetSrcRight(__IntPtr imagebutton, global::lvgl.LvImagebuttonStateT state);
        }

        /// <summary>Create an image button object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new image button</param>
        /// <returns>pointer to the created image button</returns>
        public static global::lvgl.LvObjT LvImagebuttonCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvImagebuttonCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set images for a state of the image button</summary>
        /// <param name="imagebutton">pointer to an image button object</param>
        /// <param name="state">for which state set the new image</param>
        /// <param name="src_left">
        /// <para>pointer to an image source for the left side of the button (a C array or path to</para>
        /// <para>a file)</para>
        /// </param>
        /// <param name="src_mid">
        /// <para>pointer to an image source for the middle of the button (ideally 1px wide) (a C</para>
        /// <para>array or path to a file)</para>
        /// </param>
        /// <param name="src_right">
        /// <para>pointer to an image source for the right side of the button (a C array or path</para>
        /// <para>to a file)</para>
        /// </param>
        public static void LvImagebuttonSetSrc(global::lvgl.LvObjT imagebutton, global::lvgl.LvImagebuttonStateT state, __IntPtr src_left, __IntPtr src_mid, __IntPtr src_right)
        {
            var __arg0 = imagebutton is null ? __IntPtr.Zero : imagebutton.__Instance;
            __Internal.LvImagebuttonSetSrc(__arg0, state, src_left, src_mid, src_right);
        }

        /// <summary>Use this function instead of `lv_obj_add/remove_state` to set a state manually</summary>
        /// <param name="imagebutton">pointer to an image button object</param>
        /// <param name="state">the new state</param>
        public static void LvImagebuttonSetState(global::lvgl.LvObjT imagebutton, global::lvgl.LvImagebuttonStateT state)
        {
            var __arg0 = imagebutton is null ? __IntPtr.Zero : imagebutton.__Instance;
            __Internal.LvImagebuttonSetState(__arg0, state);
        }

        /// <summary>Get the left image in a given state</summary>
        /// <param name="imagebutton">pointer to an image button object</param>
        /// <param name="state">the state where to get the image (from `lv_button_state_t`) `</param>
        /// <returns>pointer to the left image source (a C array or path to a file)</returns>
        public static __IntPtr LvImagebuttonGetSrcLeft(global::lvgl.LvObjT imagebutton, global::lvgl.LvImagebuttonStateT state)
        {
            var __arg0 = imagebutton is null ? __IntPtr.Zero : imagebutton.__Instance;
            var ___ret = __Internal.LvImagebuttonGetSrcLeft(__arg0, state);
            return ___ret;
        }

        /// <summary>Get the middle image in a given state</summary>
        /// <param name="imagebutton">pointer to an image button object</param>
        /// <param name="state">the state where to get the image (from `lv_button_state_t`) `</param>
        /// <returns>pointer to the middle image source (a C array or path to a file)</returns>
        public static __IntPtr LvImagebuttonGetSrcMiddle(global::lvgl.LvObjT imagebutton, global::lvgl.LvImagebuttonStateT state)
        {
            var __arg0 = imagebutton is null ? __IntPtr.Zero : imagebutton.__Instance;
            var ___ret = __Internal.LvImagebuttonGetSrcMiddle(__arg0, state);
            return ___ret;
        }

        /// <summary>Get the right image in a given state</summary>
        /// <param name="imagebutton">pointer to an image button object</param>
        /// <param name="state">the state where to get the image (from `lv_button_state_t`) `</param>
        /// <returns>pointer to the left image source (a C array or path to a file)</returns>
        public static __IntPtr LvImagebuttonGetSrcRight(global::lvgl.LvObjT imagebutton, global::lvgl.LvImagebuttonStateT state)
        {
            var __arg0 = imagebutton is null ? __IntPtr.Zero : imagebutton.__Instance;
            var ___ret = __Internal.LvImagebuttonGetSrcRight(__arg0, state);
            return ___ret;
        }

        public static global::lvgl.LvObjClassT LvImagebuttonClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_imagebutton_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>Current keyboard mode.</summary>
    public enum LvKeyboardModeT
    {
        LV_KEYBOARD_MODE_TEXT_LOWER = 0,
        LV_KEYBOARD_MODE_TEXT_UPPER = 1,
        LV_KEYBOARD_MODE_SPECIAL = 2,
        LV_KEYBOARD_MODE_NUMBER = 3,
        LV_KEYBOARD_MODE_USER_1 = 4,
        LV_KEYBOARD_MODE_USER_2 = 5,
        LV_KEYBOARD_MODE_USER_3 = 6,
        LV_KEYBOARD_MODE_USER_4 = 7
    }

    public unsafe partial class LvKeyboardT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 120)]
        public partial struct __Internal
        {
            internal global::lvgl.LvButtonmatrixT.__Internal btnm;
            internal __IntPtr ta;
            internal byte mode;
            internal byte popovers;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_keyboard_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvKeyboardT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvKeyboardT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvKeyboardT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvKeyboardT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvKeyboardT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvKeyboardT(native.ToPointer(), skipVTables);
        }

        internal static LvKeyboardT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvKeyboardT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvKeyboardT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvKeyboardT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvKeyboardT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvKeyboardT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvKeyboardT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvKeyboardT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvKeyboardT(global::lvgl.LvKeyboardT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvKeyboardT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvKeyboardT.__Internal*) __Instance) = *((global::lvgl.LvKeyboardT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvButtonmatrixT Btnm
        {
            get
            {
                return global::lvgl.LvButtonmatrixT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->btnm));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->btnm = *(global::lvgl.LvButtonmatrixT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvObjT Ta
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->ta, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ta = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public byte Mode
        {
            get
            {
                return ((__Internal*)__Instance)->mode;
            }

            set
            {
                ((__Internal*)__Instance)->mode = value;
            }
        }

        public byte Popovers
        {
            get
            {
                return ((__Internal*)__Instance)->popovers;
            }

            set
            {
                ((__Internal*)__Instance)->popovers = value;
            }
        }
    }

    public unsafe partial class lv_keyboard
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_keyboard_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvKeyboardCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_keyboard_set_textarea", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvKeyboardSetTextarea(__IntPtr kb, __IntPtr ta);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_keyboard_set_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvKeyboardSetMode(__IntPtr kb, byte mode);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_keyboard_set_popovers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvKeyboardSetPopovers(__IntPtr kb, bool en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_keyboard_set_map", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvKeyboardSetMap(__IntPtr kb, byte mode, [MarshalAs(UnmanagedType.LPArray)] string[] map, uint[] ctrl_map);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_keyboard_get_textarea", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvKeyboardGetTextarea(__IntPtr kb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_keyboard_get_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvKeyboardGetMode(__IntPtr kb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_buttonmatrix_get_popovers", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvButtonmatrixGetPopovers(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_keyboard_def_event_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvKeyboardDefEventCb(__IntPtr e);
        }

        /// <summary>Create a Keyboard object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new keyboard</param>
        /// <returns>pointer to the created keyboard</returns>
        public static global::lvgl.LvObjT LvKeyboardCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvKeyboardCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Assign a Text Area to the Keyboard. The pressed characters will be put there.</summary>
        /// <param name="kb">pointer to a Keyboard object</param>
        /// <param name="ta">pointer to a Text Area object to write there</param>
        public static void LvKeyboardSetTextarea(global::lvgl.LvObjT kb, global::lvgl.LvObjT ta)
        {
            var __arg0 = kb is null ? __IntPtr.Zero : kb.__Instance;
            var __arg1 = ta is null ? __IntPtr.Zero : ta.__Instance;
            __Internal.LvKeyboardSetTextarea(__arg0, __arg1);
        }

        /// <summary>Set a new a mode (text or number map)</summary>
        /// <param name="kb">pointer to a Keyboard object</param>
        /// <param name="mode">the mode from 'lv_keyboard_mode_t'</param>
        public static void LvKeyboardSetMode(global::lvgl.LvObjT kb, byte mode)
        {
            var __arg0 = kb is null ? __IntPtr.Zero : kb.__Instance;
            __Internal.LvKeyboardSetMode(__arg0, mode);
        }

        /// <summary>Show the button title in a popover when pressed.</summary>
        /// <param name="kb">pointer to a Keyboard object</param>
        /// <param name="en">whether &quot;popovers&quot; mode is enabled</param>
        public static void LvKeyboardSetPopovers(global::lvgl.LvObjT kb, bool en)
        {
            var __arg0 = kb is null ? __IntPtr.Zero : kb.__Instance;
            __Internal.LvKeyboardSetPopovers(__arg0, en);
        }

        /// <summary>Set a new map for the keyboard</summary>
        /// <param name="kb">pointer to a Keyboard object</param>
        /// <param name="mode">keyboard map to alter 'lv_keyboard_mode_t'</param>
        /// <param name="map">
        /// <para>pointer to a string array to describe the map.</para>
        /// <para>See 'lv_buttonmatrix_set_map()' for more info.</para>
        /// </param>
        /// <param name="ctrl_map">See 'lv_buttonmatrix_set_ctrl_map()' for more info.</param>
        public static void LvKeyboardSetMap(global::lvgl.LvObjT kb, byte mode, string[] map, uint[] ctrl_map)
        {
            var __arg0 = kb is null ? __IntPtr.Zero : kb.__Instance;
            __Internal.LvKeyboardSetMap(__arg0, mode, map, ctrl_map);
        }

        /// <summary>Assign a Text Area to the Keyboard. The pressed characters will be put there.</summary>
        /// <param name="kb">pointer to a Keyboard object</param>
        /// <returns>pointer to the assigned Text Area object</returns>
        public static global::lvgl.LvObjT LvKeyboardGetTextarea(global::lvgl.LvObjT kb)
        {
            var __arg0 = kb is null ? __IntPtr.Zero : kb.__Instance;
            var ___ret = __Internal.LvKeyboardGetTextarea(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set a new a mode (text or number map)</summary>
        /// <param name="kb">pointer to a Keyboard object</param>
        /// <returns>the current mode from 'lv_keyboard_mode_t'</returns>
        public static byte LvKeyboardGetMode(global::lvgl.LvObjT kb)
        {
            var __arg0 = kb is null ? __IntPtr.Zero : kb.__Instance;
            var ___ret = __Internal.LvKeyboardGetMode(__arg0);
            return ___ret;
        }

        /// <summary>Tell whether &quot;popovers&quot; mode is enabled or not.</summary>
        /// <param name="obj">pointer to a Keyboard object</param>
        /// <returns>true: &quot;popovers&quot; mode is enabled; false: disabled</returns>
        public static bool LvButtonmatrixGetPopovers(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvButtonmatrixGetPopovers(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Default keyboard event to add characters to the Text area and change the map.</para>
        /// <para>If a custom `event_cb` is added to the keyboard this function can be called from it to handle the</para>
        /// <para>button clicks</para>
        /// </summary>
        /// <param name="e">the triggering event</param>
        public static void LvKeyboardDefEventCb(global::lvgl.LvEventT e)
        {
            var __arg0 = e is null ? __IntPtr.Zero : e.__Instance;
            __Internal.LvKeyboardDefEventCb(__arg0);
        }

        public static global::lvgl.LvObjClassT LvKeyboardClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_keyboard_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvLedT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal global::lvgl.LvObjT.__Internal obj;
            internal global::lvgl.LvColorT.__Internal color;
            internal byte bright;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_led_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvLedT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvLedT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvLedT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvLedT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvLedT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvLedT(native.ToPointer(), skipVTables);
        }

        internal static LvLedT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvLedT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvLedT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvLedT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvLedT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvLedT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvLedT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvLedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvLedT(global::lvgl.LvLedT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvLedT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvLedT.__Internal*) __Instance) = *((global::lvgl.LvLedT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvColorT Color
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Current brightness of the LED (0..255)</summary>
        public byte Bright
        {
            get
            {
                return ((__Internal*)__Instance)->bright;
            }

            set
            {
                ((__Internal*)__Instance)->bright = value;
            }
        }
    }

    public unsafe partial class lv_led
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_led_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvLedCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_led_set_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLedSetColor(__IntPtr led, __IntPtr color);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_led_set_brightness", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLedSetBrightness(__IntPtr led, byte bright);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_led_on", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLedOn(__IntPtr led);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_led_off", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLedOff(__IntPtr led);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_led_toggle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLedToggle(__IntPtr led);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_led_get_brightness", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvLedGetBrightness(__IntPtr obj);
        }

        /// <summary>Create a led object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new led</param>
        /// <returns>pointer to the created led</returns>
        public static global::lvgl.LvObjT LvLedCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvLedCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the color of the LED</summary>
        /// <param name="led">pointer to a LED object</param>
        /// <param name="color">the color of the LED</param>
        public static void LvLedSetColor(global::lvgl.LvObjT led, global::lvgl.LvColorT color)
        {
            var __arg0 = led is null ? __IntPtr.Zero : led.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg1 = color.__Instance;
            __Internal.LvLedSetColor(__arg0, __arg1);
        }

        /// <summary>Set the brightness of a LED object</summary>
        /// <param name="led">pointer to a LED object</param>
        /// <param name="bright">LV_LED_BRIGHT_MIN (max. dark) ... LV_LED_BRIGHT_MAX (max. light)</param>
        public static void LvLedSetBrightness(global::lvgl.LvObjT led, byte bright)
        {
            var __arg0 = led is null ? __IntPtr.Zero : led.__Instance;
            __Internal.LvLedSetBrightness(__arg0, bright);
        }

        /// <summary>Light on a LED</summary>
        /// <param name="led">pointer to a LED object</param>
        public static void LvLedOn(global::lvgl.LvObjT led)
        {
            var __arg0 = led is null ? __IntPtr.Zero : led.__Instance;
            __Internal.LvLedOn(__arg0);
        }

        /// <summary>Light off a LED</summary>
        /// <param name="led">pointer to a LED object</param>
        public static void LvLedOff(global::lvgl.LvObjT led)
        {
            var __arg0 = led is null ? __IntPtr.Zero : led.__Instance;
            __Internal.LvLedOff(__arg0);
        }

        /// <summary>Toggle the state of a LED</summary>
        /// <param name="led">pointer to a LED object</param>
        public static void LvLedToggle(global::lvgl.LvObjT led)
        {
            var __arg0 = led is null ? __IntPtr.Zero : led.__Instance;
            __Internal.LvLedToggle(__arg0);
        }

        /// <summary>Get the brightness of a LED object</summary>
        /// <param name="obj">pointer to LED object</param>
        /// <returns>bright   0 (max. dark) ... 255 (max. light)</returns>
        public static byte LvLedGetBrightness(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvLedGetBrightness(__arg0);
            return ___ret;
        }

        public static global::lvgl.LvObjClassT LvLedClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_led_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvLineT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvObjT.__Internal obj;

            [FieldOffset(64)]
            internal global::lvgl.LvLineT.PointArray.__Internal point_array;

            [FieldOffset(72)]
            internal uint point_num;

            [FieldOffset(76)]
            internal uint y_inv;

            [FieldOffset(76)]
            internal uint point_array_is_mutable;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_line_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial struct PointArray
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal __IntPtr constant;

                [FieldOffset(0)]
                internal __IntPtr mut;

                [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0<unnamed-type-point_array>@lv_line_t@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            private PointArray.__Internal __instance;
            internal ref PointArray.__Internal __Instance => ref __instance;

            internal static PointArray __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new PointArray(native.ToPointer(), skipVTables);
            }

            internal static PointArray __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PointArray(native, skipVTables);
            }

            private PointArray(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private PointArray(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::lvgl.LvLineT.PointArray.__Internal*) native;
            }

            public PointArray(global::lvgl.LvLineT.PointArray _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            public global::lvgl.LvPointPreciseT Constant
            {
                get
                {
                    var __result0 = global::lvgl.LvPointPreciseT.__GetOrCreateInstance(__instance.constant, false);
                    return __result0;
                }
            }

            public global::lvgl.LvPointPreciseT Mut
            {
                get
                {
                    var __result0 = global::lvgl.LvPointPreciseT.__GetOrCreateInstance(__instance.mut, false);
                    return __result0;
                }

                set
                {
                    __instance.mut = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvLineT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvLineT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvLineT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvLineT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvLineT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvLineT(native.ToPointer(), skipVTables);
        }

        internal static LvLineT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvLineT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvLineT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvLineT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvLineT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvLineT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvLineT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvLineT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvLineT(global::lvgl.LvLineT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvLineT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvLineT.__Internal*) __Instance) = *((global::lvgl.LvLineT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Pointer to an array with the points of the line</summary>
        public global::lvgl.LvLineT.PointArray point_array
        {
            get
            {
                return global::lvgl.LvLineT.PointArray.__CreateInstance(((__Internal*)__Instance)->point_array);
            }

            set
            {
                ((__Internal*)__Instance)->point_array = value.__Instance;
            }
        }

        /// <summary>Number of points in 'point_array'</summary>
        public uint PointNum
        {
            get
            {
                return ((__Internal*)__Instance)->point_num;
            }

            set
            {
                ((__Internal*)__Instance)->point_num = value;
            }
        }

        /// <summary>1: y == 0 will be on the bottom</summary>
        public uint YInv
        {
            get
            {
                return ((__Internal*)__Instance)->y_inv;
            }

            set
            {
                ((__Internal*)__Instance)->y_inv = value;
            }
        }

        /// <summary>whether the point array is const or mutable</summary>
        public uint PointArrayIsMutable
        {
            get
            {
                return ((__Internal*)__Instance)->point_array_is_mutable;
            }

            set
            {
                ((__Internal*)__Instance)->point_array_is_mutable = value;
            }
        }
    }

    public unsafe partial class lv_line
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_line_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvLineCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_line_set_points", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLineSetPoints(__IntPtr obj, global::lvgl.LvPointPreciseT.__Internal[] points, uint point_num);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_line_set_points_mutable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLineSetPointsMutable(__IntPtr obj, global::lvgl.LvPointPreciseT.__Internal[] points, uint point_num);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_line_set_y_invert", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvLineSetYInvert(__IntPtr obj, bool en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_line_get_points", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvLineGetPoints(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_line_get_point_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvLineGetPointCount(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_line_is_point_array_mutable", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvLineIsPointArrayMutable(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_line_get_points_mutable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvLineGetPointsMutable(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_line_get_y_invert", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvLineGetYInvert(__IntPtr obj);
        }

        /// <summary>Create a line object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new line</param>
        /// <returns>pointer to the created line</returns>
        public static global::lvgl.LvObjT LvLineCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvLineCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set an array of points. The line object will connect these points.</summary>
        /// <param name="obj">pointer to a line object</param>
        /// <param name="points">an array of points. Only the address is saved, so the array needs to be alive while the line exists</param>
        /// <param name="point_num">number of points in 'point_a'</param>
        public static void LvLineSetPoints(global::lvgl.LvObjT obj, global::lvgl.LvPointPreciseT[] points, uint point_num)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            global::lvgl.LvPointPreciseT.__Internal[] __points;
            if (points == null)
                __points = null;
            else
            {
                __points = new global::lvgl.LvPointPreciseT.__Internal[points.Length];
                for (int i = 0; i < __points.Length; i++)
                {
                    var __element = points[i];
                    __points[i] = __element is null ? new global::lvgl.LvPointPreciseT.__Internal() : *(global::lvgl.LvPointPreciseT.__Internal*) __element.__Instance;
                }
            }
            var __arg1 = __points;
            __Internal.LvLineSetPoints(__arg0, __arg1, point_num);
        }

        /// <summary>Set a non-const array of points. Identical to `lv_line_set_points` except the array may be retrieved by `lv_line_get_points_mutable`.</summary>
        /// <param name="obj">pointer to a line object</param>
        /// <param name="points">a non-const array of points. Only the address is saved, so the array needs to be alive while the line exists.</param>
        /// <param name="point_num">number of points in 'point_a'</param>
        public static void LvLineSetPointsMutable(global::lvgl.LvObjT obj, global::lvgl.LvPointPreciseT[] points, uint point_num)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            global::lvgl.LvPointPreciseT.__Internal[] __points;
            if (points == null)
                __points = null;
            else
            {
                __points = new global::lvgl.LvPointPreciseT.__Internal[points.Length];
                for (int i = 0; i < __points.Length; i++)
                {
                    var __element = points[i];
                    __points[i] = __element is null ? new global::lvgl.LvPointPreciseT.__Internal() : *(global::lvgl.LvPointPreciseT.__Internal*) __element.__Instance;
                }
            }
            var __arg1 = __points;
            __Internal.LvLineSetPointsMutable(__arg0, __arg1, point_num);
        }

        /// <summary>
        /// <para>Enable (or disable) the y coordinate inversion.</para>
        /// <para>If enabled then y will be subtracted from the height of the object,</para>
        /// <para>therefore the y = 0 coordinate will be on the bottom.</para>
        /// </summary>
        /// <param name="obj">pointer to a line object</param>
        /// <param name="en">true: enable the y inversion, false:disable the y inversion</param>
        public static void LvLineSetYInvert(global::lvgl.LvObjT obj, bool en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvLineSetYInvert(__arg0, en);
        }

        /// <summary>Get the pointer to the array of points.</summary>
        /// <param name="obj">pointer to a line object</param>
        /// <returns>const pointer to the array of points</returns>
        public static global::lvgl.LvPointPreciseT LvLineGetPoints(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvLineGetPoints(__arg0);
            var __result0 = global::lvgl.LvPointPreciseT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the number of points in the array of points.</summary>
        /// <param name="obj">pointer to a line object</param>
        /// <returns>number of points in array of points</returns>
        public static uint LvLineGetPointCount(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvLineGetPointCount(__arg0);
            return ___ret;
        }

        /// <summary>Check the mutability of the stored point array pointer.</summary>
        /// <param name="obj">pointer to a line object</param>
        /// <returns>true: the point array pointer is mutable, false: constant</returns>
        public static bool LvLineIsPointArrayMutable(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvLineIsPointArrayMutable(__arg0);
            return ___ret;
        }

        /// <summary>Get a pointer to the mutable array of points or NULL if it is not mutable</summary>
        /// <param name="obj">pointer to a line object</param>
        /// <returns>pointer to the array of points. NULL if not mutable.</returns>
        public static global::lvgl.LvPointPreciseT LvLineGetPointsMutable(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvLineGetPointsMutable(__arg0);
            var __result0 = global::lvgl.LvPointPreciseT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the y inversion attribute</summary>
        /// <param name="obj">pointer to a line object</param>
        /// <returns>true: y inversion is enabled, false: disabled</returns>
        public static bool LvLineGetYInvert(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvLineGetYInvert(__arg0);
            return ___ret;
        }

        public static global::lvgl.LvObjClassT LvLineClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_line_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    public unsafe partial class lv_list
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_list_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvListCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_list_add_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvListAddText(__IntPtr list, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string txt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_list_add_button", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvListAddButton(__IntPtr list, __IntPtr icon, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string txt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_list_get_button_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvListGetButtonText(__IntPtr list, __IntPtr btn);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_list_set_button_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvListSetButtonText(__IntPtr list, __IntPtr btn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string txt);
        }

        /// <summary>Create a list object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new list</param>
        /// <returns>pointer to the created list</returns>
        public static global::lvgl.LvObjT LvListCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvListCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Add text to a list</summary>
        /// <param name="list">pointer to a list, it will be the parent of the new label</param>
        /// <param name="txt">text of the new label</param>
        /// <returns>pointer to the created label</returns>
        public static global::lvgl.LvObjT LvListAddText(global::lvgl.LvObjT list, string txt)
        {
            var __arg0 = list is null ? __IntPtr.Zero : list.__Instance;
            var ___ret = __Internal.LvListAddText(__arg0, txt);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Add button to a list</summary>
        /// <param name="list">pointer to a list, it will be the parent of the new button</param>
        /// <param name="icon">icon for the button, when NULL it will have no icon</param>
        /// <param name="txt">text of the new button, when NULL no text will be added</param>
        /// <returns>pointer to the created button</returns>
        public static global::lvgl.LvObjT LvListAddButton(global::lvgl.LvObjT list, __IntPtr icon, string txt)
        {
            var __arg0 = list is null ? __IntPtr.Zero : list.__Instance;
            var ___ret = __Internal.LvListAddButton(__arg0, icon, txt);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get text of a given list button</summary>
        /// <param name="list">pointer to a list</param>
        /// <param name="btn">pointer to the button</param>
        /// <returns>text of btn, if btn doesn't have text &quot;&quot; will be returned</returns>
        public static string LvListGetButtonText(global::lvgl.LvObjT list, global::lvgl.LvObjT btn)
        {
            var __arg0 = list is null ? __IntPtr.Zero : list.__Instance;
            var __arg1 = btn is null ? __IntPtr.Zero : btn.__Instance;
            var ___ret = __Internal.LvListGetButtonText(__arg0, __arg1);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Set text of a given list button</summary>
        /// <param name="list">pointer to a list</param>
        /// <param name="btn">pointer to the button</param>
        /// <param name="txt">pointer to the text</param>
        /// <returns>text of btn, if btn doesn't have text &quot;&quot; will be returned</returns>
        public static void LvListSetButtonText(global::lvgl.LvObjT list, global::lvgl.LvObjT btn, string txt)
        {
            var __arg0 = list is null ? __IntPtr.Zero : list.__Instance;
            var __arg1 = btn is null ? __IntPtr.Zero : btn.__Instance;
            __Internal.LvListSetButtonText(__arg0, __arg1, txt);
        }

        /// <summary>
        /// <para>********************</para>
        /// <para>TYPEDEFS</para>
        /// <para>********************</para>
        /// </summary>
        public static global::lvgl.LvObjClassT LvListClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_list_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvListTextClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_list_text_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvListButtonClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_list_button_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public enum LvMenuModeHeaderT
    {
        LV_MENU_HEADER_TOP_FIXED = 0,
        LV_MENU_HEADER_TOP_UNFIXED = 1,
        LV_MENU_HEADER_BOTTOM_FIXED = 2
    }

    public enum LvMenuModeRootBackButtonT
    {
        LV_MENU_ROOT_BACK_BUTTON_DISABLED = 0,
        LV_MENU_ROOT_BACK_BUTTON_ENABLED = 1
    }

    /// <summary>Tells Doxygen to ignore a duplicate declaration</summary>
    public unsafe partial class LvMenuLoadPageEventDataT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr menu;
            internal __IntPtr page;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_menu_load_page_event_data_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvMenuLoadPageEventDataT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvMenuLoadPageEventDataT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvMenuLoadPageEventDataT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvMenuLoadPageEventDataT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvMenuLoadPageEventDataT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvMenuLoadPageEventDataT(native.ToPointer(), skipVTables);
        }

        internal static LvMenuLoadPageEventDataT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvMenuLoadPageEventDataT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvMenuLoadPageEventDataT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvMenuLoadPageEventDataT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvMenuLoadPageEventDataT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvMenuLoadPageEventDataT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvMenuLoadPageEventDataT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvMenuLoadPageEventDataT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvMenuLoadPageEventDataT(global::lvgl.LvMenuLoadPageEventDataT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvMenuLoadPageEventDataT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvMenuLoadPageEventDataT.__Internal*) __Instance) = *((global::lvgl.LvMenuLoadPageEventDataT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Menu
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->menu, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->menu = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjT Page
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->page, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->page = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class LvMenuHistoryT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr page;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_menu_history_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvMenuHistoryT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvMenuHistoryT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvMenuHistoryT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvMenuHistoryT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvMenuHistoryT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvMenuHistoryT(native.ToPointer(), skipVTables);
        }

        internal static LvMenuHistoryT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvMenuHistoryT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvMenuHistoryT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvMenuHistoryT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvMenuHistoryT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvMenuHistoryT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvMenuHistoryT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvMenuHistoryT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvMenuHistoryT(global::lvgl.LvMenuHistoryT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvMenuHistoryT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvMenuHistoryT.__Internal*) __Instance) = *((global::lvgl.LvMenuHistoryT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Page
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->page, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->page = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class LvMenuT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 192)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvObjT.__Internal obj;

            [FieldOffset(64)]
            internal __IntPtr storage;

            [FieldOffset(72)]
            internal __IntPtr main;

            [FieldOffset(80)]
            internal __IntPtr main_page;

            [FieldOffset(88)]
            internal __IntPtr main_header;

            [FieldOffset(96)]
            internal __IntPtr main_header_back_btn;

            [FieldOffset(104)]
            internal __IntPtr main_header_title;

            [FieldOffset(112)]
            internal __IntPtr sidebar;

            [FieldOffset(120)]
            internal __IntPtr sidebar_page;

            [FieldOffset(128)]
            internal __IntPtr sidebar_header;

            [FieldOffset(136)]
            internal __IntPtr sidebar_header_back_btn;

            [FieldOffset(144)]
            internal __IntPtr sidebar_header_title;

            [FieldOffset(152)]
            internal __IntPtr selected_tab;

            [FieldOffset(160)]
            internal global::lvgl.LvLlT.__Internal history_ll;

            [FieldOffset(184)]
            internal byte cur_depth;

            [FieldOffset(185)]
            internal byte prev_depth;

            [FieldOffset(186)]
            internal byte sidebar_generated;

            [FieldOffset(186)]
            internal byte mode_header;

            [FieldOffset(186)]
            internal byte mode_root_back_btn;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_menu_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvMenuT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvMenuT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvMenuT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvMenuT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvMenuT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvMenuT(native.ToPointer(), skipVTables);
        }

        internal static LvMenuT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvMenuT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvMenuT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvMenuT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvMenuT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvMenuT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvMenuT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvMenuT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvMenuT(global::lvgl.LvMenuT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvMenuT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvMenuT.__Internal*) __Instance) = *((global::lvgl.LvMenuT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvObjT Storage
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->storage, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->storage = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjT Main
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->main, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->main = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjT MainPage
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->main_page, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->main_page = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjT MainHeader
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->main_header, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->main_header = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjT MainHeaderBackBtn
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->main_header_back_btn, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->main_header_back_btn = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjT MainHeaderTitle
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->main_header_title, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->main_header_title = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjT Sidebar
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->sidebar, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->sidebar = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjT SidebarPage
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->sidebar_page, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->sidebar_page = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjT SidebarHeader
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->sidebar_header, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->sidebar_header = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjT SidebarHeaderBackBtn
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->sidebar_header_back_btn, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->sidebar_header_back_btn = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjT SidebarHeaderTitle
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->sidebar_header_title, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->sidebar_header_title = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjT SelectedTab
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->selected_tab, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->selected_tab = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvLlT HistoryLl
        {
            get
            {
                return global::lvgl.LvLlT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->history_ll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->history_ll = *(global::lvgl.LvLlT.__Internal*) value.__Instance;
            }
        }

        public byte CurDepth
        {
            get
            {
                return ((__Internal*)__Instance)->cur_depth;
            }

            set
            {
                ((__Internal*)__Instance)->cur_depth = value;
            }
        }

        public byte PrevDepth
        {
            get
            {
                return ((__Internal*)__Instance)->prev_depth;
            }

            set
            {
                ((__Internal*)__Instance)->prev_depth = value;
            }
        }

        public byte SidebarGenerated
        {
            get
            {
                return ((__Internal*)__Instance)->sidebar_generated;
            }

            set
            {
                ((__Internal*)__Instance)->sidebar_generated = value;
            }
        }

        public byte ModeHeader
        {
            get
            {
                return ((__Internal*)__Instance)->mode_header;
            }

            set
            {
                ((__Internal*)__Instance)->mode_header = value;
            }
        }

        public byte ModeRootBackBtn
        {
            get
            {
                return ((__Internal*)__Instance)->mode_root_back_btn;
            }

            set
            {
                ((__Internal*)__Instance)->mode_root_back_btn = value;
            }
        }
    }

    public unsafe partial class lv_menu
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMenuCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_page_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMenuPageCreate(__IntPtr parent, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string title);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_cont_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMenuContCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_section_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMenuSectionCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_separator_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMenuSeparatorCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_set_page", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvMenuSetPage(__IntPtr obj, __IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_set_page_title", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvMenuSetPageTitle(__IntPtr page, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string title);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_set_sidebar_page", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvMenuSetSidebarPage(__IntPtr obj, __IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_set_mode_header", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvMenuSetModeHeader(__IntPtr obj, byte mode);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_set_mode_root_back_button", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvMenuSetModeRootBackButton(__IntPtr obj, byte mode);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_set_load_page_event", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvMenuSetLoadPageEvent(__IntPtr menu, __IntPtr obj, __IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_get_cur_main_page", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMenuGetCurMainPage(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_get_cur_sidebar_page", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMenuGetCurSidebarPage(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_get_main_header", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMenuGetMainHeader(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_get_main_header_back_button", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMenuGetMainHeaderBackButton(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_get_sidebar_header", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMenuGetSidebarHeader(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_get_sidebar_header_back_button", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMenuGetSidebarHeaderBackButton(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_back_button_is_root", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvMenuBackButtonIsRoot(__IntPtr menu, __IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_menu_clear_history", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvMenuClearHistory(__IntPtr obj);
        }

        /// <summary>Create a menu object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new menu</param>
        /// <returns>pointer to the created menu</returns>
        public static global::lvgl.LvObjT LvMenuCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvMenuCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create a menu page object</summary>
        /// <param name="parent">pointer to menu object</param>
        /// <param name="title">pointer to text for title in header (NULL to not display title)</param>
        /// <returns>pointer to the created menu page</returns>
        public static global::lvgl.LvObjT LvMenuPageCreate(global::lvgl.LvObjT parent, string title)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvMenuPageCreate(__arg0, title);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create a menu cont object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new menu cont object</param>
        /// <returns>pointer to the created menu cont</returns>
        public static global::lvgl.LvObjT LvMenuContCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvMenuContCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create a menu section object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new menu section object</param>
        /// <returns>pointer to the created menu section</returns>
        public static global::lvgl.LvObjT LvMenuSectionCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvMenuSectionCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create a menu separator object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new menu separator object</param>
        /// <returns>pointer to the created menu separator</returns>
        public static global::lvgl.LvObjT LvMenuSeparatorCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvMenuSeparatorCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set menu page to display in main</summary>
        /// <param name="obj">pointer to the menu</param>
        /// <param name="page">pointer to the menu page to set (NULL to clear main and clear menu history)</param>
        public static void LvMenuSetPage(global::lvgl.LvObjT obj, global::lvgl.LvObjT page)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            __Internal.LvMenuSetPage(__arg0, __arg1);
        }

        /// <summary>Set menu page title</summary>
        /// <param name="page">pointer to the menu page</param>
        /// <param name="title">pointer to text for title in header (NULL to not display title)</param>
        public static void LvMenuSetPageTitle(global::lvgl.LvObjT page, string title)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            __Internal.LvMenuSetPageTitle(__arg0, title);
        }

        /// <summary>Set menu page to display in sidebar</summary>
        /// <param name="obj">pointer to the menu</param>
        /// <param name="page">pointer to the menu page to set (NULL to clear sidebar)</param>
        public static void LvMenuSetSidebarPage(global::lvgl.LvObjT obj, global::lvgl.LvObjT page)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            __Internal.LvMenuSetSidebarPage(__arg0, __arg1);
        }

        /// <summary>Set the how the header should behave and its position</summary>
        /// <param name="obj">pointer to a menu</param>
        /// <param name="mode">LV_MENU_HEADER_TOP_FIXED/TOP_UNFIXED/BOTTOM_FIXED</param>
        public static void LvMenuSetModeHeader(global::lvgl.LvObjT obj, byte mode)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvMenuSetModeHeader(__arg0, mode);
        }

        /// <summary>Set whether back button should appear at root</summary>
        /// <param name="obj">pointer to a menu</param>
        /// <param name="mode">LV_MENU_ROOT_BACK_BUTTON_DISABLED/ENABLED</param>
        public static void LvMenuSetModeRootBackButton(global::lvgl.LvObjT obj, byte mode)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvMenuSetModeRootBackButton(__arg0, mode);
        }

        /// <summary>Add menu to the menu item</summary>
        /// <param name="menu">pointer to the menu</param>
        /// <param name="obj">pointer to the obj</param>
        /// <param name="page">pointer to the page to load when obj is clicked</param>
        public static void LvMenuSetLoadPageEvent(global::lvgl.LvObjT menu, global::lvgl.LvObjT obj, global::lvgl.LvObjT page)
        {
            var __arg0 = menu is null ? __IntPtr.Zero : menu.__Instance;
            var __arg1 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg2 = page is null ? __IntPtr.Zero : page.__Instance;
            __Internal.LvMenuSetLoadPageEvent(__arg0, __arg1, __arg2);
        }

        /// <summary>Get a pointer to menu page that is currently displayed in main</summary>
        /// <param name="obj">pointer to the menu</param>
        /// <returns>pointer to current page</returns>
        public static global::lvgl.LvObjT LvMenuGetCurMainPage(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvMenuGetCurMainPage(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get a pointer to menu page that is currently displayed in sidebar</summary>
        /// <param name="obj">pointer to the menu</param>
        /// <returns>pointer to current page</returns>
        public static global::lvgl.LvObjT LvMenuGetCurSidebarPage(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvMenuGetCurSidebarPage(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get a pointer to main header obj</summary>
        /// <param name="obj">pointer to the menu</param>
        /// <returns>pointer to main header obj</returns>
        public static global::lvgl.LvObjT LvMenuGetMainHeader(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvMenuGetMainHeader(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get a pointer to main header back btn obj</summary>
        /// <param name="obj">pointer to the menu</param>
        /// <returns>pointer to main header back btn obj</returns>
        public static global::lvgl.LvObjT LvMenuGetMainHeaderBackButton(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvMenuGetMainHeaderBackButton(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get a pointer to sidebar header obj</summary>
        /// <param name="obj">pointer to the menu</param>
        /// <returns>pointer to sidebar header obj</returns>
        public static global::lvgl.LvObjT LvMenuGetSidebarHeader(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvMenuGetSidebarHeader(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get a pointer to sidebar header obj</summary>
        /// <param name="obj">pointer to the menu</param>
        /// <returns>pointer to sidebar header back btn obj</returns>
        public static global::lvgl.LvObjT LvMenuGetSidebarHeaderBackButton(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvMenuGetSidebarHeaderBackButton(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Check if an obj is a root back btn</summary>
        /// <param name="menu">pointer to the menu</param>
        /// <param name="obj">pointer to the back button</param>
        /// <returns>true if it is a root back btn</returns>
        public static bool LvMenuBackButtonIsRoot(global::lvgl.LvObjT menu, global::lvgl.LvObjT obj)
        {
            var __arg0 = menu is null ? __IntPtr.Zero : menu.__Instance;
            var __arg1 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvMenuBackButtonIsRoot(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Clear menu history</summary>
        /// <param name="obj">pointer to the menu</param>
        public static void LvMenuClearHistory(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvMenuClearHistory(__arg0);
        }

        public static global::lvgl.LvObjClassT LvMenuClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_menu_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvMenuPageClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_menu_page_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvMenuContClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_menu_cont_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvMenuSectionClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_menu_section_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvMenuSeparatorClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_menu_separator_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvMenuSidebarContClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_menu_sidebar_cont_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvMenuMainContClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_menu_main_cont_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvMenuSidebarHeaderContClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_menu_sidebar_header_cont_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvMenuMainHeaderContClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_menu_main_header_cont_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvMsgboxT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 96)]
        public partial struct __Internal
        {
            internal global::lvgl.LvObjT.__Internal obj;
            internal __IntPtr header;
            internal __IntPtr content;
            internal __IntPtr footer;
            internal __IntPtr title;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_msgbox_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvMsgboxT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvMsgboxT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvMsgboxT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvMsgboxT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvMsgboxT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvMsgboxT(native.ToPointer(), skipVTables);
        }

        internal static LvMsgboxT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvMsgboxT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvMsgboxT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvMsgboxT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvMsgboxT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvMsgboxT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvMsgboxT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvMsgboxT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvMsgboxT(global::lvgl.LvMsgboxT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvMsgboxT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvMsgboxT.__Internal*) __Instance) = *((global::lvgl.LvMsgboxT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvObjT Header
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->header, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->header = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjT Content
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->content, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->content = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjT Footer
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->footer, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->footer = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjT Title
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->title, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->title = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class lv_msgbox
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_msgbox_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMsgboxCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_msgbox_add_title", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMsgboxAddTitle(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string title);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_msgbox_add_header_button", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMsgboxAddHeaderButton(__IntPtr obj, __IntPtr icon);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_msgbox_add_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMsgboxAddText(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_msgbox_add_footer_button", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMsgboxAddFooterButton(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_msgbox_add_close_button", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMsgboxAddCloseButton(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_msgbox_get_header", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMsgboxGetHeader(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_msgbox_get_footer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMsgboxGetFooter(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_msgbox_get_content", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMsgboxGetContent(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_msgbox_get_title", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvMsgboxGetTitle(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_msgbox_close", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvMsgboxClose(__IntPtr mbox);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_msgbox_close_async", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvMsgboxCloseAsync(__IntPtr mbox);
        }

        /// <summary>Create an empty message box</summary>
        /// <param name="parent">the parent of the message box</param>
        /// <returns>the created message box</returns>
        public static global::lvgl.LvObjT LvMsgboxCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvMsgboxCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Add title to the message box. It also creates a header for the title.</summary>
        /// <param name="obj">pointer to a message box</param>
        /// <param name="title">the text of the tile</param>
        /// <returns>the created title label</returns>
        public static global::lvgl.LvObjT LvMsgboxAddTitle(global::lvgl.LvObjT obj, string title)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvMsgboxAddTitle(__arg0, title);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Add a button to the header of to the message box. It also creates a header.</summary>
        /// <param name="obj">pointer to a message box</param>
        /// <param name="icon">the icon of the button</param>
        /// <returns>the created button</returns>
        public static global::lvgl.LvObjT LvMsgboxAddHeaderButton(global::lvgl.LvObjT obj, __IntPtr icon)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvMsgboxAddHeaderButton(__arg0, icon);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Add a text to the content area of message box. Multiply texts will be created below each other.</summary>
        /// <param name="obj">pointer to a message box</param>
        /// <param name="icon">the icon of the button</param>
        /// <returns>the created button</returns>
        public static global::lvgl.LvObjT LvMsgboxAddText(global::lvgl.LvObjT obj, string text)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvMsgboxAddText(__arg0, text);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Add a button to the footer of to the message box. It also creates a footer.</summary>
        /// <param name="obj">pointer to a message box</param>
        /// <param name="text">the text of the button</param>
        /// <returns>the created button</returns>
        public static global::lvgl.LvObjT LvMsgboxAddFooterButton(global::lvgl.LvObjT obj, string text)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvMsgboxAddFooterButton(__arg0, text);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Add a close button to the message box. It also create a header.</summary>
        /// <param name="obj">pointer to a message box</param>
        /// <returns>the created close button</returns>
        public static global::lvgl.LvObjT LvMsgboxAddCloseButton(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvMsgboxAddCloseButton(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the header widget</summary>
        /// <param name="obj">pointer to a message box</param>
        /// <returns>the header, or NULL if not exists</returns>
        public static global::lvgl.LvObjT LvMsgboxGetHeader(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvMsgboxGetHeader(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the footer widget</summary>
        /// <param name="obj">pointer to a message box</param>
        /// <returns>the footer, or NULL if not exists</returns>
        public static global::lvgl.LvObjT LvMsgboxGetFooter(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvMsgboxGetFooter(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the content widget</summary>
        /// <param name="obj">pointer to a message box</param>
        /// <returns>the content, or NULL if not exists</returns>
        public static global::lvgl.LvObjT LvMsgboxGetContent(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvMsgboxGetContent(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the title label</summary>
        /// <param name="obj">pointer to a message box</param>
        /// <returns>the title, or NULL if not exists</returns>
        public static global::lvgl.LvObjT LvMsgboxGetTitle(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvMsgboxGetTitle(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Close a message box</summary>
        /// <param name="obj">pointer to a message box</param>
        public static void LvMsgboxClose(global::lvgl.LvObjT mbox)
        {
            var __arg0 = mbox is null ? __IntPtr.Zero : mbox.__Instance;
            __Internal.LvMsgboxClose(__arg0);
        }

        /// <summary>Close a message box in the next call of the message box</summary>
        /// <param name="obj">pointer to a message box</param>
        public static void LvMsgboxCloseAsync(global::lvgl.LvObjT mbox)
        {
            var __arg0 = mbox is null ? __IntPtr.Zero : mbox.__Instance;
            __Internal.LvMsgboxCloseAsync(__arg0);
        }

        public static global::lvgl.LvObjClassT LvMsgboxClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_msgbox_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvMsgboxHeaderClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_msgbox_header_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvMsgboxContentClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_msgbox_content_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvMsgboxFooterClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_msgbox_footer_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvMsgboxHeaderButtonClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_msgbox_header_button_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvMsgboxFooterButtonClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_msgbox_footer_button_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvMsgboxBackdropClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_msgbox_backdrop_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>Roller mode.</summary>
    public enum LvRollerModeT
    {
        /// <summary>Normal mode (roller ends at the end of the options).</summary>
        LV_ROLLER_MODE_NORMAL = 0,
        /// <summary>Infinite mode (roller can be scrolled forever).</summary>
        LV_ROLLER_MODE_INFINITE = 1
    }

    public unsafe partial class LvRollerT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 88)]
        public partial struct __Internal
        {
            internal global::lvgl.LvObjT.__Internal obj;
            internal uint option_cnt;
            internal uint sel_opt_id;
            internal uint sel_opt_id_ori;
            internal uint inf_page_cnt;
            internal byte mode;
            internal uint moved;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_roller_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvRollerT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvRollerT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvRollerT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvRollerT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvRollerT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvRollerT(native.ToPointer(), skipVTables);
        }

        internal static LvRollerT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvRollerT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvRollerT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvRollerT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvRollerT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvRollerT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvRollerT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvRollerT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvRollerT(global::lvgl.LvRollerT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvRollerT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvRollerT.__Internal*) __Instance) = *((global::lvgl.LvRollerT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Number of options</summary>
        public uint OptionCnt
        {
            get
            {
                return ((__Internal*)__Instance)->option_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->option_cnt = value;
            }
        }

        /// <summary>Index of the current option</summary>
        public uint SelOptId
        {
            get
            {
                return ((__Internal*)__Instance)->sel_opt_id;
            }

            set
            {
                ((__Internal*)__Instance)->sel_opt_id = value;
            }
        }

        /// <summary>Store the original index on focus</summary>
        public uint SelOptIdOri
        {
            get
            {
                return ((__Internal*)__Instance)->sel_opt_id_ori;
            }

            set
            {
                ((__Internal*)__Instance)->sel_opt_id_ori = value;
            }
        }

        /// <summary>Number of extra pages added to make the roller look infinite</summary>
        public uint InfPageCnt
        {
            get
            {
                return ((__Internal*)__Instance)->inf_page_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->inf_page_cnt = value;
            }
        }

        public byte Mode
        {
            get
            {
                return ((__Internal*)__Instance)->mode;
            }

            set
            {
                ((__Internal*)__Instance)->mode = value;
            }
        }

        public uint Moved
        {
            get
            {
                return ((__Internal*)__Instance)->moved;
            }

            set
            {
                ((__Internal*)__Instance)->moved = value;
            }
        }
    }

    public unsafe partial class lv_roller
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_roller_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvRollerCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_roller_set_options", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvRollerSetOptions(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string options, byte mode);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_roller_set_selected", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvRollerSetSelected(__IntPtr obj, uint sel_opt, global::lvgl.LvAnimEnableT anim);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_roller_set_visible_row_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvRollerSetVisibleRowCount(__IntPtr obj, uint row_cnt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_roller_get_selected", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvRollerGetSelected(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_roller_get_selected_str", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvRollerGetSelectedStr(__IntPtr obj, sbyte* buf, uint buf_size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_roller_get_options", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvRollerGetOptions(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_roller_get_option_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvRollerGetOptionCount(__IntPtr obj);
        }

        /// <summary>Create a roller object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new roller.</param>
        /// <returns>pointer to the created roller</returns>
        public static global::lvgl.LvObjT LvRollerCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvRollerCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the options on a roller</summary>
        /// <param name="obj">pointer to roller object</param>
        /// <param name="options">a string with '' separated options. E.g. &quot;One\nTwo\nThree&quot;</param>
        /// <param name="mode">`LV_ROLLER_MODE_NORMAL` or `LV_ROLLER_MODE_INFINITE`</param>
        public static void LvRollerSetOptions(global::lvgl.LvObjT obj, string options, byte mode)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvRollerSetOptions(__arg0, options, mode);
        }

        /// <summary>Set the selected option</summary>
        /// <param name="obj">pointer to a roller object</param>
        /// <param name="sel_opt">index of the selected option (0 ... number of option - 1);</param>
        /// <param name="anim">LV_ANIM_ON: set with animation; LV_ANOM_OFF set immediately</param>
        public static void LvRollerSetSelected(global::lvgl.LvObjT obj, uint sel_opt, global::lvgl.LvAnimEnableT anim)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvRollerSetSelected(__arg0, sel_opt, anim);
        }

        /// <summary>Set the height to show the given number of rows (options)</summary>
        /// <param name="obj">pointer to a roller object</param>
        /// <param name="row_cnt">number of desired visible rows</param>
        public static void LvRollerSetVisibleRowCount(global::lvgl.LvObjT obj, uint row_cnt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvRollerSetVisibleRowCount(__arg0, row_cnt);
        }

        /// <summary>Get the index of the selected option</summary>
        /// <param name="obj">pointer to a roller object</param>
        /// <returns>index of the selected option (0 ... number of option - 1);</returns>
        public static uint LvRollerGetSelected(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvRollerGetSelected(__arg0);
            return ___ret;
        }

        /// <summary>Get the current selected option as a string.</summary>
        /// <param name="obj">pointer to ddlist object</param>
        /// <param name="buf">pointer to an array to store the string</param>
        /// <param name="buf_size">size of `buf` in bytes. 0: to ignore it.</param>
        public static void LvRollerGetSelectedStr(global::lvgl.LvObjT obj, sbyte* buf, uint buf_size)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvRollerGetSelectedStr(__arg0, buf, buf_size);
        }

        /// <summary>Get the options of a roller</summary>
        /// <param name="obj">pointer to roller object</param>
        /// <returns>the options separated by ''-s (E.g. &quot;Option1\nOption2\nOption3&quot;)</returns>
        public static string LvRollerGetOptions(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvRollerGetOptions(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the total number of options</summary>
        /// <param name="obj">pointer to a roller object</param>
        /// <returns>the total number of options</returns>
        public static uint LvRollerGetOptionCount(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvRollerGetOptionCount(__arg0);
            return ___ret;
        }

        public static global::lvgl.LvObjClassT LvRollerClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_roller_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    public unsafe partial class LvScaleSectionT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal __IntPtr main_style;
            internal __IntPtr indicator_style;
            internal __IntPtr items_style;
            internal int minor_range;
            internal int major_range;
            internal uint first_tick_idx_in_section;
            internal uint last_tick_idx_in_section;
            internal uint first_tick_idx_is_major;
            internal uint last_tick_idx_is_major;
            internal int first_tick_in_section_width;
            internal int last_tick_in_section_width;
            internal global::lvgl.LvPointT.__Internal first_tick_in_section;
            internal global::lvgl.LvPointT.__Internal last_tick_in_section;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_scale_section_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvScaleSectionT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvScaleSectionT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvScaleSectionT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvScaleSectionT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvScaleSectionT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvScaleSectionT(native.ToPointer(), skipVTables);
        }

        internal static LvScaleSectionT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvScaleSectionT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvScaleSectionT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvScaleSectionT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvScaleSectionT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvScaleSectionT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvScaleSectionT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvScaleSectionT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvScaleSectionT(global::lvgl.LvScaleSectionT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvScaleSectionT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvScaleSectionT.__Internal*) __Instance) = *((global::lvgl.LvScaleSectionT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvStyleT MainStyle
        {
            get
            {
                var __result0 = global::lvgl.LvStyleT.__GetOrCreateInstance(((__Internal*)__Instance)->main_style, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->main_style = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvStyleT IndicatorStyle
        {
            get
            {
                var __result0 = global::lvgl.LvStyleT.__GetOrCreateInstance(((__Internal*)__Instance)->indicator_style, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->indicator_style = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvStyleT ItemsStyle
        {
            get
            {
                var __result0 = global::lvgl.LvStyleT.__GetOrCreateInstance(((__Internal*)__Instance)->items_style, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->items_style = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public int MinorRange
        {
            get
            {
                return ((__Internal*)__Instance)->minor_range;
            }

            set
            {
                ((__Internal*)__Instance)->minor_range = value;
            }
        }

        public int MajorRange
        {
            get
            {
                return ((__Internal*)__Instance)->major_range;
            }

            set
            {
                ((__Internal*)__Instance)->major_range = value;
            }
        }

        public uint FirstTickIdxInSection
        {
            get
            {
                return ((__Internal*)__Instance)->first_tick_idx_in_section;
            }

            set
            {
                ((__Internal*)__Instance)->first_tick_idx_in_section = value;
            }
        }

        public uint LastTickIdxInSection
        {
            get
            {
                return ((__Internal*)__Instance)->last_tick_idx_in_section;
            }

            set
            {
                ((__Internal*)__Instance)->last_tick_idx_in_section = value;
            }
        }

        public uint FirstTickIdxIsMajor
        {
            get
            {
                return ((__Internal*)__Instance)->first_tick_idx_is_major;
            }

            set
            {
                ((__Internal*)__Instance)->first_tick_idx_is_major = value;
            }
        }

        public uint LastTickIdxIsMajor
        {
            get
            {
                return ((__Internal*)__Instance)->last_tick_idx_is_major;
            }

            set
            {
                ((__Internal*)__Instance)->last_tick_idx_is_major = value;
            }
        }

        public int FirstTickInSectionWidth
        {
            get
            {
                return ((__Internal*)__Instance)->first_tick_in_section_width;
            }

            set
            {
                ((__Internal*)__Instance)->first_tick_in_section_width = value;
            }
        }

        public int LastTickInSectionWidth
        {
            get
            {
                return ((__Internal*)__Instance)->last_tick_in_section_width;
            }

            set
            {
                ((__Internal*)__Instance)->last_tick_in_section_width = value;
            }
        }

        public global::lvgl.LvPointT FirstTickInSection
        {
            get
            {
                return global::lvgl.LvPointT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->first_tick_in_section));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->first_tick_in_section = *(global::lvgl.LvPointT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvPointT LastTickInSection
        {
            get
            {
                return global::lvgl.LvPointT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->last_tick_in_section));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->last_tick_in_section = *(global::lvgl.LvPointT.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class LvScaleT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 136)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvObjT.__Internal obj;

            [FieldOffset(64)]
            internal global::lvgl.LvLlT.__Internal section_ll;

            [FieldOffset(88)]
            internal __IntPtr txt_src;

            [FieldOffset(96)]
            internal uint mode;

            [FieldOffset(100)]
            internal int range_min;

            [FieldOffset(104)]
            internal int range_max;

            [FieldOffset(108)]
            internal uint total_tick_count;

            [FieldOffset(109)]
            internal uint major_tick_every;

            [FieldOffset(111)]
            internal uint label_enabled;

            [FieldOffset(111)]
            internal uint post_draw;

            [FieldOffset(112)]
            internal uint angle_range;

            [FieldOffset(116)]
            internal int rotation;

            [FieldOffset(120)]
            internal int custom_label_cnt;

            [FieldOffset(124)]
            internal int last_tick_width;

            [FieldOffset(128)]
            internal int first_tick_width;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_scale_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvScaleT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvScaleT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvScaleT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvScaleT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvScaleT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvScaleT(native.ToPointer(), skipVTables);
        }

        internal static LvScaleT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvScaleT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvScaleT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvScaleT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvScaleT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvScaleT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvScaleT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvScaleT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvScaleT(global::lvgl.LvScaleT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvScaleT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvScaleT.__Internal*) __Instance) = *((global::lvgl.LvScaleT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        /// <summary>Linked list for the sections (stores lv_scale_section_t)</summary>
        public global::lvgl.LvLlT SectionLl
        {
            get
            {
                return global::lvgl.LvLlT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->section_ll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->section_ll = *(global::lvgl.LvLlT.__Internal*) value.__Instance;
            }
        }

        public uint Mode
        {
            get
            {
                return ((__Internal*)__Instance)->mode;
            }

            set
            {
                ((__Internal*)__Instance)->mode = value;
            }
        }

        public int RangeMin
        {
            get
            {
                return ((__Internal*)__Instance)->range_min;
            }

            set
            {
                ((__Internal*)__Instance)->range_min = value;
            }
        }

        public int RangeMax
        {
            get
            {
                return ((__Internal*)__Instance)->range_max;
            }

            set
            {
                ((__Internal*)__Instance)->range_max = value;
            }
        }

        public uint TotalTickCount
        {
            get
            {
                return ((__Internal*)__Instance)->total_tick_count;
            }

            set
            {
                ((__Internal*)__Instance)->total_tick_count = value;
            }
        }

        public uint MajorTickEvery
        {
            get
            {
                return ((__Internal*)__Instance)->major_tick_every;
            }

            set
            {
                ((__Internal*)__Instance)->major_tick_every = value;
            }
        }

        public uint LabelEnabled
        {
            get
            {
                return ((__Internal*)__Instance)->label_enabled;
            }

            set
            {
                ((__Internal*)__Instance)->label_enabled = value;
            }
        }

        public uint PostDraw
        {
            get
            {
                return ((__Internal*)__Instance)->post_draw;
            }

            set
            {
                ((__Internal*)__Instance)->post_draw = value;
            }
        }

        public uint AngleRange
        {
            get
            {
                return ((__Internal*)__Instance)->angle_range;
            }

            set
            {
                ((__Internal*)__Instance)->angle_range = value;
            }
        }

        public int Rotation
        {
            get
            {
                return ((__Internal*)__Instance)->rotation;
            }

            set
            {
                ((__Internal*)__Instance)->rotation = value;
            }
        }

        public int CustomLabelCnt
        {
            get
            {
                return ((__Internal*)__Instance)->custom_label_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->custom_label_cnt = value;
            }
        }

        public int LastTickWidth
        {
            get
            {
                return ((__Internal*)__Instance)->last_tick_width;
            }

            set
            {
                ((__Internal*)__Instance)->last_tick_width = value;
            }
        }

        public int FirstTickWidth
        {
            get
            {
                return ((__Internal*)__Instance)->first_tick_width;
            }

            set
            {
                ((__Internal*)__Instance)->first_tick_width = value;
            }
        }
    }

    public unsafe partial class lv_scale
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvScaleCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_set_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvScaleSetMode(__IntPtr obj, uint mode);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_set_total_tick_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvScaleSetTotalTickCount(__IntPtr obj, uint total_tick_count);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_set_major_tick_every", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvScaleSetMajorTickEvery(__IntPtr obj, uint major_tick_every);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_set_label_show", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvScaleSetLabelShow(__IntPtr obj, bool show_label);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_set_range", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvScaleSetRange(__IntPtr obj, int min, int max);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_set_angle_range", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvScaleSetAngleRange(__IntPtr obj, uint angle_range);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_set_rotation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvScaleSetRotation(__IntPtr obj, int rotation);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_set_line_needle_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvScaleSetLineNeedleValue(__IntPtr obj, __IntPtr needle_line, int needle_length, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_set_image_needle_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvScaleSetImageNeedleValue(__IntPtr obj, __IntPtr needle_img, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_set_text_src", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvScaleSetTextSrc(__IntPtr obj, [MarshalAs(UnmanagedType.LPArray)] string[] txt_src);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_set_post_draw", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvScaleSetPostDraw(__IntPtr obj, bool en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_add_section", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvScaleAddSection(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_section_set_range", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvScaleSectionSetRange(__IntPtr section, int minor_range, int major_range);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_section_set_style", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvScaleSectionSetStyle(__IntPtr section, uint part, __IntPtr section_part_style);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_get_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvScaleGetMode(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_get_total_tick_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvScaleGetTotalTickCount(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_get_major_tick_every", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvScaleGetMajorTickEvery(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_get_label_show", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvScaleGetLabelShow(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_get_angle_range", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvScaleGetAngleRange(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_get_range_min_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvScaleGetRangeMinValue(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_scale_get_range_max_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvScaleGetRangeMaxValue(__IntPtr obj);
        }

        /// <summary>Create an scale object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new scale</param>
        /// <returns>pointer to the created scale</returns>
        public static global::lvgl.LvObjT LvScaleCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvScaleCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set scale mode. See</summary>
        /// <param name="obj">pointer the scale object</param>
        /// <param name="mode">the new scale mode</param>
        public static void LvScaleSetMode(global::lvgl.LvObjT obj, uint mode)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvScaleSetMode(__arg0, mode);
        }

        /// <summary>Set scale total tick count (including minor and major ticks)</summary>
        /// <param name="obj">pointer the scale object</param>
        /// <param name="total_tick_count">New total tick count</param>
        public static void LvScaleSetTotalTickCount(global::lvgl.LvObjT obj, uint total_tick_count)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvScaleSetTotalTickCount(__arg0, total_tick_count);
        }

        /// <summary>Sets how often the major tick will be drawn</summary>
        /// <param name="obj">pointer the scale object</param>
        /// <param name="major_tick_every">the new count for major tick drawing</param>
        public static void LvScaleSetMajorTickEvery(global::lvgl.LvObjT obj, uint major_tick_every)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvScaleSetMajorTickEvery(__arg0, major_tick_every);
        }

        /// <summary>Sets label visibility</summary>
        /// <param name="obj">pointer the scale object</param>
        /// <param name="show_label">true/false to enable tick label</param>
        public static void LvScaleSetLabelShow(global::lvgl.LvObjT obj, bool show_label)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvScaleSetLabelShow(__arg0, show_label);
        }

        /// <summary>Set the minimal and maximal values on a scale</summary>
        /// <param name="obj">pointer to a scale object</param>
        /// <param name="min">minimum value of the scale</param>
        /// <param name="max">maximum value of the scale</param>
        public static void LvScaleSetRange(global::lvgl.LvObjT obj, int min, int max)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvScaleSetRange(__arg0, min, max);
        }

        /// <summary>Set properties specific to round scale</summary>
        /// <param name="obj">pointer to a scale object</param>
        /// <param name="angle_range">the angular range of the scale</param>
        public static void LvScaleSetAngleRange(global::lvgl.LvObjT obj, uint angle_range)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvScaleSetAngleRange(__arg0, angle_range);
        }

        /// <summary>Set properties specific to round scale</summary>
        /// <param name="obj">pointer to a scale object</param>
        /// <param name="rotation">the angular offset from the 3 o'clock position (clock-wise)</param>
        public static void LvScaleSetRotation(global::lvgl.LvObjT obj, int rotation)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvScaleSetRotation(__arg0, rotation);
        }

        /// <summary>Point the needle to the corresponding value through the line</summary>
        /// <param name="obj">pointer to a scale object</param>
        /// <param name="needle_line">
        /// <para>needle_line of the scale. The line points will be allocated and</para>
        /// <para>managed by the scale unless the line point array was previously set</para>
        /// <para>using `lv_line_set_points_mutable`.</para>
        /// </param>
        /// <param name="needle_length">
        /// <para>length of the needle</para>
        /// <para>needle_length&gt;0 needle_length=needle_length;</para>
        /// <para>needle_length&lt;0 needle_length=radius-|needle_length|;</para>
        /// </param>
        /// <param name="value">needle to point to the corresponding value</param>
        public static void LvScaleSetLineNeedleValue(global::lvgl.LvObjT obj, global::lvgl.LvObjT needle_line, int needle_length, int value)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = needle_line is null ? __IntPtr.Zero : needle_line.__Instance;
            __Internal.LvScaleSetLineNeedleValue(__arg0, __arg1, needle_length, value);
        }

        /// <summary>
        /// <para>Point the needle to the corresponding value through the image,</para>
        /// <para>image must point to the right. E.g. -O------&gt;</para>
        /// </summary>
        /// <param name="obj">pointer to a scale object</param>
        /// <param name="needle_img">needle_img of the scale</param>
        /// <param name="value">needle to point to the corresponding value</param>
        public static void LvScaleSetImageNeedleValue(global::lvgl.LvObjT obj, global::lvgl.LvObjT needle_img, int value)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = needle_img is null ? __IntPtr.Zero : needle_img.__Instance;
            __Internal.LvScaleSetImageNeedleValue(__arg0, __arg1, value);
        }

        /// <summary>Set custom text source for major ticks labels</summary>
        /// <param name="obj">pointer to a scale object</param>
        /// <param name="txt_src">pointer to an array of strings which will be display at major ticks</param>
        public static void LvScaleSetTextSrc(global::lvgl.LvObjT obj, string[] txt_src)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvScaleSetTextSrc(__arg0, txt_src);
        }

        /// <summary>Draw the scale after all the children are drawn</summary>
        /// <param name="obj">pointer to a scale object</param>
        /// <param name="en">true: enable post draw</param>
        public static void LvScaleSetPostDraw(global::lvgl.LvObjT obj, bool en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvScaleSetPostDraw(__arg0, en);
        }

        /// <summary>Add a section to the given scale</summary>
        /// <param name="obj">pointer to a scale object</param>
        /// <returns>pointer to the new section</returns>
        public static global::lvgl.LvScaleSectionT LvScaleAddSection(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvScaleAddSection(__arg0);
            var __result0 = global::lvgl.LvScaleSectionT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the range for the given scale section</summary>
        /// <param name="section">pointer to a scale section object</param>
        /// <param name="minor_range">section new minor range</param>
        /// <param name="major_range">section new major range</param>
        public static void LvScaleSectionSetRange(global::lvgl.LvScaleSectionT section, int minor_range, int major_range)
        {
            var __arg0 = section is null ? __IntPtr.Zero : section.__Instance;
            __Internal.LvScaleSectionSetRange(__arg0, minor_range, major_range);
        }

        /// <summary>Set the style of the part for the given scale section</summary>
        /// <param name="section">pointer to a scale section object</param>
        /// <param name="part">the part for the section, e.g. LV_PART_INDICATOR</param>
        /// <param name="section_part_style">Pointer to the section part style</param>
        public static void LvScaleSectionSetStyle(global::lvgl.LvScaleSectionT section, uint part, global::lvgl.LvStyleT section_part_style)
        {
            var __arg0 = section is null ? __IntPtr.Zero : section.__Instance;
            var __arg2 = section_part_style is null ? __IntPtr.Zero : section_part_style.__Instance;
            __Internal.LvScaleSectionSetStyle(__arg0, part, __arg2);
        }

        /// <summary>Get scale mode. See</summary>
        /// <param name="obj">pointer the scale object</param>
        /// <returns>Scale mode</returns>
        public static uint LvScaleGetMode(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvScaleGetMode(__arg0);
            return ___ret;
        }

        /// <summary>Get scale total tick count (including minor and major ticks)</summary>
        /// <param name="obj">pointer the scale object</param>
        /// <returns>Scale total tick count</returns>
        public static int LvScaleGetTotalTickCount(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvScaleGetTotalTickCount(__arg0);
            return ___ret;
        }

        /// <summary>Gets how often the major tick will be drawn</summary>
        /// <param name="obj">pointer the scale object</param>
        /// <returns>Scale major tick every count</returns>
        public static int LvScaleGetMajorTickEvery(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvScaleGetMajorTickEvery(__arg0);
            return ___ret;
        }

        /// <summary>Gets label visibility</summary>
        /// <param name="obj">pointer the scale object</param>
        /// <returns>true if tick label is enabled, false otherwise</returns>
        public static bool LvScaleGetLabelShow(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvScaleGetLabelShow(__arg0);
            return ___ret;
        }

        /// <summary>Get angle range of a round scale</summary>
        /// <param name="obj">pointer to a scale object</param>
        /// <returns>Scale angle_range</returns>
        public static uint LvScaleGetAngleRange(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvScaleGetAngleRange(__arg0);
            return ___ret;
        }

        /// <summary>Get the min range for the given scale section</summary>
        /// <param name="obj">pointer to a scale section object</param>
        /// <returns>section minor range</returns>
        public static int LvScaleGetRangeMinValue(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvScaleGetRangeMinValue(__arg0);
            return ___ret;
        }

        /// <summary>Get the max range for the given scale section</summary>
        /// <param name="obj">pointer to a scale section object</param>
        /// <returns>section max range</returns>
        public static int LvScaleGetRangeMaxValue(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvScaleGetRangeMaxValue(__arg0);
            return ___ret;
        }

        public static global::lvgl.LvObjClassT LvScaleClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_scale_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public enum LvSliderModeT
    {
        LV_SLIDER_MODE_NORMAL = 0,
        LV_SLIDER_MODE_SYMMETRICAL = 1,
        LV_SLIDER_MODE_RANGE = 2
    }

    public unsafe partial class LvSliderT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 216)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvBarT.__Internal bar;

            [FieldOffset(160)]
            internal global::lvgl.LvAreaT.__Internal left_knob_area;

            [FieldOffset(176)]
            internal global::lvgl.LvAreaT.__Internal right_knob_area;

            [FieldOffset(192)]
            internal global::lvgl.LvPointT.__Internal pressed_point;

            [FieldOffset(200)]
            internal __IntPtr value_to_set;

            [FieldOffset(208)]
            internal byte dragging;

            [FieldOffset(208)]
            internal byte left_knob_focus;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_slider_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvSliderT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvSliderT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvSliderT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvSliderT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvSliderT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvSliderT(native.ToPointer(), skipVTables);
        }

        internal static LvSliderT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvSliderT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvSliderT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvSliderT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvSliderT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvSliderT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvSliderT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvSliderT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvSliderT(global::lvgl.LvSliderT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvSliderT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvSliderT.__Internal*) __Instance) = *((global::lvgl.LvSliderT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvBarT Bar
        {
            get
            {
                return global::lvgl.LvBarT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->bar));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->bar = *(global::lvgl.LvBarT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvAreaT LeftKnobArea
        {
            get
            {
                return global::lvgl.LvAreaT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->left_knob_area));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->left_knob_area = *(global::lvgl.LvAreaT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvAreaT RightKnobArea
        {
            get
            {
                return global::lvgl.LvAreaT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->right_knob_area));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->right_knob_area = *(global::lvgl.LvAreaT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvPointT PressedPoint
        {
            get
            {
                return global::lvgl.LvPointT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->pressed_point));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->pressed_point = *(global::lvgl.LvPointT.__Internal*) value.__Instance;
            }
        }

        public int* ValueToSet
        {
            get
            {
                return (int*) ((__Internal*)__Instance)->value_to_set;
            }

            set
            {
                ((__Internal*)__Instance)->value_to_set = (__IntPtr) value;
            }
        }

        public byte Dragging
        {
            get
            {
                return ((__Internal*)__Instance)->dragging;
            }

            set
            {
                ((__Internal*)__Instance)->dragging = value;
            }
        }

        public byte LeftKnobFocus
        {
            get
            {
                return ((__Internal*)__Instance)->left_knob_focus;
            }

            set
            {
                ((__Internal*)__Instance)->left_knob_focus = value;
            }
        }
    }

    public unsafe partial class lv_slider
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_slider_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvSliderCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_slider_is_dragged", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvSliderIsDragged(__IntPtr obj);
        }

        /// <summary>Create a slider object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new slider.</param>
        /// <returns>pointer to the created slider</returns>
        public static global::lvgl.LvObjT LvSliderCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvSliderCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Give the slider is being dragged or not</summary>
        /// <param name="obj">pointer to a slider object</param>
        /// <returns>true: drag in progress false: not dragged</returns>
        public static bool LvSliderIsDragged(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvSliderIsDragged(__arg0);
            return ___ret;
        }

        public static global::lvgl.LvObjClassT LvSliderClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_slider_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public enum LvSpanOverflowT
    {
        LV_SPAN_OVERFLOW_CLIP = 0,
        LV_SPAN_OVERFLOW_ELLIPSIS = 1,
        /// <summary>Fence member</summary>
        LV_SPAN_OVERFLOW_LAST = 2
    }

    public enum LvSpanModeT
    {
        /// <summary>fixed the obj size</summary>
        LV_SPAN_MODE_FIXED = 0,
        /// <summary>Expand the object size to the text size</summary>
        LV_SPAN_MODE_EXPAND = 1,
        /// <summary>Keep width, break the too long lines and expand height</summary>
        LV_SPAN_MODE_BREAK = 2,
        /// <summary>Fence member</summary>
        LV_SPAN_MODE_LAST = 3
    }

    /// <summary>Data of label</summary>
    /// <summary>Data of label</summary>
    public unsafe partial class LvSpangroupT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvObjT.__Internal obj;

            [FieldOffset(64)]
            internal int lines;

            [FieldOffset(68)]
            internal int indent;

            [FieldOffset(72)]
            internal int cache_w;

            [FieldOffset(76)]
            internal int cache_h;

            [FieldOffset(80)]
            internal global::lvgl.LvLlT.__Internal child_ll;

            [FieldOffset(104)]
            internal uint mode;

            [FieldOffset(104)]
            internal uint overflow;

            [FieldOffset(104)]
            internal uint refresh;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_spangroup_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvSpangroupT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvSpangroupT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvSpangroupT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvSpangroupT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvSpangroupT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvSpangroupT(native.ToPointer(), skipVTables);
        }

        internal static LvSpangroupT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvSpangroupT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvSpangroupT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvSpangroupT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvSpangroupT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvSpangroupT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvSpangroupT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvSpangroupT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvSpangroupT(global::lvgl.LvSpangroupT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvSpangroupT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvSpangroupT.__Internal*) __Instance) = *((global::lvgl.LvSpangroupT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        public int Lines
        {
            get
            {
                return ((__Internal*)__Instance)->lines;
            }

            set
            {
                ((__Internal*)__Instance)->lines = value;
            }
        }

        public int Indent
        {
            get
            {
                return ((__Internal*)__Instance)->indent;
            }

            set
            {
                ((__Internal*)__Instance)->indent = value;
            }
        }

        public int CacheW
        {
            get
            {
                return ((__Internal*)__Instance)->cache_w;
            }

            set
            {
                ((__Internal*)__Instance)->cache_w = value;
            }
        }

        public int CacheH
        {
            get
            {
                return ((__Internal*)__Instance)->cache_h;
            }

            set
            {
                ((__Internal*)__Instance)->cache_h = value;
            }
        }

        public global::lvgl.LvLlT ChildLl
        {
            get
            {
                return global::lvgl.LvLlT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->child_ll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->child_ll = *(global::lvgl.LvLlT.__Internal*) value.__Instance;
            }
        }

        public uint Mode
        {
            get
            {
                return ((__Internal*)__Instance)->mode;
            }

            set
            {
                ((__Internal*)__Instance)->mode = value;
            }
        }

        public uint Overflow
        {
            get
            {
                return ((__Internal*)__Instance)->overflow;
            }

            set
            {
                ((__Internal*)__Instance)->overflow = value;
            }
        }

        public uint Refresh
        {
            get
            {
                return ((__Internal*)__Instance)->refresh;
            }

            set
            {
                ((__Internal*)__Instance)->refresh = value;
            }
        }
    }

    public unsafe partial class lv_span
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_span_stack_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpanStackInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_span_stack_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpanStackDeinit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spangroup_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvSpangroupCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spangroup_set_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpangroupSetAlign(__IntPtr obj, byte align);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spangroup_set_overflow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpangroupSetOverflow(__IntPtr obj, uint overflow);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spangroup_set_indent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpangroupSetIndent(__IntPtr obj, int indent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spangroup_set_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpangroupSetMode(__IntPtr obj, uint mode);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spangroup_set_max_lines", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpangroupSetMaxLines(__IntPtr obj, int lines);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spangroup_get_span_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvSpangroupGetSpanCount(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spangroup_get_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvSpangroupGetAlign(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spangroup_get_overflow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvSpangroupGetOverflow(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spangroup_get_indent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvSpangroupGetIndent(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spangroup_get_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvSpangroupGetMode(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spangroup_get_max_lines", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvSpangroupGetMaxLines(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spangroup_get_max_line_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvSpangroupGetMaxLineHeight(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spangroup_get_expand_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvSpangroupGetExpandWidth(__IntPtr obj, uint max_width);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spangroup_get_expand_height", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvSpangroupGetExpandHeight(__IntPtr obj, int width);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spangroup_refr_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpangroupRefrMode(__IntPtr obj);
        }

        /// <summary>
        /// <para>********************</para>
        /// <para>GLOBAL PROTOTYPES</para>
        /// <para>********************</para>
        /// </summary>
        public static void LvSpanStackInit()
        {
            __Internal.LvSpanStackInit();
        }

        public static void LvSpanStackDeinit()
        {
            __Internal.LvSpanStackDeinit();
        }

        /// <summary>Create a spangroup object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new spangroup</param>
        /// <returns>pointer to the created spangroup</returns>
        public static global::lvgl.LvObjT LvSpangroupCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvSpangroupCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the align of the spangroup.</summary>
        /// <param name="obj">pointer to a spangroup object.</param>
        /// <param name="align">see lv_text_align_t for details.</param>
        public static void LvSpangroupSetAlign(global::lvgl.LvObjT obj, byte align)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpangroupSetAlign(__arg0, align);
        }

        /// <summary>Set the overflow of the spangroup.</summary>
        /// <param name="obj">pointer to a spangroup object.</param>
        /// <param name="overflow">see lv_span_overflow_t for details.</param>
        public static void LvSpangroupSetOverflow(global::lvgl.LvObjT obj, uint overflow)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpangroupSetOverflow(__arg0, overflow);
        }

        /// <summary>Set the indent of the spangroup.</summary>
        /// <param name="obj">pointer to a spangroup object.</param>
        /// <param name="indent">the first line indentation</param>
        public static void LvSpangroupSetIndent(global::lvgl.LvObjT obj, int indent)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpangroupSetIndent(__arg0, indent);
        }

        /// <summary>Set the mode of the spangroup.</summary>
        /// <param name="obj">pointer to a spangroup object.</param>
        /// <param name="mode">see lv_span_mode_t for details.</param>
        public static void LvSpangroupSetMode(global::lvgl.LvObjT obj, uint mode)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpangroupSetMode(__arg0, mode);
        }

        /// <summary>Set maximum lines of the spangroup.</summary>
        /// <param name="obj">pointer to a spangroup object.</param>
        /// <param name="lines">max lines that can be displayed in LV_SPAN_MODE_BREAK mode.&lt;0 means no limit.</param>
        public static void LvSpangroupSetMaxLines(global::lvgl.LvObjT obj, int lines)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpangroupSetMaxLines(__arg0, lines);
        }

        /// <summary>Get number of spans</summary>
        /// <param name="obj">the spangroup object to get the child count of.</param>
        /// <returns>the span count of the spangroup.</returns>
        public static uint LvSpangroupGetSpanCount(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvSpangroupGetSpanCount(__arg0);
            return ___ret;
        }

        /// <summary>Get the align of the spangroup.</summary>
        /// <param name="obj">pointer to a spangroup object.</param>
        /// <returns>the align value.</returns>
        public static byte LvSpangroupGetAlign(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvSpangroupGetAlign(__arg0);
            return ___ret;
        }

        /// <summary>Get the overflow of the spangroup.</summary>
        /// <param name="obj">pointer to a spangroup object.</param>
        /// <returns>the overflow value.</returns>
        public static uint LvSpangroupGetOverflow(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvSpangroupGetOverflow(__arg0);
            return ___ret;
        }

        /// <summary>Get the indent of the spangroup.</summary>
        /// <param name="obj">pointer to a spangroup object.</param>
        /// <returns>the indent value.</returns>
        public static int LvSpangroupGetIndent(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvSpangroupGetIndent(__arg0);
            return ___ret;
        }

        /// <summary>Get the mode of the spangroup.</summary>
        /// <param name="obj">pointer to a spangroup object.</param>
        public static uint LvSpangroupGetMode(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvSpangroupGetMode(__arg0);
            return ___ret;
        }

        /// <summary>Get maximum lines of the spangroup.</summary>
        /// <param name="obj">pointer to a spangroup object.</param>
        /// <returns>the max lines value.</returns>
        public static int LvSpangroupGetMaxLines(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvSpangroupGetMaxLines(__arg0);
            return ___ret;
        }

        /// <summary>Get max line height of all span in the spangroup.</summary>
        /// <param name="obj">pointer to a spangroup object.</param>
        public static int LvSpangroupGetMaxLineHeight(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvSpangroupGetMaxLineHeight(__arg0);
            return ___ret;
        }

        /// <summary>Get the text content width when all span of spangroup on a line.</summary>
        /// <param name="obj">pointer to a spangroup object.</param>
        /// <param name="max_width">
        /// <para>if text content width &gt;= max_width, return max_width</para>
        /// <para>to reduce computation, if max_width == 0, returns the text content width.</para>
        /// </param>
        /// <returns>text     content width or max_width.</returns>
        public static uint LvSpangroupGetExpandWidth(global::lvgl.LvObjT obj, uint max_width)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvSpangroupGetExpandWidth(__arg0, max_width);
            return ___ret;
        }

        /// <summary>Get the text content height with width fixed.</summary>
        /// <param name="obj">pointer to a spangroup object.</param>
        /// <param name="width">the width of the span group.</param>
        public static int LvSpangroupGetExpandHeight(global::lvgl.LvObjT obj, int width)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvSpangroupGetExpandHeight(__arg0, width);
            return ___ret;
        }

        /// <summary>Update the mode of the spangroup.</summary>
        /// <param name="obj">pointer to a spangroup object.</param>
        public static void LvSpangroupRefrMode(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpangroupRefrMode(__arg0);
        }

        public static global::lvgl.LvObjClassT LvSpangroupClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_spangroup_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvSpinboxT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 184)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvTextareaT.__Internal ta;

            [FieldOffset(160)]
            internal int value;

            [FieldOffset(164)]
            internal int range_max;

            [FieldOffset(168)]
            internal int range_min;

            [FieldOffset(172)]
            internal int step;

            [FieldOffset(176)]
            internal uint digit_count;

            [FieldOffset(176)]
            internal uint dec_point_pos;

            [FieldOffset(177)]
            internal uint rollover;

            [FieldOffset(177)]
            internal uint digit_step_dir;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_spinbox_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvSpinboxT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvSpinboxT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvSpinboxT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvSpinboxT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvSpinboxT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvSpinboxT(native.ToPointer(), skipVTables);
        }

        internal static LvSpinboxT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvSpinboxT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvSpinboxT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvSpinboxT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvSpinboxT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvSpinboxT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvSpinboxT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvSpinboxT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvSpinboxT(global::lvgl.LvSpinboxT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvSpinboxT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvSpinboxT.__Internal*) __Instance) = *((global::lvgl.LvSpinboxT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvTextareaT Ta
        {
            get
            {
                return global::lvgl.LvTextareaT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ta));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ta = *(global::lvgl.LvTextareaT.__Internal*) value.__Instance;
            }
        }

        public int Value
        {
            get
            {
                return ((__Internal*)__Instance)->value;
            }

            set
            {
                ((__Internal*)__Instance)->value = value;
            }
        }

        public int RangeMax
        {
            get
            {
                return ((__Internal*)__Instance)->range_max;
            }

            set
            {
                ((__Internal*)__Instance)->range_max = value;
            }
        }

        public int RangeMin
        {
            get
            {
                return ((__Internal*)__Instance)->range_min;
            }

            set
            {
                ((__Internal*)__Instance)->range_min = value;
            }
        }

        public int Step
        {
            get
            {
                return ((__Internal*)__Instance)->step;
            }

            set
            {
                ((__Internal*)__Instance)->step = value;
            }
        }

        public uint DigitCount
        {
            get
            {
                return ((__Internal*)__Instance)->digit_count;
            }

            set
            {
                ((__Internal*)__Instance)->digit_count = value;
            }
        }

        public uint DecPointPos
        {
            get
            {
                return ((__Internal*)__Instance)->dec_point_pos;
            }

            set
            {
                ((__Internal*)__Instance)->dec_point_pos = value;
            }
        }

        public uint Rollover
        {
            get
            {
                return ((__Internal*)__Instance)->rollover;
            }

            set
            {
                ((__Internal*)__Instance)->rollover = value;
            }
        }

        public uint DigitStepDir
        {
            get
            {
                return ((__Internal*)__Instance)->digit_step_dir;
            }

            set
            {
                ((__Internal*)__Instance)->digit_step_dir = value;
            }
        }
    }

    public unsafe partial class lv_spinbox
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spinbox_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvSpinboxCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spinbox_set_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpinboxSetValue(__IntPtr obj, int v);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spinbox_set_rollover", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpinboxSetRollover(__IntPtr obj, bool rollover);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spinbox_set_digit_format", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpinboxSetDigitFormat(__IntPtr obj, uint digit_count, uint sep_pos);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spinbox_set_step", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpinboxSetStep(__IntPtr obj, uint step);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spinbox_set_range", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpinboxSetRange(__IntPtr obj, int range_min, int range_max);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spinbox_set_cursor_pos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpinboxSetCursorPos(__IntPtr obj, uint pos);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spinbox_set_digit_step_direction", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpinboxSetDigitStepDirection(__IntPtr obj, byte direction);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spinbox_get_rollover", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvSpinboxGetRollover(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spinbox_get_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvSpinboxGetValue(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spinbox_get_step", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvSpinboxGetStep(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spinbox_step_next", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpinboxStepNext(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spinbox_step_prev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpinboxStepPrev(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spinbox_increment", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpinboxIncrement(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spinbox_decrement", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpinboxDecrement(__IntPtr obj);
        }

        /// <summary>Create a spinbox object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new spinbox</param>
        /// <returns>pointer to the created spinbox</returns>
        public static global::lvgl.LvObjT LvSpinboxCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvSpinboxCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set spinbox value</summary>
        /// <param name="obj">pointer to spinbox</param>
        /// <param name="v">value to be set</param>
        public static void LvSpinboxSetValue(global::lvgl.LvObjT obj, int v)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpinboxSetValue(__arg0, v);
        }

        /// <summary>Set spinbox rollover function</summary>
        /// <param name="obj">pointer to spinbox</param>
        /// <param name="rollover">true or false to enable or disable (default)</param>
        public static void LvSpinboxSetRollover(global::lvgl.LvObjT obj, bool rollover)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpinboxSetRollover(__arg0, rollover);
        }

        /// <summary>Set spinbox digit format (digit count and decimal format)</summary>
        /// <param name="obj">pointer to spinbox</param>
        /// <param name="digit_count">number of digit excluding the decimal separator and the sign</param>
        /// <param name="sep_pos">
        /// <para>number of digit before the decimal point. If 0, decimal point is not</para>
        /// <para>shown</para>
        /// </param>
        public static void LvSpinboxSetDigitFormat(global::lvgl.LvObjT obj, uint digit_count, uint sep_pos)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpinboxSetDigitFormat(__arg0, digit_count, sep_pos);
        }

        /// <summary>Set spinbox step</summary>
        /// <param name="obj">pointer to spinbox</param>
        /// <param name="step">steps on increment/decrement. Can be 1, 10, 100, 1000, etc the digit that will change.</param>
        public static void LvSpinboxSetStep(global::lvgl.LvObjT obj, uint step)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpinboxSetStep(__arg0, step);
        }

        /// <summary>Set spinbox value range</summary>
        /// <param name="obj">pointer to spinbox</param>
        /// <param name="range_min">maximum value, inclusive</param>
        /// <param name="range_max">minimum value, inclusive</param>
        public static void LvSpinboxSetRange(global::lvgl.LvObjT obj, int range_min, int range_max)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpinboxSetRange(__arg0, range_min, range_max);
        }

        /// <summary>Set cursor position to a specific digit for edition</summary>
        /// <param name="obj">pointer to spinbox</param>
        /// <param name="pos">selected position in spinbox</param>
        public static void LvSpinboxSetCursorPos(global::lvgl.LvObjT obj, uint pos)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpinboxSetCursorPos(__arg0, pos);
        }

        /// <summary>Set direction of digit step when clicking an encoder button while in editing mode</summary>
        /// <param name="obj">pointer to spinbox</param>
        /// <param name="direction">the direction (LV_DIR_RIGHT or LV_DIR_LEFT)</param>
        public static void LvSpinboxSetDigitStepDirection(global::lvgl.LvObjT obj, byte direction)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpinboxSetDigitStepDirection(__arg0, direction);
        }

        /// <summary>Get spinbox rollover function status</summary>
        /// <param name="obj">pointer to spinbox</param>
        public static bool LvSpinboxGetRollover(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvSpinboxGetRollover(__arg0);
            return ___ret;
        }

        /// <summary>Get the spinbox numeral value (user has to convert to float according to its digit format)</summary>
        /// <param name="obj">pointer to spinbox</param>
        /// <returns>value integer value of the spinbox</returns>
        public static int LvSpinboxGetValue(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvSpinboxGetValue(__arg0);
            return ___ret;
        }

        /// <summary>Get the spinbox step value (user has to convert to float according to its digit format)</summary>
        /// <param name="obj">pointer to spinbox</param>
        /// <returns>value integer step value of the spinbox</returns>
        public static int LvSpinboxGetStep(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvSpinboxGetStep(__arg0);
            return ___ret;
        }

        /// <summary>Select next lower digit for edition by dividing the step by 10</summary>
        /// <param name="obj">pointer to spinbox</param>
        public static void LvSpinboxStepNext(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpinboxStepNext(__arg0);
        }

        /// <summary>Select next higher digit for edition by multiplying the step by 10</summary>
        /// <param name="obj">pointer to spinbox</param>
        public static void LvSpinboxStepPrev(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpinboxStepPrev(__arg0);
        }

        /// <summary>Increment spinbox value by one step</summary>
        /// <param name="obj">pointer to spinbox</param>
        public static void LvSpinboxIncrement(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpinboxIncrement(__arg0);
        }

        /// <summary>Decrement spinbox value by one step</summary>
        /// <param name="obj">pointer to spinbox</param>
        public static void LvSpinboxDecrement(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpinboxDecrement(__arg0);
        }

        public static global::lvgl.LvObjClassT LvSpinboxClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_spinbox_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvTextareaT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 160)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvObjT.__Internal obj;

            [FieldOffset(64)]
            internal __IntPtr label;

            [FieldOffset(72)]
            internal __IntPtr placeholder_txt;

            [FieldOffset(80)]
            internal __IntPtr pwd_tmp;

            [FieldOffset(88)]
            internal __IntPtr pwd_bullet;

            [FieldOffset(96)]
            internal __IntPtr accepted_chars;

            [FieldOffset(104)]
            internal uint max_length;

            [FieldOffset(108)]
            internal uint pwd_show_time;

            [FieldOffset(112)]
            internal global::lvgl.LvTextareaT.Cursor.__Internal cursor;

            [FieldOffset(144)]
            internal uint sel_start;

            [FieldOffset(148)]
            internal uint sel_end;

            [FieldOffset(152)]
            internal byte text_sel_in_prog;

            [FieldOffset(152)]
            internal byte text_sel_en;

            [FieldOffset(152)]
            internal byte pwd_mode;

            [FieldOffset(152)]
            internal byte one_line;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_textarea_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial class Cursor : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal int valid_x;

                [FieldOffset(4)]
                internal uint pos;

                [FieldOffset(8)]
                internal global::lvgl.LvAreaT.__Internal area;

                [FieldOffset(24)]
                internal uint txt_byte_pos;

                [FieldOffset(28)]
                internal byte show;

                [FieldOffset(28)]
                internal byte click_pos;

                [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0<unnamed-type-cursor>@lv_textarea_t@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTextareaT.Cursor> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTextareaT.Cursor>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvTextareaT.Cursor managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvTextareaT.Cursor managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Cursor __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Cursor(native.ToPointer(), skipVTables);
            }

            internal static Cursor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Cursor)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Cursor __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Cursor(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Cursor(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Cursor(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Cursor()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTextareaT.Cursor.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public Cursor(global::lvgl.LvTextareaT.Cursor _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTextareaT.Cursor.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::lvgl.LvTextareaT.Cursor.__Internal*) __Instance) = *((global::lvgl.LvTextareaT.Cursor.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public int ValidX
            {
                get
                {
                    return ((__Internal*)__Instance)->valid_x;
                }

                set
                {
                    ((__Internal*)__Instance)->valid_x = value;
                }
            }

            public uint Pos
            {
                get
                {
                    return ((__Internal*)__Instance)->pos;
                }

                set
                {
                    ((__Internal*)__Instance)->pos = value;
                }
            }

            public global::lvgl.LvAreaT Area
            {
                get
                {
                    return global::lvgl.LvAreaT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->area));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->area = *(global::lvgl.LvAreaT.__Internal*) value.__Instance;
                }
            }

            public uint TxtBytePos
            {
                get
                {
                    return ((__Internal*)__Instance)->txt_byte_pos;
                }

                set
                {
                    ((__Internal*)__Instance)->txt_byte_pos = value;
                }
            }

            public byte Show
            {
                get
                {
                    return ((__Internal*)__Instance)->show;
                }

                set
                {
                    ((__Internal*)__Instance)->show = value;
                }
            }

            public byte ClickPos
            {
                get
                {
                    return ((__Internal*)__Instance)->click_pos;
                }

                set
                {
                    ((__Internal*)__Instance)->click_pos = value;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTextareaT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTextareaT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvTextareaT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvTextareaT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __accepted_chars_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static LvTextareaT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvTextareaT(native.ToPointer(), skipVTables);
        }

        internal static LvTextareaT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvTextareaT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvTextareaT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvTextareaT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvTextareaT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvTextareaT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvTextareaT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTextareaT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvTextareaT(global::lvgl.LvTextareaT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTextareaT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvTextareaT.__Internal*) __Instance) = *((global::lvgl.LvTextareaT.__Internal*) _0.__Instance);
            if (_0.__accepted_chars_OwnsNativeMemory)
                this.AcceptedChars = _0.AcceptedChars;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__accepted_chars_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->accepted_chars);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvObjT Label
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->label, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->label = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public sbyte* PlaceholderTxt
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->placeholder_txt;
            }

            set
            {
                ((__Internal*)__Instance)->placeholder_txt = (__IntPtr) value;
            }
        }

        public sbyte* PwdTmp
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->pwd_tmp;
            }

            set
            {
                ((__Internal*)__Instance)->pwd_tmp = (__IntPtr) value;
            }
        }

        public sbyte* PwdBullet
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->pwd_bullet;
            }

            set
            {
                ((__Internal*)__Instance)->pwd_bullet = (__IntPtr) value;
            }
        }

        public string AcceptedChars
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->accepted_chars);
            }

            set
            {
                if (__accepted_chars_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->accepted_chars);
                __accepted_chars_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->accepted_chars = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->accepted_chars = (__IntPtr) __bytePtr0;
            }
        }

        public uint MaxLength
        {
            get
            {
                return ((__Internal*)__Instance)->max_length;
            }

            set
            {
                ((__Internal*)__Instance)->max_length = value;
            }
        }

        public uint PwdShowTime
        {
            get
            {
                return ((__Internal*)__Instance)->pwd_show_time;
            }

            set
            {
                ((__Internal*)__Instance)->pwd_show_time = value;
            }
        }

        public global::lvgl.LvTextareaT.Cursor cursor
        {
            get
            {
                return global::lvgl.LvTextareaT.Cursor.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->cursor));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->cursor = *(global::lvgl.LvTextareaT.Cursor.__Internal*) value.__Instance;
            }
        }

        public uint SelStart
        {
            get
            {
                return ((__Internal*)__Instance)->sel_start;
            }

            set
            {
                ((__Internal*)__Instance)->sel_start = value;
            }
        }

        public uint SelEnd
        {
            get
            {
                return ((__Internal*)__Instance)->sel_end;
            }

            set
            {
                ((__Internal*)__Instance)->sel_end = value;
            }
        }

        public byte TextSelInProg
        {
            get
            {
                return ((__Internal*)__Instance)->text_sel_in_prog;
            }

            set
            {
                ((__Internal*)__Instance)->text_sel_in_prog = value;
            }
        }

        public byte TextSelEn
        {
            get
            {
                return ((__Internal*)__Instance)->text_sel_en;
            }

            set
            {
                ((__Internal*)__Instance)->text_sel_en = value;
            }
        }

        public byte PwdMode
        {
            get
            {
                return ((__Internal*)__Instance)->pwd_mode;
            }

            set
            {
                ((__Internal*)__Instance)->pwd_mode = value;
            }
        }

        public byte OneLine
        {
            get
            {
                return ((__Internal*)__Instance)->one_line;
            }

            set
            {
                ((__Internal*)__Instance)->one_line = value;
            }
        }
    }

    public unsafe partial class lv_textarea
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTextareaCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_add_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaAddChar(__IntPtr obj, uint c);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_add_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaAddText(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string txt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_delete_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaDeleteChar(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_delete_char_forward", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaDeleteCharForward(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_set_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaSetText(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string txt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_set_placeholder_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaSetPlaceholderText(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string txt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_set_cursor_pos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaSetCursorPos(__IntPtr obj, int pos);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_set_cursor_click_pos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaSetCursorClickPos(__IntPtr obj, bool en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_set_password_mode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaSetPasswordMode(__IntPtr obj, bool en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_set_password_bullet", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaSetPasswordBullet(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string bullet);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_set_one_line", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaSetOneLine(__IntPtr obj, bool en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_set_accepted_chars", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaSetAcceptedChars(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string list);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_set_max_length", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaSetMaxLength(__IntPtr obj, uint num);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_set_insert_replace", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaSetInsertReplace(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string txt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_set_text_selection", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaSetTextSelection(__IntPtr obj, bool en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_set_password_show_time", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaSetPasswordShowTime(__IntPtr obj, uint time);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_set_align", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaSetAlign(__IntPtr obj, byte align);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_get_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTextareaGetText(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_get_placeholder_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTextareaGetPlaceholderText(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_get_label", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTextareaGetLabel(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_get_cursor_pos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvTextareaGetCursorPos(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_get_cursor_click_pos", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvTextareaGetCursorClickPos(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_get_password_mode", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvTextareaGetPasswordMode(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_get_password_bullet", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTextareaGetPasswordBullet(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_get_one_line", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvTextareaGetOneLine(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_get_accepted_chars", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTextareaGetAcceptedChars(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_get_max_length", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvTextareaGetMaxLength(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_text_is_selected", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvTextareaTextIsSelected(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_get_text_selection", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvTextareaGetTextSelection(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_get_password_show_time", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvTextareaGetPasswordShowTime(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_get_current_char", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvTextareaGetCurrentChar(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_clear_selection", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaClearSelection(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_cursor_right", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaCursorRight(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_cursor_left", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaCursorLeft(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_cursor_down", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaCursorDown(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_textarea_cursor_up", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTextareaCursorUp(__IntPtr obj);
        }

        /// <summary>Create a text area object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new text area</param>
        /// <returns>pointer to the created text area</returns>
        public static global::lvgl.LvObjT LvTextareaCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvTextareaCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Insert a character to the current cursor position.</para>
        /// <para>To add a wide char, e.g. '&#193;' use `lv_text_encoded_conv_wc('&#193;')`</para>
        /// </summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <param name="c">a character (e.g. 'a')</param>
        public static void LvTextareaAddChar(global::lvgl.LvObjT obj, uint c)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaAddChar(__arg0, c);
        }

        /// <summary>Insert a text to the current cursor position</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <param name="txt">a '\0' terminated string to insert</param>
        public static void LvTextareaAddText(global::lvgl.LvObjT obj, string txt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaAddText(__arg0, txt);
        }

        /// <summary>Delete a the left character from the current cursor position</summary>
        /// <param name="obj">pointer to a text area object</param>
        public static void LvTextareaDeleteChar(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaDeleteChar(__arg0);
        }

        /// <summary>Delete the right character from the current cursor position</summary>
        /// <param name="obj">pointer to a text area object</param>
        public static void LvTextareaDeleteCharForward(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaDeleteCharForward(__arg0);
        }

        /// <summary>Set the text of a text area</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <param name="txt">pointer to the text</param>
        public static void LvTextareaSetText(global::lvgl.LvObjT obj, string txt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaSetText(__arg0, txt);
        }

        /// <summary>Set the placeholder text of a text area</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <param name="txt">pointer to the text</param>
        public static void LvTextareaSetPlaceholderText(global::lvgl.LvObjT obj, string txt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaSetPlaceholderText(__arg0, txt);
        }

        /// <summary>Set the cursor position</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <param name="pos">
        /// <para>the new cursor position in character index</para>
        /// <para>&lt;0 : index from the end of the text</para>
        /// <para>LV_TEXTAREA_CURSOR_LAST: go after the last character</para>
        /// </param>
        public static void LvTextareaSetCursorPos(global::lvgl.LvObjT obj, int pos)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaSetCursorPos(__arg0, pos);
        }

        /// <summary>Enable/Disable the positioning of the cursor by clicking the text on the text area.</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <param name="en">true: enable click positions; false: disable</param>
        public static void LvTextareaSetCursorClickPos(global::lvgl.LvObjT obj, bool en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaSetCursorClickPos(__arg0, en);
        }

        /// <summary>Enable/Disable password mode</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <param name="en">true: enable, false: disable</param>
        public static void LvTextareaSetPasswordMode(global::lvgl.LvObjT obj, bool en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaSetPasswordMode(__arg0, en);
        }

        /// <summary>Set the replacement characters to show in password mode</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <param name="bullet">pointer to the replacement text</param>
        public static void LvTextareaSetPasswordBullet(global::lvgl.LvObjT obj, string bullet)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaSetPasswordBullet(__arg0, bullet);
        }

        /// <summary>Configure the text area to one line or back to normal</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <param name="en">true: one line, false: normal</param>
        public static void LvTextareaSetOneLine(global::lvgl.LvObjT obj, bool en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaSetOneLine(__arg0, en);
        }

        /// <summary>Set a list of characters. Only these characters will be accepted by the text area</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <param name="list">list of characters. Only the pointer is saved. E.g. &quot;+-.,0123456789&quot;</param>
        public static void LvTextareaSetAcceptedChars(global::lvgl.LvObjT obj, string list)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaSetAcceptedChars(__arg0, list);
        }

        /// <summary>Set max length of a Text Area.</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <param name="num">the maximal number of characters can be added (`lv_textarea_set_text` ignores it)</param>
        public static void LvTextareaSetMaxLength(global::lvgl.LvObjT obj, uint num)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaSetMaxLength(__arg0, num);
        }

        /// <summary>
        /// <para>In `LV_EVENT_INSERT` the text which planned to be inserted can be replaced by an other text.</para>
        /// <para>It can be used to add automatic formatting to the text area.</para>
        /// </summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <param name="txt">
        /// <para>pointer to a new string to insert. If `&quot;&quot;` no text will be added.</para>
        /// <para>The variable must be live after the `event_cb` exists. (Should be `global` or `static`)</para>
        /// </param>
        public static void LvTextareaSetInsertReplace(global::lvgl.LvObjT obj, string txt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaSetInsertReplace(__arg0, txt);
        }

        /// <summary>Enable/disable selection mode.</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <param name="en">true or false to enable/disable selection mode</param>
        public static void LvTextareaSetTextSelection(global::lvgl.LvObjT obj, bool en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaSetTextSelection(__arg0, en);
        }

        /// <summary>Set how long show the password before changing it to '*'</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <param name="time">show time in milliseconds. 0: hide immediately.</param>
        public static void LvTextareaSetPasswordShowTime(global::lvgl.LvObjT obj, uint time)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaSetPasswordShowTime(__arg0, time);
        }

        /// <param name="obj">pointer to a text area object</param>
        /// <param name="align">the align mode from ::lv_text_align_t</param>
        /// <remarks>
        /// <para>Use the normal text_align style property instead</para>
        /// <para>Set the label's alignment.</para>
        /// <para>It sets where the label is aligned (in one line mode it can be smaller than the text area)</para>
        /// <para>and how the lines of the area align in case of multiline text area</para>
        /// </remarks>
        public static void LvTextareaSetAlign(global::lvgl.LvObjT obj, byte align)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaSetAlign(__arg0, align);
        }

        /// <summary>Get the text of a text area. In password mode it gives the real text (not '*'s).</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <returns>pointer to the text</returns>
        public static string LvTextareaGetText(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTextareaGetText(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the placeholder text of a text area</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <returns>pointer to the text</returns>
        public static string LvTextareaGetPlaceholderText(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTextareaGetPlaceholderText(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the label of a text area</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <returns>pointer to the label object</returns>
        public static global::lvgl.LvObjT LvTextareaGetLabel(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTextareaGetLabel(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the current cursor position in character index</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <returns>the cursor position</returns>
        public static uint LvTextareaGetCursorPos(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTextareaGetCursorPos(__arg0);
            return ___ret;
        }

        /// <summary>Get whether the cursor click positioning is enabled or not.</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <returns>true: enable click positions; false: disable</returns>
        public static bool LvTextareaGetCursorClickPos(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTextareaGetCursorClickPos(__arg0);
            return ___ret;
        }

        /// <summary>Get the password mode attribute</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <returns>true: password mode is enabled, false: disabled</returns>
        public static bool LvTextareaGetPasswordMode(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTextareaGetPasswordMode(__arg0);
            return ___ret;
        }

        /// <summary>Get the replacement characters to show in password mode</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <returns>pointer to the replacement text</returns>
        public static string LvTextareaGetPasswordBullet(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTextareaGetPasswordBullet(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the one line configuration attribute</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <returns>true: one line configuration is enabled, false: disabled</returns>
        public static bool LvTextareaGetOneLine(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTextareaGetOneLine(__arg0);
            return ___ret;
        }

        /// <summary>Get a list of accepted characters.</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <returns>list of accented characters.</returns>
        public static string LvTextareaGetAcceptedChars(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTextareaGetAcceptedChars(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get max length of a Text Area.</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <returns>the maximal number of characters to be add</returns>
        public static uint LvTextareaGetMaxLength(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTextareaGetMaxLength(__arg0);
            return ___ret;
        }

        /// <summary>Find whether text is selected or not.</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <returns>whether text is selected or not</returns>
        public static bool LvTextareaTextIsSelected(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTextareaTextIsSelected(__arg0);
            return ___ret;
        }

        /// <summary>Find whether selection mode is enabled.</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <returns>true: selection mode is enabled, false: disabled</returns>
        public static bool LvTextareaGetTextSelection(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTextareaGetTextSelection(__arg0);
            return ___ret;
        }

        /// <summary>Set how long show the password before changing it to '*'</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <returns>show time in milliseconds. 0: hide immediately.</returns>
        public static uint LvTextareaGetPasswordShowTime(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTextareaGetPasswordShowTime(__arg0);
            return ___ret;
        }

        /// <summary>Get a the character from the current cursor position</summary>
        /// <param name="obj">pointer to a text area object</param>
        /// <returns>a the character or 0</returns>
        public static uint LvTextareaGetCurrentChar(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTextareaGetCurrentChar(__arg0);
            return ___ret;
        }

        /// <summary>Clear the selection on the text area.</summary>
        /// <param name="obj">pointer to a text area object</param>
        public static void LvTextareaClearSelection(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaClearSelection(__arg0);
        }

        /// <summary>Move the cursor one character right</summary>
        /// <param name="obj">pointer to a text area object</param>
        public static void LvTextareaCursorRight(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaCursorRight(__arg0);
        }

        /// <summary>Move the cursor one character left</summary>
        /// <param name="obj">pointer to a text area object</param>
        public static void LvTextareaCursorLeft(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaCursorLeft(__arg0);
        }

        /// <summary>Move the cursor one line down</summary>
        /// <param name="obj">pointer to a text area object</param>
        public static void LvTextareaCursorDown(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaCursorDown(__arg0);
        }

        /// <summary>Move the cursor one line up</summary>
        /// <param name="obj">pointer to a text area object</param>
        public static void LvTextareaCursorUp(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTextareaCursorUp(__arg0);
        }

        public static global::lvgl.LvObjClassT LvTextareaClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_textarea_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    public unsafe partial class lv_spinner
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spinner_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvSpinnerCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_spinner_set_anim_params", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSpinnerSetAnimParams(__IntPtr obj, uint t, uint angle);
        }

        /// <summary>Create a spinner widget</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new spinner.</param>
        /// <returns>the created spinner</returns>
        public static global::lvgl.LvObjT LvSpinnerCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvSpinnerCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the animation time and arc length of the spinner</summary>
        /// <param name="obj">pointer to a spinner</param>
        /// <param name="t">the animation time in milliseconds</param>
        /// <param name="angle">the angle of the arc in degrees</param>
        public static void LvSpinnerSetAnimParams(global::lvgl.LvObjT obj, uint t, uint angle)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSpinnerSetAnimParams(__arg0, t, angle);
        }

        /// <summary>
        /// <para>********************</para>
        /// <para>TYPEDEFS</para>
        /// <para>********************</para>
        /// </summary>
        public static global::lvgl.LvObjClassT LvSpinnerClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_spinner_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvSwitchT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal global::lvgl.LvObjT.__Internal obj;
            internal int anim_state;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_switch_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvSwitchT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvSwitchT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvSwitchT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvSwitchT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvSwitchT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvSwitchT(native.ToPointer(), skipVTables);
        }

        internal static LvSwitchT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvSwitchT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvSwitchT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvSwitchT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvSwitchT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvSwitchT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvSwitchT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvSwitchT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvSwitchT(global::lvgl.LvSwitchT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvSwitchT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvSwitchT.__Internal*) __Instance) = *((global::lvgl.LvSwitchT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        public int AnimState
        {
            get
            {
                return ((__Internal*)__Instance)->anim_state;
            }

            set
            {
                ((__Internal*)__Instance)->anim_state = value;
            }
        }
    }

    public unsafe partial class lv_switch
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_switch_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvSwitchCreate(__IntPtr parent);
        }

        /// <summary>Create a switch object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new switch</param>
        /// <returns>pointer to the created switch</returns>
        public static global::lvgl.LvObjT LvSwitchCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvSwitchCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::lvgl.LvObjClassT LvSwitchClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_switch_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    [Flags]
    public enum LvTableCellCtrlT
    {
        LV_TABLE_CELL_CTRL_MERGE_RIGHT = 1,
        LV_TABLE_CELL_CTRL_TEXT_CROP = 2,
        LV_TABLE_CELL_CTRL_CUSTOM_1 = 16,
        LV_TABLE_CELL_CTRL_CUSTOM_2 = 32,
        LV_TABLE_CELL_CTRL_CUSTOM_3 = 64,
        LV_TABLE_CELL_CTRL_CUSTOM_4 = 128
    }

    public unsafe partial class LvTableCellT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal uint ctrl;
            internal __IntPtr user_data;
            internal fixed sbyte txt[1];

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_table_cell_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTableCellT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTableCellT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvTableCellT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvTableCellT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvTableCellT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvTableCellT(native.ToPointer(), skipVTables);
        }

        internal static LvTableCellT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvTableCellT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvTableCellT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvTableCellT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvTableCellT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvTableCellT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvTableCellT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTableCellT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvTableCellT(global::lvgl.LvTableCellT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTableCellT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvTableCellT.__Internal*) __Instance) = *((global::lvgl.LvTableCellT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Ctrl
        {
            get
            {
                return ((__Internal*)__Instance)->ctrl;
            }

            set
            {
                ((__Internal*)__Instance)->ctrl = value;
            }
        }

        /// <summary>Custom user data</summary>
        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }

        /// <summary>Variable length array</summary>
        public sbyte[] Txt
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->txt, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->txt[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class LvTableT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 104)]
        public partial struct __Internal
        {
            internal global::lvgl.LvObjT.__Internal obj;
            internal uint col_cnt;
            internal uint row_cnt;
            internal __IntPtr cell_data;
            internal __IntPtr row_h;
            internal __IntPtr col_w;
            internal uint col_act;
            internal uint row_act;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_table_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTableT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTableT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvTableT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvTableT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvTableT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvTableT(native.ToPointer(), skipVTables);
        }

        internal static LvTableT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvTableT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvTableT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvTableT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvTableT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvTableT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvTableT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTableT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvTableT(global::lvgl.LvTableT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTableT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvTableT.__Internal*) __Instance) = *((global::lvgl.LvTableT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        public uint ColCnt
        {
            get
            {
                return ((__Internal*)__Instance)->col_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->col_cnt = value;
            }
        }

        public uint RowCnt
        {
            get
            {
                return ((__Internal*)__Instance)->row_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->row_cnt = value;
            }
        }

        public global::lvgl.LvTableCellT CellData
        {
            get
            {
                var __result0 = global::lvgl.LvTableCellT.__GetOrCreateInstance(((__Internal*)__Instance)->cell_data, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->cell_data = new __IntPtr(&__value);
            }
        }

        public int* RowH
        {
            get
            {
                return (int*) ((__Internal*)__Instance)->row_h;
            }

            set
            {
                ((__Internal*)__Instance)->row_h = (__IntPtr) value;
            }
        }

        public int* ColW
        {
            get
            {
                return (int*) ((__Internal*)__Instance)->col_w;
            }

            set
            {
                ((__Internal*)__Instance)->col_w = (__IntPtr) value;
            }
        }

        public uint ColAct
        {
            get
            {
                return ((__Internal*)__Instance)->col_act;
            }

            set
            {
                ((__Internal*)__Instance)->col_act = value;
            }
        }

        public uint RowAct
        {
            get
            {
                return ((__Internal*)__Instance)->row_act;
            }

            set
            {
                ((__Internal*)__Instance)->row_act = value;
            }
        }
    }

    public unsafe partial class lv_table
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_table_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTableCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_table_set_cell_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTableSetCellValue(__IntPtr obj, uint row, uint col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string txt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_table_set_cell_value_fmt", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTableSetCellValueFmt(__IntPtr obj, uint row, uint col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_table_set_row_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTableSetRowCount(__IntPtr obj, uint row_cnt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_table_set_column_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTableSetColumnCount(__IntPtr obj, uint col_cnt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_table_set_column_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTableSetColumnWidth(__IntPtr obj, uint col_id, int w);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_table_add_cell_ctrl", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTableAddCellCtrl(__IntPtr obj, uint row, uint col, uint ctrl);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_table_clear_cell_ctrl", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTableClearCellCtrl(__IntPtr obj, uint row, uint col, uint ctrl);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_table_set_cell_user_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTableSetCellUserData(__IntPtr obj, ushort row, ushort col, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_table_set_selected_cell", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTableSetSelectedCell(__IntPtr obj, ushort row, ushort col);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_table_get_cell_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTableGetCellValue(__IntPtr obj, uint row, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_table_get_row_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvTableGetRowCount(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_table_get_column_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvTableGetColumnCount(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_table_get_column_width", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvTableGetColumnWidth(__IntPtr obj, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_table_has_cell_ctrl", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvTableHasCellCtrl(__IntPtr obj, uint row, uint col, uint ctrl);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_table_get_selected_cell", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTableGetSelectedCell(__IntPtr obj, uint* row, uint* col);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_table_get_cell_user_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTableGetCellUserData(__IntPtr obj, ushort row, ushort col);
        }

        /// <summary>Create a table object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new table</param>
        /// <returns>pointer to the created table</returns>
        public static global::lvgl.LvObjT LvTableCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvTableCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the value of a cell.</summary>
        /// <param name="obj">pointer to a Table object</param>
        /// <param name="row">id of the row [0 .. row_cnt -1]</param>
        /// <param name="col">id of the column [0 .. col_cnt -1]</param>
        /// <param name="txt">text to display in the cell. It will be copied and saved so this variable is not required after this function call.</param>
        /// <remarks>New roes/columns are added automatically if required</remarks>
        public static void LvTableSetCellValue(global::lvgl.LvObjT obj, uint row, uint col, string txt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTableSetCellValue(__arg0, row, col, txt);
        }

        /// <summary>Set the value of a cell.  Memory will be allocated to store the text by the table.</summary>
        /// <param name="obj">pointer to a Table object</param>
        /// <param name="row">id of the row [0 .. row_cnt -1]</param>
        /// <param name="col">id of the column [0 .. col_cnt -1]</param>
        /// <param name="fmt">`printf`-like format</param>
        /// <remarks>New roes/columns are added automatically if required</remarks>
        public static void LvTableSetCellValueFmt(global::lvgl.LvObjT obj, uint row, uint col, string fmt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTableSetCellValueFmt(__arg0, row, col, fmt);
        }

        /// <summary>Set the number of rows</summary>
        /// <param name="obj">table pointer to a Table object</param>
        /// <param name="row_cnt">number of rows</param>
        public static void LvTableSetRowCount(global::lvgl.LvObjT obj, uint row_cnt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTableSetRowCount(__arg0, row_cnt);
        }

        /// <summary>Set the number of columns</summary>
        /// <param name="obj">table pointer to a Table object</param>
        /// <param name="col_cnt">number of columns.</param>
        public static void LvTableSetColumnCount(global::lvgl.LvObjT obj, uint col_cnt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTableSetColumnCount(__arg0, col_cnt);
        }

        /// <summary>Set the width of a column</summary>
        /// <param name="obj">table pointer to a Table object</param>
        /// <param name="col_id">id of the column [0 .. LV_TABLE_COL_MAX -1]</param>
        /// <param name="w">width of the column</param>
        public static void LvTableSetColumnWidth(global::lvgl.LvObjT obj, uint col_id, int w)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTableSetColumnWidth(__arg0, col_id, w);
        }

        /// <summary>Add control bits to the cell.</summary>
        /// <param name="obj">pointer to a Table object</param>
        /// <param name="row">id of the row [0 .. row_cnt -1]</param>
        /// <param name="col">id of the column [0 .. col_cnt -1]</param>
        /// <param name="ctrl">OR-ed values from ::lv_table_cell_ctrl_t</param>
        public static void LvTableAddCellCtrl(global::lvgl.LvObjT obj, uint row, uint col, uint ctrl)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTableAddCellCtrl(__arg0, row, col, ctrl);
        }

        /// <summary>Clear control bits of the cell.</summary>
        /// <param name="obj">pointer to a Table object</param>
        /// <param name="row">id of the row [0 .. row_cnt -1]</param>
        /// <param name="col">id of the column [0 .. col_cnt -1]</param>
        /// <param name="ctrl">OR-ed values from ::lv_table_cell_ctrl_t</param>
        public static void LvTableClearCellCtrl(global::lvgl.LvObjT obj, uint row, uint col, uint ctrl)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTableClearCellCtrl(__arg0, row, col, ctrl);
        }

        /// <summary>Add custom user data to the cell.</summary>
        /// <param name="obj">pointer to a Table object</param>
        /// <param name="row">id of the row [0 .. row_cnt -1]</param>
        /// <param name="col">id of the column [0 .. col_cnt -1]</param>
        /// <param name="user_data">
        /// <para>pointer to the new user_data.</para>
        /// <para>Should be allocated by `lv_malloc`,</para>
        /// <para>and it will be freed automatically when the table is deleted or</para>
        /// <para>when the cell is dropped due to lower row or column count.</para>
        /// </param>
        public static void LvTableSetCellUserData(global::lvgl.LvObjT obj, ushort row, ushort col, __IntPtr user_data)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTableSetCellUserData(__arg0, row, col, user_data);
        }

        /// <summary>Set the selected cell</summary>
        /// <param name="obj">pointer to a table object</param>
        /// <param name="row">id of the cell row to select</param>
        /// <param name="col">id of the cell column to select</param>
        public static void LvTableSetSelectedCell(global::lvgl.LvObjT obj, ushort row, ushort col)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTableSetSelectedCell(__arg0, row, col);
        }

        /// <summary>Get the value of a cell.</summary>
        /// <param name="obj">pointer to a Table object</param>
        /// <param name="row">id of the row [0 .. row_cnt -1]</param>
        /// <param name="col">id of the column [0 .. col_cnt -1]</param>
        /// <returns>text in the cell</returns>
        public static string LvTableGetCellValue(global::lvgl.LvObjT obj, uint row, uint col)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTableGetCellValue(__arg0, row, col);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the number of rows.</summary>
        /// <param name="obj">table pointer to a Table object</param>
        /// <returns>number of rows.</returns>
        public static uint LvTableGetRowCount(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTableGetRowCount(__arg0);
            return ___ret;
        }

        /// <summary>Get the number of columns.</summary>
        /// <param name="obj">table pointer to a Table object</param>
        /// <returns>number of columns.</returns>
        public static uint LvTableGetColumnCount(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTableGetColumnCount(__arg0);
            return ___ret;
        }

        /// <summary>Get the width of a column</summary>
        /// <param name="obj">table pointer to a Table object</param>
        /// <param name="col">id of the column [0 .. LV_TABLE_COL_MAX -1]</param>
        /// <returns>width of the column</returns>
        public static int LvTableGetColumnWidth(global::lvgl.LvObjT obj, uint col)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTableGetColumnWidth(__arg0, col);
            return ___ret;
        }

        /// <summary>Get whether a cell has the control bits</summary>
        /// <param name="obj">pointer to a Table object</param>
        /// <param name="row">id of the row [0 .. row_cnt -1]</param>
        /// <param name="col">id of the column [0 .. col_cnt -1]</param>
        /// <param name="ctrl">OR-ed values from ::lv_table_cell_ctrl_t</param>
        /// <returns>true: all control bits are set; false: not all control bits are set</returns>
        public static bool LvTableHasCellCtrl(global::lvgl.LvObjT obj, uint row, uint col, uint ctrl)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTableHasCellCtrl(__arg0, row, col, ctrl);
            return ___ret;
        }

        /// <summary>Get the selected cell (pressed and or focused)</summary>
        /// <param name="obj">pointer to a table object</param>
        /// <param name="row">pointer to variable to store the selected row (LV_TABLE_CELL_NONE: if no cell selected)</param>
        /// <param name="col">pointer to variable to store the selected column  (LV_TABLE_CELL_NONE: if no cell selected)</param>
        public static void LvTableGetSelectedCell(global::lvgl.LvObjT obj, ref uint row, ref uint col)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            fixed (uint* __row1 = &row)
            {
                var __arg1 = __row1;
                fixed (uint* __col2 = &col)
                {
                    var __arg2 = __col2;
                    __Internal.LvTableGetSelectedCell(__arg0, __arg1, __arg2);
                }
            }
        }

        /// <summary>Get custom user data to the cell.</summary>
        /// <param name="obj">pointer to a Table object</param>
        /// <param name="row">id of the row [0 .. row_cnt -1]</param>
        /// <param name="col">id of the column [0 .. col_cnt -1]</param>
        public static __IntPtr LvTableGetCellUserData(global::lvgl.LvObjT obj, ushort row, ushort col)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTableGetCellUserData(__arg0, row, col);
            return ___ret;
        }

        public static global::lvgl.LvObjClassT LvTableClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_table_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvTabviewT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal global::lvgl.LvObjT.__Internal obj;
            internal uint tab_cur;
            internal byte tab_pos;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_tabview_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTabviewT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTabviewT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvTabviewT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvTabviewT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvTabviewT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvTabviewT(native.ToPointer(), skipVTables);
        }

        internal static LvTabviewT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvTabviewT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvTabviewT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvTabviewT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvTabviewT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvTabviewT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvTabviewT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTabviewT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvTabviewT(global::lvgl.LvTabviewT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTabviewT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvTabviewT.__Internal*) __Instance) = *((global::lvgl.LvTabviewT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        public uint TabCur
        {
            get
            {
                return ((__Internal*)__Instance)->tab_cur;
            }

            set
            {
                ((__Internal*)__Instance)->tab_cur = value;
            }
        }

        public byte TabPos
        {
            get
            {
                return ((__Internal*)__Instance)->tab_pos;
            }

            set
            {
                ((__Internal*)__Instance)->tab_pos = value;
            }
        }
    }

    public unsafe partial class lv_tabview
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tabview_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTabviewCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tabview_add_tab", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTabviewAddTab(__IntPtr obj, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tabview_rename_tab", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTabviewRenameTab(__IntPtr obj, uint idx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string new_name);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tabview_set_active", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTabviewSetActive(__IntPtr obj, uint idx, global::lvgl.LvAnimEnableT anim_en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tabview_set_tab_bar_position", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTabviewSetTabBarPosition(__IntPtr obj, byte dir);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tabview_set_tab_bar_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTabviewSetTabBarSize(__IntPtr obj, int size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tabview_get_tab_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvTabviewGetTabCount(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tabview_get_tab_active", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint LvTabviewGetTabActive(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tabview_get_content", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTabviewGetContent(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tabview_get_tab_bar", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTabviewGetTabBar(__IntPtr obj);
        }

        /// <summary>Create a tabview widget</summary>
        /// <param name="parent">pointer to a parent widget</param>
        /// <returns>the created tabview</returns>
        public static global::lvgl.LvObjT LvTabviewCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvTabviewCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Add a tab to the tabview</summary>
        /// <param name="obj">pointer to a tabview widget</param>
        /// <param name="name">the name of the tab, it will be displayed on the tab bar</param>
        /// <returns>the widget where the content of the tab can be created</returns>
        public static global::lvgl.LvObjT LvTabviewAddTab(global::lvgl.LvObjT obj, string name)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTabviewAddTab(__arg0, name);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Change the name of the tab</summary>
        /// <param name="obj">pointer to a tabview widget</param>
        /// <param name="idx">the index of the tab to rename</param>
        /// <param name="new_name">the new name as a string</param>
        public static void LvTabviewRenameTab(global::lvgl.LvObjT obj, uint idx, string new_name)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTabviewRenameTab(__arg0, idx, new_name);
        }

        /// <summary>Show a tab</summary>
        /// <param name="obj">pointer to a tabview widget</param>
        /// <param name="idx">the index of the tab to show</param>
        /// <param name="anim_en">LV_ANIM_ON/OFF</param>
        public static void LvTabviewSetActive(global::lvgl.LvObjT obj, uint idx, global::lvgl.LvAnimEnableT anim_en)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTabviewSetActive(__arg0, idx, anim_en);
        }

        /// <summary>Set the position of the tab bar</summary>
        /// <param name="obj">pointer to a tabview widget</param>
        /// <param name="dir">LV_DIR_TOP/BOTTOM/LEFT/RIGHT</param>
        public static void LvTabviewSetTabBarPosition(global::lvgl.LvObjT obj, byte dir)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTabviewSetTabBarPosition(__arg0, dir);
        }

        /// <summary>Set the width or height of the tab bar</summary>
        /// <param name="size">
        /// <para>size of the tab bar in pixels or percentage.</para>
        /// <para>will be used as width or height based on the position of the tab bar)</para>
        /// </param>
        public static void LvTabviewSetTabBarSize(global::lvgl.LvObjT obj, int size)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvTabviewSetTabBarSize(__arg0, size);
        }

        /// <summary>Get the number of tabs</summary>
        /// <param name="obj">pointer to a tabview widget</param>
        /// <returns>the number of tabs</returns>
        public static uint LvTabviewGetTabCount(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTabviewGetTabCount(__arg0);
            return ___ret;
        }

        /// <summary>Get the current tab's index</summary>
        /// <param name="obj">pointer to a tabview widget</param>
        /// <returns>the zero based indoex of the current tab</returns>
        public static uint LvTabviewGetTabActive(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTabviewGetTabActive(__arg0);
            return ___ret;
        }

        /// <summary>Get the widget where the container of each tab is created</summary>
        /// <param name="obj">pointer to a tabview widget</param>
        /// <returns>the main container widget</returns>
        public static global::lvgl.LvObjT LvTabviewGetContent(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTabviewGetContent(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the tab bar where the buttons are created</summary>
        /// <param name="obj">pointer to a tabview widget</param>
        /// <returns>the tabbar</returns>
        public static global::lvgl.LvObjT LvTabviewGetTabBar(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTabviewGetTabBar(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::lvgl.LvObjClassT LvTabviewClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_tabview_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvTileviewT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal global::lvgl.LvObjT.__Internal obj;
            internal __IntPtr tile_act;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_tileview_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTileviewT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTileviewT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvTileviewT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvTileviewT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvTileviewT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvTileviewT(native.ToPointer(), skipVTables);
        }

        internal static LvTileviewT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvTileviewT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvTileviewT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvTileviewT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvTileviewT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvTileviewT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvTileviewT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTileviewT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvTileviewT(global::lvgl.LvTileviewT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTileviewT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvTileviewT.__Internal*) __Instance) = *((global::lvgl.LvTileviewT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvObjT TileAct
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->tile_act, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->tile_act = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class LvTileviewTileT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal global::lvgl.LvObjT.__Internal obj;
            internal byte dir;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_tileview_tile_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTileviewTileT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvTileviewTileT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvTileviewTileT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvTileviewTileT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvTileviewTileT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvTileviewTileT(native.ToPointer(), skipVTables);
        }

        internal static LvTileviewTileT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvTileviewTileT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvTileviewTileT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvTileviewTileT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvTileviewTileT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvTileviewTileT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvTileviewTileT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTileviewTileT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvTileviewTileT(global::lvgl.LvTileviewTileT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvTileviewTileT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvTileviewTileT.__Internal*) __Instance) = *((global::lvgl.LvTileviewTileT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }

        public byte Dir
        {
            get
            {
                return ((__Internal*)__Instance)->dir;
            }

            set
            {
                ((__Internal*)__Instance)->dir = value;
            }
        }
    }

    public unsafe partial class lv_tileview
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tileview_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTileviewCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tileview_add_tile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTileviewAddTile(__IntPtr tv, byte col_id, byte row_id, byte dir);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tileview_set_tile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTileviewSetTile(__IntPtr tv, __IntPtr tile_obj, global::lvgl.LvAnimEnableT anim_en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tileview_set_tile_by_index", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTileviewSetTileByIndex(__IntPtr tv, uint col_id, uint row_id, global::lvgl.LvAnimEnableT anim_en);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tileview_get_tile_active", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTileviewGetTileActive(__IntPtr obj);
        }

        /// <summary>Create a Tileview object</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new tileview</param>
        /// <returns>pointer to the created tileview</returns>
        public static global::lvgl.LvObjT LvTileviewCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvTileviewCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::lvgl.LvObjT LvTileviewAddTile(global::lvgl.LvObjT tv, byte col_id, byte row_id, byte dir)
        {
            var __arg0 = tv is null ? __IntPtr.Zero : tv.__Instance;
            var ___ret = __Internal.LvTileviewAddTile(__arg0, col_id, row_id, dir);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static void LvTileviewSetTile(global::lvgl.LvObjT tv, global::lvgl.LvObjT tile_obj, global::lvgl.LvAnimEnableT anim_en)
        {
            var __arg0 = tv is null ? __IntPtr.Zero : tv.__Instance;
            var __arg1 = tile_obj is null ? __IntPtr.Zero : tile_obj.__Instance;
            __Internal.LvTileviewSetTile(__arg0, __arg1, anim_en);
        }

        public static void LvTileviewSetTileByIndex(global::lvgl.LvObjT tv, uint col_id, uint row_id, global::lvgl.LvAnimEnableT anim_en)
        {
            var __arg0 = tv is null ? __IntPtr.Zero : tv.__Instance;
            __Internal.LvTileviewSetTileByIndex(__arg0, col_id, row_id, anim_en);
        }

        public static global::lvgl.LvObjT LvTileviewGetTileActive(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvTileviewGetTileActive(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::lvgl.LvObjClassT LvTileviewClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_tileview_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }

        public static global::lvgl.LvObjClassT LvTileviewTileClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_tileview_tile_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvWinT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal global::lvgl.LvObjT.__Internal obj;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_win_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvWinT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvWinT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvWinT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvWinT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvWinT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvWinT(native.ToPointer(), skipVTables);
        }

        internal static LvWinT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvWinT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvWinT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvWinT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvWinT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvWinT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvWinT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvWinT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvWinT(global::lvgl.LvWinT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvWinT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvWinT.__Internal*) __Instance) = *((global::lvgl.LvWinT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvObjT Obj
        {
            get
            {
                return global::lvgl.LvObjT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->obj));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->obj = *(global::lvgl.LvObjT.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class lv_win
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_win_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvWinCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_win_add_title", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvWinAddTitle(__IntPtr win, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string txt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_win_add_button", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvWinAddButton(__IntPtr win, __IntPtr icon, int btn_w);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_win_get_header", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvWinGetHeader(__IntPtr win);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_win_get_content", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvWinGetContent(__IntPtr win);
        }

        /// <summary>
        /// <para>********************</para>
        /// <para>GLOBAL PROTOTYPES</para>
        /// <para>********************</para>
        /// </summary>
        public static global::lvgl.LvObjT LvWinCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvWinCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::lvgl.LvObjT LvWinAddTitle(global::lvgl.LvObjT win, string txt)
        {
            var __arg0 = win is null ? __IntPtr.Zero : win.__Instance;
            var ___ret = __Internal.LvWinAddTitle(__arg0, txt);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::lvgl.LvObjT LvWinAddButton(global::lvgl.LvObjT win, __IntPtr icon, int btn_w)
        {
            var __arg0 = win is null ? __IntPtr.Zero : win.__Instance;
            var ___ret = __Internal.LvWinAddButton(__arg0, icon, btn_w);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::lvgl.LvObjT LvWinGetHeader(global::lvgl.LvObjT win)
        {
            var __arg0 = win is null ? __IntPtr.Zero : win.__Instance;
            var ___ret = __Internal.LvWinGetHeader(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::lvgl.LvObjT LvWinGetContent(global::lvgl.LvObjT win)
        {
            var __arg0 = win is null ? __IntPtr.Zero : win.__Instance;
            var ___ret = __Internal.LvWinGetContent(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::lvgl.LvObjClassT LvWinClass
        {
            get
            {
                var __ptr = (global::lvgl.LvObjClassT.__Internal*)global::lvgl.__Symbols.lvgl._lv_win_class;
                return global::lvgl.LvObjClassT.__CreateInstance(new __IntPtr(__ptr));
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvSysmonBackendDataT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 80)]
        public partial struct __Internal
        {
            internal global::lvgl.LvSubjectT.__Internal subject;
            internal __IntPtr timer;
            internal byte inited;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_sysmon_backend_data_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvSysmonBackendDataT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvSysmonBackendDataT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvSysmonBackendDataT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvSysmonBackendDataT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvSysmonBackendDataT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvSysmonBackendDataT(native.ToPointer(), skipVTables);
        }

        internal static LvSysmonBackendDataT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvSysmonBackendDataT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvSysmonBackendDataT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvSysmonBackendDataT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvSysmonBackendDataT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvSysmonBackendDataT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvSysmonBackendDataT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvSysmonBackendDataT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvSysmonBackendDataT(global::lvgl.LvSysmonBackendDataT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvSysmonBackendDataT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvSysmonBackendDataT.__Internal*) __Instance) = *((global::lvgl.LvSysmonBackendDataT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvSubjectT Subject
        {
            get
            {
                return global::lvgl.LvSubjectT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->subject));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->subject = *(global::lvgl.LvSubjectT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvTimerT Timer
        {
            get
            {
                var __result0 = global::lvgl.LvTimerT.__GetOrCreateInstance(((__Internal*)__Instance)->timer, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->timer = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public bool Inited
        {
            get
            {
                return ((__Internal*)__Instance)->inited != 0;
            }

            set
            {
                ((__Internal*)__Instance)->inited = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class lv_sysmon
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_sysmon_create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvSysmonCreate(__IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_sysmon_set_refr_period", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSysmonSetRefrPeriod(__IntPtr obj, uint period);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_sysmon_builtin_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSysmonBuiltinInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_sysmon_builtin_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSysmonBuiltinDeinit();
        }

        /// <summary>Create a system monitor object.</summary>
        /// <param name="parent">pointer to an object, it will be the parent of the new system monitor</param>
        /// <returns>pointer to the new system monitor object</returns>
        public static global::lvgl.LvObjT LvSysmonCreate(global::lvgl.LvObjT parent)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.LvSysmonCreate(__arg0);
            var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the refresh period of the system monitor object</summary>
        /// <param name="obj">pointer to a system monitor object</param>
        /// <param name="period">the refresh period in milliseconds</param>
        public static void LvSysmonSetRefrPeriod(global::lvgl.LvObjT obj, uint period)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSysmonSetRefrPeriod(__arg0, period);
        }

        /// <summary>Initialize built-in system monitor, such as performance and memory monitor.</summary>
        public static void LvSysmonBuiltinInit()
        {
            __Internal.LvSysmonBuiltinInit();
        }

        /// <summary>DeInitialize built-in system monitor, such as performance and memory monitor.</summary>
        public static void LvSysmonBuiltinDeinit()
        {
            __Internal.LvSysmonBuiltinDeinit();
        }
    }

    public enum LvSubjectTypeT
    {
        /// <summary>indicates subject not initialized yet</summary>
        LV_SUBJECT_TYPE_INVALID = 0,
        /// <summary>a null value like None or NILt</summary>
        LV_SUBJECT_TYPE_NONE = 1,
        /// <summary>an int32_t</summary>
        LV_SUBJECT_TYPE_INT = 2,
        /// <summary>a void pointer</summary>
        LV_SUBJECT_TYPE_POINTER = 3,
        /// <summary>an lv_color_t</summary>
        LV_SUBJECT_TYPE_COLOR = 4,
        /// <summary>an array of subjects</summary>
        LV_SUBJECT_TYPE_GROUP = 5,
        /// <summary>a char pointer</summary>
        LV_SUBJECT_TYPE_STRING = 6
    }

    /// <summary>A common type to handle all the various observable types in the same way</summary>
    /// <summary>The subject (an observable value)</summary>
    /// <summary>Callback called when the observed value changes</summary>
    /// <param name="observer">pointer to the observer of the callback</param>
    /// <param name="subject">pointer to the subject of the observer</param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvObserverCbT(__IntPtr observer, __IntPtr subject);

    /// <summary>A common type to handle all the various observable types in the same way</summary>
    public unsafe partial struct LvSubjectValueT
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int num;

            [FieldOffset(0)]
            internal __IntPtr pointer;

            [FieldOffset(0)]
            internal global::lvgl.LvColorT.__Internal color;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_subject_value_t@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        private LvSubjectValueT.__Internal __instance;
        internal ref LvSubjectValueT.__Internal __Instance => ref __instance;

        internal static LvSubjectValueT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new LvSubjectValueT(native.ToPointer(), skipVTables);
        }

        internal static LvSubjectValueT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvSubjectValueT(native, skipVTables);
        }

        private LvSubjectValueT(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private LvSubjectValueT(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::lvgl.LvSubjectValueT.__Internal*) native;
        }

        public LvSubjectValueT(global::lvgl.LvSubjectValueT _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        /// <summary>Integer number (opacity, enums, booleans or &quot;normal&quot; numbers)</summary>
        public int Num
        {
            get
            {
                return __instance.num;
            }

            set
            {
                __instance.num = value;
            }
        }

        /// <summary>Constant pointer  (string buffer, format string, font, cone text, etc)</summary>
        public __IntPtr Pointer
        {
            get
            {
                return __instance.pointer;
            }
        }

        /// <summary>Color</summary>
        public global::lvgl.LvColorT Color
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(__instance.color);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>The subject (an observable value)</summary>
    public unsafe partial class LvSubjectT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvLlT.__Internal subs_ll;

            [FieldOffset(24)]
            internal uint type;

            [FieldOffset(24)]
            internal uint size;

            [FieldOffset(32)]
            internal global::lvgl.LvSubjectValueT.__Internal value;

            [FieldOffset(40)]
            internal global::lvgl.LvSubjectValueT.__Internal prev_value;

            [FieldOffset(48)]
            internal uint notify_restart_query;

            [FieldOffset(56)]
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_subject_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvSubjectT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvSubjectT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvSubjectT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvSubjectT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvSubjectT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvSubjectT(native.ToPointer(), skipVTables);
        }

        internal static LvSubjectT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvSubjectT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvSubjectT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvSubjectT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvSubjectT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvSubjectT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvSubjectT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvSubjectT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvSubjectT(global::lvgl.LvSubjectT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvSubjectT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvSubjectT.__Internal*) __Instance) = *((global::lvgl.LvSubjectT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Subscribers</summary>
        public global::lvgl.LvLlT SubsLl
        {
            get
            {
                return global::lvgl.LvLlT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->subs_ll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->subs_ll = *(global::lvgl.LvLlT.__Internal*) value.__Instance;
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>Might be used to store a size related to `type`</summary>
        public uint Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }

        /// <summary>Actual value</summary>
        public global::lvgl.LvSubjectValueT Value
        {
            get
            {
                return global::lvgl.LvSubjectValueT.__CreateInstance(((__Internal*)__Instance)->value);
            }

            set
            {
                ((__Internal*)__Instance)->value = value.__Instance;
            }
        }

        /// <summary>Previous value</summary>
        public global::lvgl.LvSubjectValueT PrevValue
        {
            get
            {
                return global::lvgl.LvSubjectValueT.__CreateInstance(((__Internal*)__Instance)->prev_value);
            }

            set
            {
                ((__Internal*)__Instance)->prev_value = value.__Instance;
            }
        }

        /// <summary>If an observer deleted start notifying from the beginning.</summary>
        public uint NotifyRestartQuery
        {
            get
            {
                return ((__Internal*)__Instance)->notify_restart_query;
            }

            set
            {
                ((__Internal*)__Instance)->notify_restart_query = value;
            }
        }

        /// <summary>Additional parameter, can be used freely by the user</summary>
        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvObserverT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal __IntPtr subject;

            [FieldOffset(8)]
            internal __IntPtr cb;

            [FieldOffset(16)]
            internal __IntPtr target;

            [FieldOffset(24)]
            internal __IntPtr user_data;

            [FieldOffset(32)]
            internal uint auto_free_user_data;

            [FieldOffset(32)]
            internal uint notified;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_observer_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvObserverT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvObserverT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvObserverT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvObserverT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvObserverT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvObserverT(native.ToPointer(), skipVTables);
        }

        internal static LvObserverT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvObserverT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvObserverT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvObserverT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvObserverT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvObserverT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvObserverT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvObserverT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvObserverT(global::lvgl.LvObserverT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvObserverT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvObserverT.__Internal*) __Instance) = *((global::lvgl.LvObserverT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The observed value</summary>
        public global::lvgl.LvSubjectT Subject
        {
            get
            {
                var __result0 = global::lvgl.LvSubjectT.__GetOrCreateInstance(((__Internal*)__Instance)->subject, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->subject = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Callback that should be called when the value changes</summary>
        public global::lvgl.LvObserverCbT Cb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvObserverCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvObserverCbT));
            }

            set
            {
                ((__Internal*)__Instance)->cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>A target for the observer, e.g. a widget or style</summary>
        public __IntPtr Target
        {
            get
            {
                return ((__Internal*)__Instance)->target;
            }

            set
            {
                ((__Internal*)__Instance)->target = (__IntPtr) value;
            }
        }

        /// <summary>Additional parameter supplied when subscribing</summary>
        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }

        /// <summary>Automatically free user data when the observer is removed</summary>
        public uint AutoFreeUserData
        {
            get
            {
                return ((__Internal*)__Instance)->auto_free_user_data;
            }

            set
            {
                ((__Internal*)__Instance)->auto_free_user_data = value;
            }
        }

        /// <summary>Mark if this observer was already notified</summary>
        public uint Notified
        {
            get
            {
                return ((__Internal*)__Instance)->notified;
            }

            set
            {
                ((__Internal*)__Instance)->notified = value;
            }
        }
    }

    public unsafe partial class lv_observer
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_init_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSubjectInitInt(__IntPtr subject, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_set_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSubjectSetInt(__IntPtr subject, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_get_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvSubjectGetInt(__IntPtr subject);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_get_previous_int", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvSubjectGetPreviousInt(__IntPtr subject);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_init_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSubjectInitString(__IntPtr subject, sbyte* buf, sbyte* prev_buf, ulong size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_copy_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSubjectCopyString(__IntPtr subject, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string buf);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_get_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvSubjectGetString(__IntPtr subject);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_get_previous_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvSubjectGetPreviousString(__IntPtr subject);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_init_pointer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSubjectInitPointer(__IntPtr subject, __IntPtr value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_set_pointer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSubjectSetPointer(__IntPtr subject, __IntPtr ptr);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_get_pointer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvSubjectGetPointer(__IntPtr subject);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_get_previous_pointer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvSubjectGetPreviousPointer(__IntPtr subject);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_init_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSubjectInitColor(__IntPtr subject, __IntPtr color);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_set_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSubjectSetColor(__IntPtr subject, __IntPtr color);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_get_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSubjectGetColor(__IntPtr @return, __IntPtr subject);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_get_previous_color", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSubjectGetPreviousColor(__IntPtr @return, __IntPtr subject);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_init_group", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSubjectInitGroup(__IntPtr subject, __IntPtr[] list, uint list_len);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_get_group_element", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvSubjectGetGroupElement(__IntPtr subject, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_add_observer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvSubjectAddObserver(__IntPtr subject, __IntPtr observer_cb, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_add_observer_obj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvSubjectAddObserverObj(__IntPtr subject, __IntPtr observer_cb, __IntPtr obj, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_add_observer_with_target", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvSubjectAddObserverWithTarget(__IntPtr subject, __IntPtr cb, __IntPtr target, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_observer_remove", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvObserverRemove(__IntPtr observer);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_remove_all_obj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSubjectRemoveAllObj(__IntPtr subject, __IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_observer_get_target", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObserverGetTarget(__IntPtr observer);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_subject_notify", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvSubjectNotify(__IntPtr subject);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_bind_flag_if_eq", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjBindFlagIfEq(__IntPtr obj, __IntPtr subject, uint flag, int ref_value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_bind_flag_if_not_eq", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjBindFlagIfNotEq(__IntPtr obj, __IntPtr subject, uint flag, int ref_value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_bind_state_if_eq", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjBindStateIfEq(__IntPtr obj, __IntPtr subject, ushort state, int ref_value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_bind_state_if_not_eq", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjBindStateIfNotEq(__IntPtr obj, __IntPtr subject, ushort state, int ref_value);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_obj_bind_checked", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvObjBindChecked(__IntPtr obj, __IntPtr subject);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_label_bind_text", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvLabelBindText(__IntPtr obj, __IntPtr subject, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_arc_bind_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvArcBindValue(__IntPtr obj, __IntPtr subject);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_slider_bind_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvSliderBindValue(__IntPtr obj, __IntPtr subject);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_roller_bind_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvRollerBindValue(__IntPtr obj, __IntPtr subject);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_dropdown_bind_value", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvDropdownBindValue(__IntPtr obj, __IntPtr subject);
        }

        /// <summary>Initialize an integer type subject</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <param name="value">initial value</param>
        public static void LvSubjectInitInt(global::lvgl.LvSubjectT subject, int value)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            __Internal.LvSubjectInitInt(__arg0, value);
        }

        /// <summary>Set the value of an integer subject. It will notify all the observers as well.</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <param name="value">the new value</param>
        public static void LvSubjectSetInt(global::lvgl.LvSubjectT subject, int value)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            __Internal.LvSubjectSetInt(__arg0, value);
        }

        /// <summary>Get the current value of an integer subject</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <returns>the current value</returns>
        public static int LvSubjectGetInt(global::lvgl.LvSubjectT subject)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = __Internal.LvSubjectGetInt(__arg0);
            return ___ret;
        }

        /// <summary>Get the previous value of an integer subject</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <returns>the current value</returns>
        public static int LvSubjectGetPreviousInt(global::lvgl.LvSubjectT subject)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = __Internal.LvSubjectGetPreviousInt(__arg0);
            return ___ret;
        }

        /// <summary>Initialize a string type subject</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <param name="buf">pointer to a buffer to store the string</param>
        /// <param name="prev_buf">pointer to a buffer to store the previous string, can be NULL if not used</param>
        /// <param name="size">size of the buffer</param>
        /// <param name="value">initial value as a string, e.g. &quot;hello&quot;</param>
        /// <remarks>the string subject stores the whole string, not only a pointer</remarks>
        public static void LvSubjectInitString(global::lvgl.LvSubjectT subject, sbyte* buf, sbyte* prev_buf, ulong size, string value)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            __Internal.LvSubjectInitString(__arg0, buf, prev_buf, size, value);
        }

        /// <summary>Copy a string to a subject. It will notify all the observers as well.</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <param name="buf">the new string</param>
        public static void LvSubjectCopyString(global::lvgl.LvSubjectT subject, string buf)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            __Internal.LvSubjectCopyString(__arg0, buf);
        }

        /// <summary>Get the current value of an string subject</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <returns>pointer to the buffer containing the current value</returns>
        public static string LvSubjectGetString(global::lvgl.LvSubjectT subject)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = __Internal.LvSubjectGetString(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the previous value of an string subject</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <returns>pointer to the buffer containing the current value</returns>
        /// <remarks>
        /// <para>NULL will be returned if NULL was passed in `lv_subject_init_string()`</para>
        /// <para>as `prev_buf`</para>
        /// </remarks>
        public static string LvSubjectGetPreviousString(global::lvgl.LvSubjectT subject)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = __Internal.LvSubjectGetPreviousString(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Initialize an pointer type subject</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <param name="value">initial value</param>
        public static void LvSubjectInitPointer(global::lvgl.LvSubjectT subject, __IntPtr value)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            __Internal.LvSubjectInitPointer(__arg0, value);
        }

        /// <summary>Set the value of a pointer subject. It will notify all the observers as well.</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <param name="value">the new value</param>
        public static void LvSubjectSetPointer(global::lvgl.LvSubjectT subject, __IntPtr ptr)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            __Internal.LvSubjectSetPointer(__arg0, ptr);
        }

        /// <summary>Get the current value of a pointer subject</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <returns>the current value</returns>
        public static __IntPtr LvSubjectGetPointer(global::lvgl.LvSubjectT subject)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = __Internal.LvSubjectGetPointer(__arg0);
            return ___ret;
        }

        /// <summary>Get the previous value of a pointer subject</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <returns>the current value</returns>
        public static __IntPtr LvSubjectGetPreviousPointer(global::lvgl.LvSubjectT subject)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = __Internal.LvSubjectGetPreviousPointer(__arg0);
            return ___ret;
        }

        /// <summary>Initialize an color type subject</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <param name="value">initial value</param>
        public static void LvSubjectInitColor(global::lvgl.LvSubjectT subject, global::lvgl.LvColorT color)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg1 = color.__Instance;
            __Internal.LvSubjectInitColor(__arg0, __arg1);
        }

        /// <summary>Set the value of a color subject. It will notify all the observers as well.</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <param name="value">the new value</param>
        public static void LvSubjectSetColor(global::lvgl.LvSubjectT subject, global::lvgl.LvColorT color)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            if (ReferenceEquals(color, null))
                throw new global::System.ArgumentNullException("color", "Cannot be null because it is passed by value.");
            var __arg1 = color.__Instance;
            __Internal.LvSubjectSetColor(__arg0, __arg1);
        }

        /// <summary>Get the current value of a color subject</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <returns>the current value</returns>
        public static global::lvgl.LvColorT LvSubjectGetColor(global::lvgl.LvSubjectT subject)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = new global::lvgl.LvColorT.__Internal();
            __Internal.LvSubjectGetColor(new IntPtr(&___ret), __arg0);
            return global::lvgl.LvColorT.__CreateInstance(___ret);
        }

        /// <summary>Get the previous value of a color subject</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <returns>the current value</returns>
        public static global::lvgl.LvColorT LvSubjectGetPreviousColor(global::lvgl.LvSubjectT subject)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = new global::lvgl.LvColorT.__Internal();
            __Internal.LvSubjectGetPreviousColor(new IntPtr(&___ret), __arg0);
            return global::lvgl.LvColorT.__CreateInstance(___ret);
        }

        /// <summary>Initialize a subject group</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <param name="list">list of other subject addresses, any of these changes `subject` will be notified</param>
        /// <param name="list_len">number of elements in `list`</param>
        public static void LvSubjectInitGroup(global::lvgl.LvSubjectT subject, global::lvgl.LvSubjectT[] list, uint list_len)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            __IntPtr[] __list;
            if (list == null)
                __list = null;
            else
            {
                __list = new __IntPtr[list.Length];
                for (int i = 0; i < __list.Length; i++)
                {
                    var __element = list[i];
                    __list[i] = __element is null ? __IntPtr.Zero : __element.__Instance;
                }
            }
            var __arg1 = __list;
            __Internal.LvSubjectInitGroup(__arg0, __arg1, list_len);
        }

        /// <summary>Get an element from the subject group's list</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <param name="index">index of the element to get</param>
        /// <returns>pointer a subject from the list, or NULL if the index is out of bounds</returns>
        public static global::lvgl.LvSubjectT LvSubjectGetGroupElement(global::lvgl.LvSubjectT subject, int index)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = __Internal.LvSubjectGetGroupElement(__arg0, index);
            var __result0 = global::lvgl.LvSubjectT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Add an observer to a subject. When the subject changes `observer_cb` will be called.</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <param name="observer_cb">the callback to call</param>
        /// <param name="user_data">optional user data</param>
        /// <returns>pointer to the created observer</returns>
        public static global::lvgl.LvObserverT LvSubjectAddObserver(global::lvgl.LvSubjectT subject, global::lvgl.LvObserverCbT observer_cb, __IntPtr user_data)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var __arg1 = observer_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(observer_cb);
            var ___ret = __Internal.LvSubjectAddObserver(__arg0, __arg1, user_data);
            var __result0 = global::lvgl.LvObserverT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Add an observer to a subject for an object.</para>
        /// <para>When the object is deleted, it will be removed from the subject automatically.</para>
        /// </summary>
        /// <param name="subject">pointer to the subject</param>
        /// <param name="observer_cb">the callback to call</param>
        /// <param name="obj">pointer to an object</param>
        /// <param name="user_data">optional user data</param>
        /// <returns>pointer to the created observer</returns>
        public static global::lvgl.LvObserverT LvSubjectAddObserverObj(global::lvgl.LvSubjectT subject, global::lvgl.LvObserverCbT observer_cb, global::lvgl.LvObjT obj, __IntPtr user_data)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var __arg1 = observer_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(observer_cb);
            var __arg2 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvSubjectAddObserverObj(__arg0, __arg1, __arg2, user_data);
            var __result0 = global::lvgl.LvObserverT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Add an observer to a subject and also save a target.</summary>
        /// <param name="subject">pointer to the subject</param>
        /// <param name="observer_cb">the callback to call</param>
        /// <param name="target">pointer to any data</param>
        /// <param name="user_data">optional user data</param>
        /// <returns>pointer to the created observer</returns>
        public static global::lvgl.LvObserverT LvSubjectAddObserverWithTarget(global::lvgl.LvSubjectT subject, global::lvgl.LvObserverCbT cb, __IntPtr target, __IntPtr user_data)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            var ___ret = __Internal.LvSubjectAddObserverWithTarget(__arg0, __arg1, target, user_data);
            var __result0 = global::lvgl.LvObserverT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Remove an observer from its subject</summary>
        /// <param name="observer">pointer to an observer</param>
        public static void LvObserverRemove(global::lvgl.LvObserverT observer)
        {
            var __arg0 = observer is null ? __IntPtr.Zero : observer.__Instance;
            __Internal.LvObserverRemove(__arg0);
        }

        /// <summary>Remove all observers from their subject related to an object</summary>
        /// <param name="observer">pointer to an observer</param>
        /// <param name="obj">pointer to an object</param>
        public static void LvSubjectRemoveAllObj(global::lvgl.LvSubjectT subject, global::lvgl.LvObjT obj)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var __arg1 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvSubjectRemoveAllObj(__arg0, __arg1);
        }

        /// <summary>Get the target of an observer</summary>
        /// <param name="observer">pointer to an observer</param>
        /// <returns>pointer to the saved target</returns>
        public static __IntPtr LvObserverGetTarget(global::lvgl.LvObserverT observer)
        {
            var __arg0 = observer is null ? __IntPtr.Zero : observer.__Instance;
            var ___ret = __Internal.LvObserverGetTarget(__arg0);
            return ___ret;
        }

        /// <summary>Notify all observers of subject</summary>
        /// <param name="subject">pointer to a subject</param>
        public static void LvSubjectNotify(global::lvgl.LvSubjectT subject)
        {
            var __arg0 = subject is null ? __IntPtr.Zero : subject.__Instance;
            __Internal.LvSubjectNotify(__arg0);
        }

        /// <summary>Set an object flag if an integer subject's value is equal to a reference value, clear the flag otherwise</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="subject">pointer to a subject</param>
        /// <param name="flag">a flag to set or clear (e.g. `LV_OBJ_FLAG_HIDDEN`)</param>
        /// <param name="ref_value">a reference value to compare the subject's value with</param>
        /// <returns>pointer to the created observer</returns>
        public static global::lvgl.LvObserverT LvObjBindFlagIfEq(global::lvgl.LvObjT obj, global::lvgl.LvSubjectT subject, uint flag, int ref_value)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = __Internal.LvObjBindFlagIfEq(__arg0, __arg1, flag, ref_value);
            var __result0 = global::lvgl.LvObserverT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set an object flag if an integer subject's value is not equal to a reference value, clear the flag otherwise</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="subject">pointer to a subject</param>
        /// <param name="flag">a flag to set or clear (e.g. `LV_OBJ_FLAG_HIDDEN`)</param>
        /// <param name="ref_value">a reference value to compare the subject's value with</param>
        /// <returns>pointer to the created observer</returns>
        public static global::lvgl.LvObserverT LvObjBindFlagIfNotEq(global::lvgl.LvObjT obj, global::lvgl.LvSubjectT subject, uint flag, int ref_value)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = __Internal.LvObjBindFlagIfNotEq(__arg0, __arg1, flag, ref_value);
            var __result0 = global::lvgl.LvObserverT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set an object state if an integer subject's value is equal to a reference value, clear the flag otherwise</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="subject">pointer to a subject</param>
        /// <param name="flag">a state to set or clear (e.g. `LV_STATE_CHECKED`)</param>
        /// <param name="ref_value">a reference value to compare the subject's value with</param>
        /// <returns>pointer to the created observer</returns>
        public static global::lvgl.LvObserverT LvObjBindStateIfEq(global::lvgl.LvObjT obj, global::lvgl.LvSubjectT subject, ushort state, int ref_value)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = __Internal.LvObjBindStateIfEq(__arg0, __arg1, state, ref_value);
            var __result0 = global::lvgl.LvObserverT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set an object state if an integer subject's value is not equal to a reference value, clear the flag otherwise</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="subject">pointer to a subject</param>
        /// <param name="flag">a state to set or clear (e.g. `LV_STATE_CHECKED`)</param>
        /// <param name="ref_value">a reference value to compare the subject's value with</param>
        /// <returns>pointer to the created observer</returns>
        public static global::lvgl.LvObserverT LvObjBindStateIfNotEq(global::lvgl.LvObjT obj, global::lvgl.LvSubjectT subject, ushort state, int ref_value)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = __Internal.LvObjBindStateIfNotEq(__arg0, __arg1, state, ref_value);
            var __result0 = global::lvgl.LvObserverT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set an integer subject to 1 when an object is checked and set it 0 when unchecked.</summary>
        /// <param name="obj">pointer to an object</param>
        /// <param name="subject">pointer to a subject</param>
        /// <returns>pointer to the created observer</returns>
        /// <remarks>Ensure the object's `LV_OBJ_FLAG_CHECKABLE` flag is set</remarks>
        public static global::lvgl.LvObserverT LvObjBindChecked(global::lvgl.LvObjT obj, global::lvgl.LvSubjectT subject)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = __Internal.LvObjBindChecked(__arg0, __arg1);
            var __result0 = global::lvgl.LvObserverT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Bind an integer, string, or pointer subject to a label.</summary>
        /// <param name="obj">pointer to a label</param>
        /// <param name="subject">pointer to a subject</param>
        /// <param name="fmt">
        /// <para>an optional format string with 1 format specifier (e.g. &quot;%d &#176;C&quot;)</para>
        /// <para>or NULL to bind the value directly.</para>
        /// </param>
        /// <returns>pointer to the created observer</returns>
        /// <remarks>
        /// <para>fmt == NULL can be used only with string and pointer subjects.</para>
        /// <para>if the subject is a pointer must point to a `\0` terminated string.</para>
        /// </remarks>
        public static global::lvgl.LvObserverT LvLabelBindText(global::lvgl.LvObjT obj, global::lvgl.LvSubjectT subject, string fmt)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = __Internal.LvLabelBindText(__arg0, __arg1, fmt);
            var __result0 = global::lvgl.LvObserverT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Bind an integer subject to an arc's value</summary>
        /// <param name="obj">pointer to an arc</param>
        /// <param name="subject">pointer to a subject</param>
        /// <returns>pointer to the created observer</returns>
        public static global::lvgl.LvObserverT LvArcBindValue(global::lvgl.LvObjT obj, global::lvgl.LvSubjectT subject)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = __Internal.LvArcBindValue(__arg0, __arg1);
            var __result0 = global::lvgl.LvObserverT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Bind an integer subject to a slider's value</summary>
        /// <param name="obj">pointer to a slider</param>
        /// <param name="subject">pointer to a subject</param>
        /// <returns>pointer to the created observer</returns>
        public static global::lvgl.LvObserverT LvSliderBindValue(global::lvgl.LvObjT obj, global::lvgl.LvSubjectT subject)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = __Internal.LvSliderBindValue(__arg0, __arg1);
            var __result0 = global::lvgl.LvObserverT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Bind an integer subject to a roller's value</summary>
        /// <param name="obj">pointer to a roller</param>
        /// <param name="subject">pointer to a subject</param>
        /// <returns>pointer to the created observer</returns>
        public static global::lvgl.LvObserverT LvRollerBindValue(global::lvgl.LvObjT obj, global::lvgl.LvSubjectT subject)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = __Internal.LvRollerBindValue(__arg0, __arg1);
            var __result0 = global::lvgl.LvObserverT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Bind an integer subject to a dropdown's value</summary>
        /// <param name="obj">pointer to a drop down</param>
        /// <param name="subject">pointer to a subject</param>
        /// <returns>pointer to the created observer</returns>
        public static global::lvgl.LvObserverT LvDropdownBindValue(global::lvgl.LvObjT obj, global::lvgl.LvSubjectT subject)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var __arg1 = subject is null ? __IntPtr.Zero : subject.__Instance;
            var ___ret = __Internal.LvDropdownBindValue(__arg0, __arg1);
            var __result0 = global::lvgl.LvObserverT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class lv_bin_decoder
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_bin_decoder_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvBinDecoderInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_bin_decoder_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvBinDecoderInfo(__IntPtr decoder, __IntPtr src, __IntPtr header);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_bin_decoder_get_area", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvBinDecoderGetArea(__IntPtr decoder, __IntPtr dsc, __IntPtr full_area, __IntPtr decoded_area);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_bin_decoder_open", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvBinDecoderOpen(__IntPtr decoder, __IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_bin_decoder_close", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvBinDecoderClose(__IntPtr decoder, __IntPtr dsc);
        }

        /// <summary>Initialize the binary image decoder module</summary>
        public static void LvBinDecoderInit()
        {
            __Internal.LvBinDecoderInit();
        }

        /// <summary>Get info about a lvgl binary image</summary>
        /// <param name="decoder">the decoder where this function belongs</param>
        /// <param name="src">the image source: pointer to an `lv_image_dsc_t` variable, a file path or a symbol</param>
        /// <param name="header">store the image data here</param>
        /// <returns>LV_RESULT_OK: the info is successfully stored in `header`; LV_RESULT_INVALID: unknown format or other error.</returns>
        public static byte LvBinDecoderInfo(global::lvgl.LvImageDecoderT decoder, __IntPtr src, global::lvgl.LvImageHeaderT header)
        {
            var __arg0 = decoder is null ? __IntPtr.Zero : decoder.__Instance;
            var __arg2 = header is null ? __IntPtr.Zero : header.__Instance;
            var ___ret = __Internal.LvBinDecoderInfo(__arg0, src, __arg2);
            return ___ret;
        }

        public static byte LvBinDecoderGetArea(global::lvgl.LvImageDecoderT decoder, global::lvgl.LvImageDecoderDscT dsc, global::lvgl.LvAreaT full_area, global::lvgl.LvAreaT decoded_area)
        {
            var __arg0 = decoder is null ? __IntPtr.Zero : decoder.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var __arg2 = full_area is null ? __IntPtr.Zero : full_area.__Instance;
            var __arg3 = decoded_area is null ? __IntPtr.Zero : decoded_area.__Instance;
            var ___ret = __Internal.LvBinDecoderGetArea(__arg0, __arg1, __arg2, __arg3);
            return ___ret;
        }

        /// <summary>Open a lvgl binary image</summary>
        /// <param name="decoder">the decoder where this function belongs</param>
        /// <param name="dsc">pointer to decoder descriptor. `src`, `style` are already initialized in it.</param>
        /// <returns>LV_RESULT_OK: the info is successfully stored in `header`; LV_RESULT_INVALID: unknown format or other error.</returns>
        public static byte LvBinDecoderOpen(global::lvgl.LvImageDecoderT decoder, global::lvgl.LvImageDecoderDscT dsc)
        {
            var __arg0 = decoder is null ? __IntPtr.Zero : decoder.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var ___ret = __Internal.LvBinDecoderOpen(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Close the pending decoding. Free resources etc.</summary>
        /// <param name="decoder">pointer to the decoder the function associated with</param>
        /// <param name="dsc">pointer to decoder descriptor</param>
        public static void LvBinDecoderClose(global::lvgl.LvImageDecoderT decoder, global::lvgl.LvImageDecoderDscT dsc)
        {
            var __arg0 = decoder is null ? __IntPtr.Zero : decoder.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvBinDecoderClose(__arg0, __arg1);
        }
    }

    public unsafe partial class lv_fsdrv
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_fs_win32_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvFsWin32Init();
        }

        public static void LvFsWin32Init()
        {
            __Internal.LvFsWin32Init();
        }
    }

    public unsafe partial class lv_tiny_ttf
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tiny_ttf_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTinyTtfInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tiny_ttf_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTinyTtfDeinit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tiny_ttf_create_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTinyTtfCreateData(__IntPtr data, ulong data_size, int font_size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tiny_ttf_create_data_ex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvTinyTtfCreateDataEx(__IntPtr data, ulong data_size, int font_size, ulong cache_size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tiny_ttf_set_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTinyTtfSetSize(__IntPtr font, int font_size);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_tiny_ttf_destroy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvTinyTtfDestroy(__IntPtr font);
        }

        public static void LvTinyTtfInit()
        {
            __Internal.LvTinyTtfInit();
        }

        public static void LvTinyTtfDeinit()
        {
            __Internal.LvTinyTtfDeinit();
        }

        public static global::lvgl.LvFontT LvTinyTtfCreateData(__IntPtr data, ulong data_size, int font_size)
        {
            var ___ret = __Internal.LvTinyTtfCreateData(data, data_size, font_size);
            var __result0 = global::lvgl.LvFontT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::lvgl.LvFontT LvTinyTtfCreateDataEx(__IntPtr data, ulong data_size, int font_size, ulong cache_size)
        {
            var ___ret = __Internal.LvTinyTtfCreateDataEx(data, data_size, font_size, cache_size);
            var __result0 = global::lvgl.LvFontT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static void LvTinyTtfSetSize(global::lvgl.LvFontT font, int font_size)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            __Internal.LvTinyTtfSetSize(__arg0, font_size);
        }

        public static void LvTinyTtfDestroy(global::lvgl.LvFontT font)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            __Internal.LvTinyTtfDestroy(__arg0);
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LvThemeApplyCbT(__IntPtr __0, __IntPtr __1);

    public unsafe partial class LvThemeT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal __IntPtr apply_cb;
            internal __IntPtr parent;
            internal __IntPtr user_data;
            internal __IntPtr disp;
            internal global::lvgl.LvColorT.__Internal color_primary;
            internal global::lvgl.LvColorT.__Internal color_secondary;
            internal __IntPtr font_small;
            internal __IntPtr font_normal;
            internal __IntPtr font_large;
            internal uint flags;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_theme_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvThemeT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvThemeT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvThemeT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvThemeT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvThemeT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvThemeT(native.ToPointer(), skipVTables);
        }

        internal static LvThemeT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvThemeT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvThemeT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvThemeT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvThemeT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvThemeT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvThemeT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvThemeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvThemeT(global::lvgl.LvThemeT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvThemeT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvThemeT.__Internal*) __Instance) = *((global::lvgl.LvThemeT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvThemeApplyCbT ApplyCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->apply_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvThemeApplyCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvThemeApplyCbT));
            }

            set
            {
                ((__Internal*)__Instance)->apply_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Apply the current theme's style on top of this theme.</summary>
        public global::lvgl.LvThemeT Parent
        {
            get
            {
                var __result0 = global::lvgl.LvThemeT.__GetOrCreateInstance(((__Internal*)__Instance)->parent, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->parent = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }

        public global::lvgl.LvDisplayT Disp
        {
            get
            {
                var __result0 = global::lvgl.LvDisplayT.__GetOrCreateInstance(((__Internal*)__Instance)->disp, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->disp = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvColorT ColorPrimary
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->color_primary));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->color_primary = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvColorT ColorSecondary
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->color_secondary));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->color_secondary = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvFontT FontSmall
        {
            get
            {
                var __result0 = global::lvgl.LvFontT.__GetOrCreateInstance(((__Internal*)__Instance)->font_small, false);
                return __result0;
            }
        }

        public global::lvgl.LvFontT FontNormal
        {
            get
            {
                var __result0 = global::lvgl.LvFontT.__GetOrCreateInstance(((__Internal*)__Instance)->font_normal, false);
                return __result0;
            }
        }

        public global::lvgl.LvFontT FontLarge
        {
            get
            {
                var __result0 = global::lvgl.LvFontT.__GetOrCreateInstance(((__Internal*)__Instance)->font_large, false);
                return __result0;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }
    }

    public unsafe partial class lv_theme
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_get_from_obj", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvThemeGetFromObj(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_apply", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvThemeApply(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_set_parent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvThemeSetParent(__IntPtr new_theme, __IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_set_apply_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvThemeSetApplyCb(__IntPtr theme, __IntPtr apply_cb);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_get_font_small", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvThemeGetFontSmall(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_get_font_normal", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvThemeGetFontNormal(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_get_font_large", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvThemeGetFontLarge(__IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_get_color_primary", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvThemeGetColorPrimary(__IntPtr @return, __IntPtr obj);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_get_color_secondary", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvThemeGetColorSecondary(__IntPtr @return, __IntPtr obj);
        }

        /// <summary>Get the theme assigned to the display of the object</summary>
        /// <param name="obj">pointer to a theme object</param>
        /// <returns>the theme of the object's display (can be NULL)</returns>
        public static global::lvgl.LvThemeT LvThemeGetFromObj(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvThemeGetFromObj(__arg0);
            var __result0 = global::lvgl.LvThemeT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Apply the active theme on an object</summary>
        /// <param name="obj">pointer to an object</param>
        public static void LvThemeApply(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            __Internal.LvThemeApply(__arg0);
        }

        /// <summary>
        /// <para>Set a base theme for a theme.</para>
        /// <para>The styles from the base them will be added before the styles of the current theme.</para>
        /// <para>Arbitrary long chain of themes can be created by setting base themes.</para>
        /// </summary>
        /// <param name="new_theme">pointer to theme which base should be set</param>
        /// <param name="parent">pointer to the base theme</param>
        public static void LvThemeSetParent(global::lvgl.LvThemeT new_theme, global::lvgl.LvThemeT parent)
        {
            var __arg0 = new_theme is null ? __IntPtr.Zero : new_theme.__Instance;
            var __arg1 = parent is null ? __IntPtr.Zero : parent.__Instance;
            __Internal.LvThemeSetParent(__arg0, __arg1);
        }

        /// <summary>
        /// <para>Set an apply callback for a theme.</para>
        /// <para>The apply callback is used to add styles to different objects</para>
        /// </summary>
        /// <param name="theme">pointer to theme which callback should be set</param>
        /// <param name="apply_cb">pointer to the callback</param>
        public static void LvThemeSetApplyCb(global::lvgl.LvThemeT theme, global::lvgl.LvThemeApplyCbT apply_cb)
        {
            var __arg0 = theme is null ? __IntPtr.Zero : theme.__Instance;
            var __arg1 = apply_cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(apply_cb);
            __Internal.LvThemeSetApplyCb(__arg0, __arg1);
        }

        /// <summary>Get the small font of the theme</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>pointer to the font</returns>
        public static global::lvgl.LvFontT LvThemeGetFontSmall(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvThemeGetFontSmall(__arg0);
            var __result0 = global::lvgl.LvFontT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the normal font of the theme</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>pointer to the font</returns>
        public static global::lvgl.LvFontT LvThemeGetFontNormal(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvThemeGetFontNormal(__arg0);
            var __result0 = global::lvgl.LvFontT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the subtitle font of the theme</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>pointer to the font</returns>
        public static global::lvgl.LvFontT LvThemeGetFontLarge(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = __Internal.LvThemeGetFontLarge(__arg0);
            var __result0 = global::lvgl.LvFontT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the primary color of the theme</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the color</returns>
        public static global::lvgl.LvColorT LvThemeGetColorPrimary(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = new global::lvgl.LvColorT.__Internal();
            __Internal.LvThemeGetColorPrimary(new IntPtr(&___ret), __arg0);
            return global::lvgl.LvColorT.__CreateInstance(___ret);
        }

        /// <summary>Get the secondary color of the theme</summary>
        /// <param name="obj">pointer to an object</param>
        /// <returns>the color</returns>
        public static global::lvgl.LvColorT LvThemeGetColorSecondary(global::lvgl.LvObjT obj)
        {
            var __arg0 = obj is null ? __IntPtr.Zero : obj.__Instance;
            var ___ret = new global::lvgl.LvColorT.__Internal();
            __Internal.LvThemeGetColorSecondary(new IntPtr(&___ret), __arg0);
            return global::lvgl.LvColorT.__CreateInstance(___ret);
        }
    }

    public unsafe partial class lv_theme_default
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_default_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvThemeDefaultInit(__IntPtr disp, global::lvgl.LvColorT.__Internal color_primary, global::lvgl.LvColorT.__Internal color_secondary, bool dark, __IntPtr font);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_default_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvThemeDefaultGet();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_default_is_inited", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvThemeDefaultIsInited();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_default_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvThemeDefaultDeinit();
        }

        /// <summary>Initialize the theme</summary>
        /// <param name="disp">pointer to display</param>
        /// <param name="color_primary">the primary color of the theme</param>
        /// <param name="color_secondary">the secondary color for the theme</param>
        /// <param name="font">pointer to a font to use.</param>
        /// <returns>a pointer to reference this theme later</returns>
        public static global::lvgl.LvThemeT LvThemeDefaultInit(global::lvgl.LvDisplayT disp, global::lvgl.LvColorT color_primary, global::lvgl.LvColorT color_secondary, bool dark, global::lvgl.LvFontT font)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            if (ReferenceEquals(color_primary, null))
                throw new global::System.ArgumentNullException("color_primary", "Cannot be null because it is passed by value.");
            var __arg1 = color_primary.__Instance;
            if (ReferenceEquals(color_secondary, null))
                throw new global::System.ArgumentNullException("color_secondary", "Cannot be null because it is passed by value.");
            var __arg2 = color_secondary.__Instance;
            var __arg4 = font is null ? __IntPtr.Zero : font.__Instance;
            var ___ret = __Internal.LvThemeDefaultInit(__arg0, *(global::lvgl.LvColorT.__Internal*) __arg1, *(global::lvgl.LvColorT.__Internal*) __arg2, dark, __arg4);
            var __result0 = global::lvgl.LvThemeT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get default theme</summary>
        /// <returns>a pointer to default theme, or NULL if this is not initialized</returns>
        public static global::lvgl.LvThemeT LvThemeDefaultGet()
        {
            var ___ret = __Internal.LvThemeDefaultGet();
            var __result0 = global::lvgl.LvThemeT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Check if default theme is initialized</summary>
        /// <returns>true if default theme is initialized, false otherwise</returns>
        public static bool LvThemeDefaultIsInited()
        {
            var ___ret = __Internal.LvThemeDefaultIsInited();
            return ___ret;
        }

        /// <summary>Deinitialize the default theme</summary>
        public static void LvThemeDefaultDeinit()
        {
            __Internal.LvThemeDefaultDeinit();
        }
    }

    public unsafe partial class lv_theme_mono
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_mono_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvThemeMonoInit(__IntPtr disp, bool dark_bg, __IntPtr font);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_mono_is_inited", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvThemeMonoIsInited();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_mono_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvThemeMonoDeinit();
        }

        /// <summary>Initialize the theme</summary>
        /// <param name="disp">pointer to display</param>
        /// <param name="font">pointer to a font to use.</param>
        /// <returns>a pointer to reference this theme later</returns>
        public static global::lvgl.LvThemeT LvThemeMonoInit(global::lvgl.LvDisplayT disp, bool dark_bg, global::lvgl.LvFontT font)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var __arg2 = font is null ? __IntPtr.Zero : font.__Instance;
            var ___ret = __Internal.LvThemeMonoInit(__arg0, dark_bg, __arg2);
            var __result0 = global::lvgl.LvThemeT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Check if the theme is initialized</summary>
        /// <returns>true if default theme is initialized, false otherwise</returns>
        public static bool LvThemeMonoIsInited()
        {
            var ___ret = __Internal.LvThemeMonoIsInited();
            return ___ret;
        }

        /// <summary>Deinitialize the mono theme</summary>
        public static void LvThemeMonoDeinit()
        {
            __Internal.LvThemeMonoDeinit();
        }
    }

    public unsafe partial class lv_theme_simple
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_simple_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvThemeSimpleInit(__IntPtr disp);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_simple_is_inited", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool LvThemeSimpleIsInited();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_simple_get", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvThemeSimpleGet();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_theme_simple_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvThemeSimpleDeinit();
        }

        /// <summary>Initialize the theme</summary>
        /// <param name="disp">pointer to display to attach the theme</param>
        /// <returns>a pointer to reference this theme later</returns>
        public static global::lvgl.LvThemeT LvThemeSimpleInit(global::lvgl.LvDisplayT disp)
        {
            var __arg0 = disp is null ? __IntPtr.Zero : disp.__Instance;
            var ___ret = __Internal.LvThemeSimpleInit(__arg0);
            var __result0 = global::lvgl.LvThemeT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Check if the theme is initialized</summary>
        /// <returns>true if default theme is initialized, false otherwise</returns>
        public static bool LvThemeSimpleIsInited()
        {
            var ___ret = __Internal.LvThemeSimpleIsInited();
            return ___ret;
        }

        /// <summary>Get simple theme</summary>
        /// <returns>a pointer to simple theme, or NULL if this is not initialized</returns>
        public static global::lvgl.LvThemeT LvThemeSimpleGet()
        {
            var ___ret = __Internal.LvThemeSimpleGet();
            var __result0 = global::lvgl.LvThemeT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Deinitialize the simple theme</summary>
        public static void LvThemeSimpleDeinit()
        {
            __Internal.LvThemeSimpleDeinit();
        }
    }

    public unsafe partial class lv_windows_input
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_windows_acquire_pointer_indev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvWindowsAcquirePointerIndev(__IntPtr display);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_windows_acquire_keypad_indev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvWindowsAcquireKeypadIndev(__IntPtr display);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_windows_acquire_encoder_indev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvWindowsAcquireEncoderIndev(__IntPtr display);
        }

        /// <summary>
        /// <para>Open a LVGL pointer input device object for the specific LVGL</para>
        /// <para>display object, or create it if the LVGL pointer input device</para>
        /// <para>object is not created or removed before.</para>
        /// </summary>
        /// <param name="display">The specific LVGL display object.</param>
        /// <returns>
        /// <para>The LVGL pointer input device object for the specific LVGL</para>
        /// <para>display object.</para>
        /// </returns>
        public static global::lvgl.LvIndevT LvWindowsAcquirePointerIndev(global::lvgl.LvDisplayT display)
        {
            var __arg0 = display is null ? __IntPtr.Zero : display.__Instance;
            var ___ret = __Internal.LvWindowsAcquirePointerIndev(__arg0);
            var __result0 = global::lvgl.LvIndevT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Open a LVGL keypad input device object for the specific LVGL</para>
        /// <para>display object, or create it if the LVGL keypad input device</para>
        /// <para>object is not created or removed before.</para>
        /// </summary>
        /// <param name="display">The specific LVGL display object.</param>
        /// <returns>
        /// <para>The LVGL keypad input device object for the specific LVGL</para>
        /// <para>display object.</para>
        /// </returns>
        public static global::lvgl.LvIndevT LvWindowsAcquireKeypadIndev(global::lvgl.LvDisplayT display)
        {
            var __arg0 = display is null ? __IntPtr.Zero : display.__Instance;
            var ___ret = __Internal.LvWindowsAcquireKeypadIndev(__arg0);
            var __result0 = global::lvgl.LvIndevT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Open a LVGL encoder input device object for the specific LVGL</para>
        /// <para>display object, or create it if the LVGL encoder input device</para>
        /// <para>object is not created or removed before.</para>
        /// </summary>
        /// <param name="display">The specific LVGL display object.</param>
        /// <returns>
        /// <para>The LVGL encoder input device object for the specific LVGL</para>
        /// <para>display object.</para>
        /// </returns>
        public static global::lvgl.LvIndevT LvWindowsAcquireEncoderIndev(global::lvgl.LvDisplayT display)
        {
            var __arg0 = display is null ? __IntPtr.Zero : display.__Instance;
            var ___ret = __Internal.LvWindowsAcquireEncoderIndev(__arg0);
            var __result0 = global::lvgl.LvIndevT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    public unsafe partial class lv_windows_display
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_windows_create_display", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LvWindowsCreateDisplay([MarshalAs(UnmanagedType.LPWStr)] string title, int hor_res, int ver_res, int zoom_level, bool allow_dpi_override, bool simulator_mode);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_windows_zoom_to_logical", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvWindowsZoomToLogical(int physical, int zoom_level);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_windows_zoom_to_physical", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvWindowsZoomToPhysical(int logical, int zoom_level);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_windows_dpi_to_logical", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvWindowsDpiToLogical(int physical, int dpi);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_windows_dpi_to_physical", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LvWindowsDpiToPhysical(int logical, int dpi);
        }

        /// <summary>Create a LVGL display object.</summary>
        /// <param name="title">The window title of LVGL display.</param>
        /// <param name="hor_res">The horizontal resolution value of LVGL display.</param>
        /// <param name="ver_res">The vertical resolution value of LVGL display.</param>
        /// <param name="zoom_level">The zoom level value. Base value is 100 a.k.a 100%.</param>
        /// <param name="allow_dpi_override">
        /// <para>Allow DPI override if true, or follow the</para>
        /// <para>Windows DPI scaling setting dynamically.</para>
        /// </param>
        /// <param name="simulator_mode">
        /// <para>Create simulator mode display if true, or create</para>
        /// <para>application mode display.</para>
        /// </param>
        /// <returns>The created LVGL display object.</returns>
        public static global::lvgl.LvDisplayT LvWindowsCreateDisplay(string title, int hor_res, int ver_res, int zoom_level, bool allow_dpi_override, bool simulator_mode)
        {
            var ___ret = __Internal.LvWindowsCreateDisplay(title, hor_res, ver_res, zoom_level, allow_dpi_override, simulator_mode);
            var __result0 = global::lvgl.LvDisplayT.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get logical pixel value from physical pixel value taken account</para>
        /// <para>with zoom level.</para>
        /// </summary>
        /// <param name="physical">The physical pixel value taken account with zoom level.</param>
        /// <param name="zoom_level">The zoom level value. Base value is 100 a.k.a 100%.</param>
        /// <returns>The logical pixel value.</returns>
        /// <remarks>
        /// <para>It uses the same calculation style as Windows OS implementation.</para>
        /// <para>It will be useful for integrate LVGL Windows backend to other</para>
        /// <para>Windows applications.</para>
        /// </remarks>
        public static int LvWindowsZoomToLogical(int physical, int zoom_level)
        {
            var ___ret = __Internal.LvWindowsZoomToLogical(physical, zoom_level);
            return ___ret;
        }

        /// <summary>
        /// <para>Get physical pixel value taken account with zoom level from</para>
        /// <para>logical pixel value.</para>
        /// </summary>
        /// <param name="logical">The logical pixel value.</param>
        /// <param name="zoom_level">The zoom level value. Base value is 100 a.k.a 100%.</param>
        /// <returns>The physical pixel value taken account with zoom level.</returns>
        /// <remarks>
        /// <para>It uses the same calculation style as Windows OS implementation.</para>
        /// <para>It will be useful for integrate LVGL Windows backend to other</para>
        /// <para>Windows applications.</para>
        /// </remarks>
        public static int LvWindowsZoomToPhysical(int logical, int zoom_level)
        {
            var ___ret = __Internal.LvWindowsZoomToPhysical(logical, zoom_level);
            return ___ret;
        }

        /// <summary>
        /// <para>Get logical pixel value from physical pixel value taken account</para>
        /// <para>with DPI scaling.</para>
        /// </summary>
        /// <param name="physical">The physical pixel value taken account with DPI scaling.</param>
        /// <param name="dpi">The DPI scaling value. Base value is USER_DEFAULT_SCREEN_DPI.</param>
        /// <returns>The logical pixel value.</returns>
        /// <remarks>
        /// <para>It uses the same calculation style as Windows OS implementation.</para>
        /// <para>It will be useful for integrate LVGL Windows backend to other</para>
        /// <para>Windows applications.</para>
        /// </remarks>
        public static int LvWindowsDpiToLogical(int physical, int dpi)
        {
            var ___ret = __Internal.LvWindowsDpiToLogical(physical, dpi);
            return ___ret;
        }

        /// <summary>
        /// <para>Get physical pixel value taken account with DPI scaling from</para>
        /// <para>logical pixel value.</para>
        /// </summary>
        /// <param name="logical">The logical pixel value.</param>
        /// <param name="dpi">The DPI scaling value. Base value is USER_DEFAULT_SCREEN_DPI.</param>
        /// <returns>The physical pixel value taken account with DPI scaling.</returns>
        /// <remarks>
        /// <para>It uses the same calculation style as Windows OS implementation.</para>
        /// <para>It will be useful for integrate LVGL Windows backend to other</para>
        /// <para>Windows applications.</para>
        /// </remarks>
        public static int LvWindowsDpiToPhysical(int logical, int dpi)
        {
            var ___ret = __Internal.LvWindowsDpiToPhysical(logical, dpi);
            return ___ret;
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvGlobalT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1032)]
        public partial struct __Internal
        {
            internal byte inited;
            internal byte deinit_in_progress;
            internal global::lvgl.LvLlT.__Internal disp_ll;
            internal __IntPtr disp_refresh;
            internal __IntPtr disp_default;
            internal global::lvgl.LvLlT.__Internal style_trans_ll;
            internal byte style_refresh;
            internal uint style_custom_table_size;
            internal uint style_last_custom_prop_id;
            internal __IntPtr style_custom_prop_flag_lookup_table;
            internal global::lvgl.LvLlT.__Internal group_ll;
            internal __IntPtr group_default;
            internal global::lvgl.LvLlT.__Internal indev_ll;
            internal __IntPtr indev_active;
            internal __IntPtr indev_obj_active;
            internal uint layout_count;
            internal __IntPtr layout_list;
            internal byte layout_update_mutex;
            internal uint memory_zero;
            internal uint math_rand_seed;
            internal __IntPtr event_header;
            internal uint event_last_register_id;
            internal global::lvgl.LvTimerStateT.__Internal timer_state;
            internal global::lvgl.LvAnimStateT.__Internal anim_state;
            internal global::lvgl.LvTickStateT.__Internal tick_state;
            internal global::lvgl.LvDrawBufHandlersT.__Internal draw_buf_handlers;
            internal global::lvgl.LvDrawBufHandlersT.__Internal font_draw_buf_handlers;
            internal global::lvgl.LvDrawBufHandlersT.__Internal image_cache_draw_buf_handlers;
            internal global::lvgl.LvLlT.__Internal img_decoder_ll;
            internal __IntPtr img_cache;
            internal __IntPtr img_header_cache;
            internal global::lvgl.LvDrawGlobalInfoT.__Internal draw_info;
            internal fixed byte sw_circle_cache[192];
            internal __IntPtr custom_log_print_cb;
            internal uint log_last_log_time;
            internal __IntPtr theme_simple;
            internal __IntPtr theme_default;
            internal __IntPtr theme_mono;
            internal global::lvgl.LvLlT.__Internal fsdrv_ll;
            internal global::lvgl.LvFsDrvT.__Internal win32_fs_drv;
            internal __IntPtr tiny_ttf_cache;
            internal __IntPtr span_snippet_stack;
            internal __IntPtr user_data;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_global_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvGlobalT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvGlobalT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvGlobalT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvGlobalT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvGlobalT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvGlobalT(native.ToPointer(), skipVTables);
        }

        internal static LvGlobalT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvGlobalT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvGlobalT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvGlobalT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvGlobalT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvGlobalT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvGlobalT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvGlobalT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvGlobalT(global::lvgl.LvGlobalT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvGlobalT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvGlobalT.__Internal*) __Instance) = *((global::lvgl.LvGlobalT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Inited
        {
            get
            {
                return ((__Internal*)__Instance)->inited != 0;
            }

            set
            {
                ((__Internal*)__Instance)->inited = (byte) (value ? 1 : 0);
            }
        }

        /// <summary>Can be used e.g. in the LV_EVENT_DELETE to deinit the drivers too</summary>
        public bool DeinitInProgress
        {
            get
            {
                return ((__Internal*)__Instance)->deinit_in_progress != 0;
            }

            set
            {
                ((__Internal*)__Instance)->deinit_in_progress = (byte) (value ? 1 : 0);
            }
        }

        public global::lvgl.LvLlT DispLl
        {
            get
            {
                return global::lvgl.LvLlT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->disp_ll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->disp_ll = *(global::lvgl.LvLlT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvDisplayT DispRefresh
        {
            get
            {
                var __result0 = global::lvgl.LvDisplayT.__GetOrCreateInstance(((__Internal*)__Instance)->disp_refresh, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->disp_refresh = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvDisplayT DispDefault
        {
            get
            {
                var __result0 = global::lvgl.LvDisplayT.__GetOrCreateInstance(((__Internal*)__Instance)->disp_default, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->disp_default = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvLlT StyleTransLl
        {
            get
            {
                return global::lvgl.LvLlT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->style_trans_ll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->style_trans_ll = *(global::lvgl.LvLlT.__Internal*) value.__Instance;
            }
        }

        public bool StyleRefresh
        {
            get
            {
                return ((__Internal*)__Instance)->style_refresh != 0;
            }

            set
            {
                ((__Internal*)__Instance)->style_refresh = (byte) (value ? 1 : 0);
            }
        }

        public uint StyleCustomTableSize
        {
            get
            {
                return ((__Internal*)__Instance)->style_custom_table_size;
            }

            set
            {
                ((__Internal*)__Instance)->style_custom_table_size = value;
            }
        }

        public uint StyleLastCustomPropId
        {
            get
            {
                return ((__Internal*)__Instance)->style_last_custom_prop_id;
            }

            set
            {
                ((__Internal*)__Instance)->style_last_custom_prop_id = value;
            }
        }

        public byte* StyleCustomPropFlagLookupTable
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->style_custom_prop_flag_lookup_table;
            }

            set
            {
                ((__Internal*)__Instance)->style_custom_prop_flag_lookup_table = (__IntPtr) value;
            }
        }

        public global::lvgl.LvLlT GroupLl
        {
            get
            {
                return global::lvgl.LvLlT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->group_ll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->group_ll = *(global::lvgl.LvLlT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvGroupT GroupDefault
        {
            get
            {
                var __result0 = global::lvgl.LvGroupT.__GetOrCreateInstance(((__Internal*)__Instance)->group_default, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->group_default = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvLlT IndevLl
        {
            get
            {
                return global::lvgl.LvLlT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->indev_ll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->indev_ll = *(global::lvgl.LvLlT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvIndevT IndevActive
        {
            get
            {
                var __result0 = global::lvgl.LvIndevT.__GetOrCreateInstance(((__Internal*)__Instance)->indev_active, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->indev_active = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvObjT IndevObjActive
        {
            get
            {
                var __result0 = global::lvgl.LvObjT.__GetOrCreateInstance(((__Internal*)__Instance)->indev_obj_active, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->indev_obj_active = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint LayoutCount
        {
            get
            {
                return ((__Internal*)__Instance)->layout_count;
            }

            set
            {
                ((__Internal*)__Instance)->layout_count = value;
            }
        }

        public global::lvgl.LvLayoutDscT LayoutList
        {
            get
            {
                var __result0 = global::lvgl.LvLayoutDscT.__GetOrCreateInstance(((__Internal*)__Instance)->layout_list, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->layout_list = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public bool LayoutUpdateMutex
        {
            get
            {
                return ((__Internal*)__Instance)->layout_update_mutex != 0;
            }

            set
            {
                ((__Internal*)__Instance)->layout_update_mutex = (byte) (value ? 1 : 0);
            }
        }

        public uint MemoryZero
        {
            get
            {
                return ((__Internal*)__Instance)->memory_zero;
            }

            set
            {
                ((__Internal*)__Instance)->memory_zero = value;
            }
        }

        public uint MathRandSeed
        {
            get
            {
                return ((__Internal*)__Instance)->math_rand_seed;
            }

            set
            {
                ((__Internal*)__Instance)->math_rand_seed = value;
            }
        }

        public global::lvgl.LvEventT EventHeader
        {
            get
            {
                var __result0 = global::lvgl.LvEventT.__GetOrCreateInstance(((__Internal*)__Instance)->event_header, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->event_header = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint EventLastRegisterId
        {
            get
            {
                return ((__Internal*)__Instance)->event_last_register_id;
            }

            set
            {
                ((__Internal*)__Instance)->event_last_register_id = value;
            }
        }

        public global::lvgl.LvTimerStateT TimerState
        {
            get
            {
                return global::lvgl.LvTimerStateT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->timer_state));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->timer_state = *(global::lvgl.LvTimerStateT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvAnimStateT AnimState
        {
            get
            {
                return global::lvgl.LvAnimStateT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->anim_state));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->anim_state = *(global::lvgl.LvAnimStateT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvTickStateT TickState
        {
            get
            {
                return global::lvgl.LvTickStateT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->tick_state));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->tick_state = *(global::lvgl.LvTickStateT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvDrawBufHandlersT DrawBufHandlers
        {
            get
            {
                return global::lvgl.LvDrawBufHandlersT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->draw_buf_handlers));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->draw_buf_handlers = *(global::lvgl.LvDrawBufHandlersT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvDrawBufHandlersT FontDrawBufHandlers
        {
            get
            {
                return global::lvgl.LvDrawBufHandlersT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->font_draw_buf_handlers));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->font_draw_buf_handlers = *(global::lvgl.LvDrawBufHandlersT.__Internal*) value.__Instance;
            }
        }

        /// <summary>
        /// <para>Ensure that all assigned draw buffers</para>
        /// <para>can be managed by image cache.</para>
        /// </summary>
        public global::lvgl.LvDrawBufHandlersT ImageCacheDrawBufHandlers
        {
            get
            {
                return global::lvgl.LvDrawBufHandlersT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->image_cache_draw_buf_handlers));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->image_cache_draw_buf_handlers = *(global::lvgl.LvDrawBufHandlersT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvLlT ImgDecoderLl
        {
            get
            {
                return global::lvgl.LvLlT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->img_decoder_ll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->img_decoder_ll = *(global::lvgl.LvLlT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvCacheT ImgCache
        {
            get
            {
                var __result0 = global::lvgl.LvCacheT.__GetOrCreateInstance(((__Internal*)__Instance)->img_cache, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->img_cache = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvCacheT ImgHeaderCache
        {
            get
            {
                var __result0 = global::lvgl.LvCacheT.__GetOrCreateInstance(((__Internal*)__Instance)->img_header_cache, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->img_header_cache = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvDrawGlobalInfoT DrawInfo
        {
            get
            {
                return global::lvgl.LvDrawGlobalInfoT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->draw_info));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->draw_info = *(global::lvgl.LvDrawGlobalInfoT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvDrawSwMaskRadiusCircleDscT[] SwCircleCache
        {
            get
            {
                global::lvgl.LvDrawSwMaskRadiusCircleDscT[] __value = null;
                if (((__Internal*)__Instance)->sw_circle_cache != null)
                {
                    __value = new global::lvgl.LvDrawSwMaskRadiusCircleDscT[4];
                    for (int i = 0; i < 4; i++)
                        __value[i] = global::lvgl.LvDrawSwMaskRadiusCircleDscT.__GetOrCreateInstance((IntPtr)((global::lvgl.LvDrawSwMaskRadiusCircleDscT.__Internal*)&(((__Internal*)__Instance)->sw_circle_cache[i * sizeof(global::lvgl.LvDrawSwMaskRadiusCircleDscT.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 4)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 4; i++)
                        *(global::lvgl.LvDrawSwMaskRadiusCircleDscT.__Internal*) &((__Internal*)__Instance)->sw_circle_cache[i * sizeof(global::lvgl.LvDrawSwMaskRadiusCircleDscT.__Internal)] = *(global::lvgl.LvDrawSwMaskRadiusCircleDscT.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::lvgl.LvLogPrintGCbT CustomLogPrintCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->custom_log_print_cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvLogPrintGCbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvLogPrintGCbT));
            }

            set
            {
                ((__Internal*)__Instance)->custom_log_print_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public uint LogLastLogTime
        {
            get
            {
                return ((__Internal*)__Instance)->log_last_log_time;
            }

            set
            {
                ((__Internal*)__Instance)->log_last_log_time = value;
            }
        }

        public __IntPtr ThemeSimple
        {
            get
            {
                return ((__Internal*)__Instance)->theme_simple;
            }

            set
            {
                ((__Internal*)__Instance)->theme_simple = (__IntPtr) value;
            }
        }

        public __IntPtr ThemeDefault
        {
            get
            {
                return ((__Internal*)__Instance)->theme_default;
            }

            set
            {
                ((__Internal*)__Instance)->theme_default = (__IntPtr) value;
            }
        }

        public __IntPtr ThemeMono
        {
            get
            {
                return ((__Internal*)__Instance)->theme_mono;
            }

            set
            {
                ((__Internal*)__Instance)->theme_mono = (__IntPtr) value;
            }
        }

        public global::lvgl.LvLlT FsdrvLl
        {
            get
            {
                return global::lvgl.LvLlT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->fsdrv_ll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->fsdrv_ll = *(global::lvgl.LvLlT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvFsDrvT Win32FsDrv
        {
            get
            {
                return global::lvgl.LvFsDrvT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->win32_fs_drv));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->win32_fs_drv = *(global::lvgl.LvFsDrvT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvCacheT TinyTtfCache
        {
            get
            {
                var __result0 = global::lvgl.LvCacheT.__GetOrCreateInstance(((__Internal*)__Instance)->tiny_ttf_cache, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->tiny_ttf_cache = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->user_data;
            }

            set
            {
                ((__Internal*)__Instance)->user_data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class lv_global
    {
        public partial struct __Internal
        {
        }

        public static global::lvgl.LvGlobalT LvGlobal
        {
            get
            {
                var __ptr = (global::lvgl.LvGlobalT.__Internal*)global::lvgl.__Symbols.lvgl._lv_global;
                return global::lvgl.LvGlobalT.__CreateInstance(new __IntPtr(__ptr));
            }

            set
            {
                var __ptr = (global::lvgl.LvGlobalT.__Internal*)global::lvgl.__Symbols.lvgl._lv_global;
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                *__ptr = *(global::lvgl.LvGlobalT.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvDrawSwUnitT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 128)]
        public partial struct __Internal
        {
            internal global::lvgl.LvDrawUnitT.__Internal base_unit;
            internal __IntPtr task_act;
            internal global::lvgl.LvThreadSyncT.__Internal sync;
            internal __IntPtr thread;
            internal byte inited;
            internal byte exit_status;
            internal uint idx;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_sw_unit_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwUnitT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwUnitT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawSwUnitT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawSwUnitT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawSwUnitT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawSwUnitT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawSwUnitT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawSwUnitT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawSwUnitT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawSwUnitT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawSwUnitT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawSwUnitT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawSwUnitT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwUnitT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawSwUnitT(global::lvgl.LvDrawSwUnitT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwUnitT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawSwUnitT.__Internal*) __Instance) = *((global::lvgl.LvDrawSwUnitT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawUnitT BaseUnit
        {
            get
            {
                return global::lvgl.LvDrawUnitT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->base_unit));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->base_unit = *(global::lvgl.LvDrawUnitT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvDrawTaskT TaskAct
        {
            get
            {
                var __result0 = global::lvgl.LvDrawTaskT.__GetOrCreateInstance(((__Internal*)__Instance)->task_act, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->task_act = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::lvgl.LvThreadSyncT Sync
        {
            get
            {
                return global::lvgl.LvThreadSyncT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sync));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sync = *(global::lvgl.LvThreadSyncT.__Internal*) value.__Instance;
            }
        }

        public __IntPtr Thread
        {
            get
            {
                return ((__Internal*)__Instance)->thread;
            }

            set
            {
                ((__Internal*)__Instance)->thread = (__IntPtr) value;
            }
        }

        public bool Inited
        {
            get
            {
                return ((__Internal*)__Instance)->inited != 0;
            }

            set
            {
                ((__Internal*)__Instance)->inited = (byte) (value ? 1 : 0);
            }
        }

        public bool ExitStatus
        {
            get
            {
                return ((__Internal*)__Instance)->exit_status != 0;
            }

            set
            {
                ((__Internal*)__Instance)->exit_status = (byte) (value ? 1 : 0);
            }
        }

        public uint Idx
        {
            get
            {
                return ((__Internal*)__Instance)->idx;
            }

            set
            {
                ((__Internal*)__Instance)->idx = value;
            }
        }
    }

    public unsafe partial class lv_draw_sw
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwDeinit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_fill", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwFill(__IntPtr draw_unit, __IntPtr dsc, __IntPtr coords);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_border", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwBorder(__IntPtr draw_unit, __IntPtr dsc, __IntPtr coords);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_box_shadow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwBoxShadow(__IntPtr draw_unit, __IntPtr dsc, __IntPtr coords);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_image", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwImage(__IntPtr draw_unit, __IntPtr draw_dsc, __IntPtr coords);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_label", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwLabel(__IntPtr draw_unit, __IntPtr dsc, __IntPtr coords);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_arc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwArc(__IntPtr draw_unit, __IntPtr dsc, __IntPtr coords);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_line", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwLine(__IntPtr draw_unit, __IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_layer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwLayer(__IntPtr draw_unit, __IntPtr draw_dsc, __IntPtr coords);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_triangle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwTriangle(__IntPtr draw_unit, __IntPtr dsc);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_mask_rect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwMaskRect(__IntPtr draw_unit, __IntPtr dsc, __IntPtr coords);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_transform", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwTransform(__IntPtr draw_unit, __IntPtr dest_area, __IntPtr src_buf, int src_w, int src_h, int src_stride, __IntPtr draw_dsc, __IntPtr sup, byte cf, __IntPtr dest_buf);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_rgb565_swap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwRgb565Swap(__IntPtr buf, uint buf_size_px);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_rotate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwRotate(__IntPtr src, __IntPtr dest, int src_width, int src_height, int src_sride, int dest_stride, global::lvgl.LvDisplayRotationT rotation, byte color_format);
        }

        /// <summary>
        /// <para>Initialize the SW renderer. Called in internally.</para>
        /// <para>It creates as many SW renderers as defined in LV_DRAW_SW_DRAW_UNIT_CNT</para>
        /// </summary>
        public static void LvDrawSwInit()
        {
            __Internal.LvDrawSwInit();
        }

        /// <summary>Deinitialize the SW renderers</summary>
        public static void LvDrawSwDeinit()
        {
            __Internal.LvDrawSwDeinit();
        }

        /// <summary>Fill an area using SW render. Handle gradient and radius.</summary>
        /// <param name="draw_unit">pointer to a draw unit</param>
        /// <param name="dsc">the draw descriptor</param>
        /// <param name="coords">the coordinates of the rectangle</param>
        public static void LvDrawSwFill(global::lvgl.LvDrawUnitT draw_unit, global::lvgl.LvDrawFillDscT dsc, global::lvgl.LvAreaT coords)
        {
            var __arg0 = draw_unit is null ? __IntPtr.Zero : draw_unit.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var __arg2 = coords is null ? __IntPtr.Zero : coords.__Instance;
            __Internal.LvDrawSwFill(__arg0, __arg1, __arg2);
        }

        /// <summary>Draw border with SW render.</summary>
        /// <param name="draw_unit">pointer to a draw unit</param>
        /// <param name="dsc">the draw descriptor</param>
        /// <param name="coords">the coordinates of the rectangle</param>
        public static void LvDrawSwBorder(global::lvgl.LvDrawUnitT draw_unit, global::lvgl.LvDrawBorderDscT dsc, global::lvgl.LvAreaT coords)
        {
            var __arg0 = draw_unit is null ? __IntPtr.Zero : draw_unit.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var __arg2 = coords is null ? __IntPtr.Zero : coords.__Instance;
            __Internal.LvDrawSwBorder(__arg0, __arg1, __arg2);
        }

        /// <summary>Draw box shadow with SW render.</summary>
        /// <param name="draw_unit">pointer to a draw unit</param>
        /// <param name="dsc">the draw descriptor</param>
        /// <param name="coords">the coordinates of the rectangle for which the box shadow should be drawn</param>
        public static void LvDrawSwBoxShadow(global::lvgl.LvDrawUnitT draw_unit, global::lvgl.LvDrawBoxShadowDscT dsc, global::lvgl.LvAreaT coords)
        {
            var __arg0 = draw_unit is null ? __IntPtr.Zero : draw_unit.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var __arg2 = coords is null ? __IntPtr.Zero : coords.__Instance;
            __Internal.LvDrawSwBoxShadow(__arg0, __arg1, __arg2);
        }

        /// <summary>Draw an image with SW render. It handles image decoding, tiling, transformations, and recoloring.</summary>
        /// <param name="draw_unit">pointer to a draw unit</param>
        /// <param name="dsc">the draw descriptor</param>
        /// <param name="coords">the coordinates of the image</param>
        public static void LvDrawSwImage(global::lvgl.LvDrawUnitT draw_unit, global::lvgl.LvDrawImageDscT draw_dsc, global::lvgl.LvAreaT coords)
        {
            var __arg0 = draw_unit is null ? __IntPtr.Zero : draw_unit.__Instance;
            var __arg1 = draw_dsc is null ? __IntPtr.Zero : draw_dsc.__Instance;
            var __arg2 = coords is null ? __IntPtr.Zero : coords.__Instance;
            __Internal.LvDrawSwImage(__arg0, __arg1, __arg2);
        }

        /// <summary>Draw a label with SW render.</summary>
        /// <param name="draw_unit">pointer to a draw unit</param>
        /// <param name="dsc">the draw descriptor</param>
        /// <param name="coords">the coordinates of the label</param>
        public static void LvDrawSwLabel(global::lvgl.LvDrawUnitT draw_unit, global::lvgl.LvDrawLabelDscT dsc, global::lvgl.LvAreaT coords)
        {
            var __arg0 = draw_unit is null ? __IntPtr.Zero : draw_unit.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var __arg2 = coords is null ? __IntPtr.Zero : coords.__Instance;
            __Internal.LvDrawSwLabel(__arg0, __arg1, __arg2);
        }

        /// <summary>Draw an arc with SW render.</summary>
        /// <param name="draw_unit">pointer to a draw unit</param>
        /// <param name="dsc">the draw descriptor</param>
        /// <param name="coords">the coordinates of the arc</param>
        public static void LvDrawSwArc(global::lvgl.LvDrawUnitT draw_unit, global::lvgl.LvDrawArcDscT dsc, global::lvgl.LvAreaT coords)
        {
            var __arg0 = draw_unit is null ? __IntPtr.Zero : draw_unit.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var __arg2 = coords is null ? __IntPtr.Zero : coords.__Instance;
            __Internal.LvDrawSwArc(__arg0, __arg1, __arg2);
        }

        /// <summary>Draw a line with SW render.</summary>
        /// <param name="draw_unit">pointer to a draw unit</param>
        /// <param name="dsc">the draw descriptor</param>
        public static void LvDrawSwLine(global::lvgl.LvDrawUnitT draw_unit, global::lvgl.LvDrawLineDscT dsc)
        {
            var __arg0 = draw_unit is null ? __IntPtr.Zero : draw_unit.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvDrawSwLine(__arg0, __arg1);
        }

        /// <summary>Blend a layer with SW render</summary>
        /// <param name="draw_unit">pointer to a draw unit</param>
        /// <param name="dsc">the draw descriptor</param>
        /// <param name="coords">the coordinates of the layer</param>
        public static void LvDrawSwLayer(global::lvgl.LvDrawUnitT draw_unit, global::lvgl.LvDrawImageDscT draw_dsc, global::lvgl.LvAreaT coords)
        {
            var __arg0 = draw_unit is null ? __IntPtr.Zero : draw_unit.__Instance;
            var __arg1 = draw_dsc is null ? __IntPtr.Zero : draw_dsc.__Instance;
            var __arg2 = coords is null ? __IntPtr.Zero : coords.__Instance;
            __Internal.LvDrawSwLayer(__arg0, __arg1, __arg2);
        }

        /// <summary>Draw a triangle with SW render.</summary>
        /// <param name="draw_unit">pointer to a draw unit</param>
        /// <param name="dsc">the draw descriptor</param>
        public static void LvDrawSwTriangle(global::lvgl.LvDrawUnitT draw_unit, global::lvgl.LvDrawTriangleDscT dsc)
        {
            var __arg0 = draw_unit is null ? __IntPtr.Zero : draw_unit.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvDrawSwTriangle(__arg0, __arg1);
        }

        /// <summary>Mask out a rectangle with radius from a current layer</summary>
        /// <param name="draw_unit">pointer to a draw unit</param>
        /// <param name="dsc">the draw descriptor</param>
        /// <param name="coords">the coordinates of the mask</param>
        public static void LvDrawSwMaskRect(global::lvgl.LvDrawUnitT draw_unit, global::lvgl.LvDrawMaskRectDscT dsc, global::lvgl.LvAreaT coords)
        {
            var __arg0 = draw_unit is null ? __IntPtr.Zero : draw_unit.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            var __arg2 = coords is null ? __IntPtr.Zero : coords.__Instance;
            __Internal.LvDrawSwMaskRect(__arg0, __arg1, __arg2);
        }

        /// <summary>Used internally to get a transformed are of an image</summary>
        /// <param name="draw_unit">pointer to a draw unit</param>
        /// <param name="dest_area">the area to calculate, i.e. get this area from the transformed image</param>
        /// <param name="src_buf">the source buffer</param>
        /// <param name="src_w">source buffer width in pixels</param>
        /// <param name="src_h">source buffer height in pixels</param>
        /// <param name="src_stride">source buffer stride in bytes</param>
        /// <param name="dsc">the draw descriptor</param>
        /// <param name="sup">supplementary data</param>
        /// <param name="cf">color format of the source buffer</param>
        /// <param name="dest_buf">the destination buffer</param>
        public static void LvDrawSwTransform(global::lvgl.LvDrawUnitT draw_unit, global::lvgl.LvAreaT dest_area, __IntPtr src_buf, int src_w, int src_h, int src_stride, global::lvgl.LvDrawImageDscT draw_dsc, global::lvgl.LvDrawImageSupT sup, byte cf, __IntPtr dest_buf)
        {
            var __arg0 = draw_unit is null ? __IntPtr.Zero : draw_unit.__Instance;
            var __arg1 = dest_area is null ? __IntPtr.Zero : dest_area.__Instance;
            var __arg6 = draw_dsc is null ? __IntPtr.Zero : draw_dsc.__Instance;
            var __arg7 = sup is null ? __IntPtr.Zero : sup.__Instance;
            __Internal.LvDrawSwTransform(__arg0, __arg1, src_buf, src_w, src_h, src_stride, __arg6, __arg7, cf, dest_buf);
        }

        /// <summary>
        /// <para>Swap the upper and lower byte of an RGB565 buffer.</para>
        /// <para>Might be required if a 8bit parallel port or an SPI port send the bytes in the wrong order.</para>
        /// <para>The bytes will be swapped in place.</para>
        /// </summary>
        /// <param name="buf_size_px">number of pixels in the buffer</param>
        public static void LvDrawSwRgb565Swap(__IntPtr buf, uint buf_size_px)
        {
            __Internal.LvDrawSwRgb565Swap(buf, buf_size_px);
        }

        /// <summary>Rotate a buffer into an other buffer</summary>
        /// <param name="src">the source buffer</param>
        /// <param name="dest">the destination buffer</param>
        /// <param name="src_width">source width in pixels</param>
        /// <param name="src_height">source height in pixels</param>
        /// <param name="src_sride">source stride in bytes (number of bytes in a row)</param>
        /// <param name="dest_stride">destination stride in bytes (number of bytes in a row)</param>
        /// <param name="rotation">LV_DISPLAY_ROTATION_0/90/180/270</param>
        /// <param name="color_format">LV_COLOR_FORMAT_RGB565/RGB888/XRGB8888/ARGB8888</param>
        public static void LvDrawSwRotate(__IntPtr src, __IntPtr dest, int src_width, int src_height, int src_sride, int dest_stride, global::lvgl.LvDisplayRotationT rotation, byte color_format)
        {
            __Internal.LvDrawSwRotate(src, dest, src_width, src_height, src_sride, dest_stride, rotation, color_format);
        }
    }

    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    /// <summary>
    /// <para>********************</para>
    /// <para>TYPEDEFS</para>
    /// <para>********************</para>
    /// </summary>
    public unsafe partial class LvDrawSwBlendDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal __IntPtr blend_area;
            internal __IntPtr src_buf;
            internal uint src_stride;
            internal byte src_color_format;
            internal __IntPtr src_area;
            internal byte opa;
            internal global::lvgl.LvColorT.__Internal color;
            internal __IntPtr mask_buf;
            internal byte mask_res;
            internal __IntPtr mask_area;
            internal int mask_stride;
            internal byte blend_mode;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_sw_blend_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwBlendDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwBlendDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawSwBlendDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawSwBlendDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawSwBlendDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawSwBlendDscT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawSwBlendDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawSwBlendDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawSwBlendDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawSwBlendDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawSwBlendDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawSwBlendDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawSwBlendDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwBlendDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawSwBlendDscT(global::lvgl.LvDrawSwBlendDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwBlendDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawSwBlendDscT.__Internal*) __Instance) = *((global::lvgl.LvDrawSwBlendDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>The area with absolute coordinates to draw on `layer-&gt;buf`</para>
        /// <para>will be clipped to `layer-&gt;clip_area`</para>
        /// </summary>
        public global::lvgl.LvAreaT BlendArea
        {
            get
            {
                var __result0 = global::lvgl.LvAreaT.__GetOrCreateInstance(((__Internal*)__Instance)->blend_area, false);
                return __result0;
            }
        }

        /// <summary>Pointer to an image to blend. If set `fill_color` is ignored</summary>
        public __IntPtr SrcBuf
        {
            get
            {
                return ((__Internal*)__Instance)->src_buf;
            }
        }

        public uint SrcStride
        {
            get
            {
                return ((__Internal*)__Instance)->src_stride;
            }

            set
            {
                ((__Internal*)__Instance)->src_stride = value;
            }
        }

        public byte SrcColorFormat
        {
            get
            {
                return ((__Internal*)__Instance)->src_color_format;
            }

            set
            {
                ((__Internal*)__Instance)->src_color_format = value;
            }
        }

        public global::lvgl.LvAreaT SrcArea
        {
            get
            {
                var __result0 = global::lvgl.LvAreaT.__GetOrCreateInstance(((__Internal*)__Instance)->src_area, false);
                return __result0;
            }
        }

        /// <summary>The overall opacity</summary>
        public byte Opa
        {
            get
            {
                return ((__Internal*)__Instance)->opa;
            }

            set
            {
                ((__Internal*)__Instance)->opa = value;
            }
        }

        /// <summary>Fill color</summary>
        public global::lvgl.LvColorT Color
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        /// <summary>NULL if ignored, or an alpha mask to apply on `blend_area`</summary>
        public byte* MaskBuf
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->mask_buf;
            }
        }

        /// <summary>The result of the previous mask operation</summary>
        public byte MaskRes
        {
            get
            {
                return ((__Internal*)__Instance)->mask_res;
            }

            set
            {
                ((__Internal*)__Instance)->mask_res = value;
            }
        }

        /// <summary>The area of `mask_buf` with absolute coordinates</summary>
        public global::lvgl.LvAreaT MaskArea
        {
            get
            {
                var __result0 = global::lvgl.LvAreaT.__GetOrCreateInstance(((__Internal*)__Instance)->mask_area, false);
                return __result0;
            }
        }

        public int MaskStride
        {
            get
            {
                return ((__Internal*)__Instance)->mask_stride;
            }

            set
            {
                ((__Internal*)__Instance)->mask_stride = value;
            }
        }

        /// <summary>E.g. LV_BLEND_MODE_ADDITIVE</summary>
        public byte BlendMode
        {
            get
            {
                return ((__Internal*)__Instance)->blend_mode;
            }

            set
            {
                ((__Internal*)__Instance)->blend_mode = value;
            }
        }
    }

    public unsafe partial class LvDrawSwBlendFillDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal __IntPtr dest_buf;
            internal int dest_w;
            internal int dest_h;
            internal int dest_stride;
            internal __IntPtr mask_buf;
            internal int mask_stride;
            internal global::lvgl.LvColorT.__Internal color;
            internal byte opa;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_draw_sw_blend_fill_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwBlendFillDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwBlendFillDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawSwBlendFillDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawSwBlendFillDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawSwBlendFillDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawSwBlendFillDscT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawSwBlendFillDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawSwBlendFillDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawSwBlendFillDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawSwBlendFillDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawSwBlendFillDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawSwBlendFillDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawSwBlendFillDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwBlendFillDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawSwBlendFillDscT(global::lvgl.LvDrawSwBlendFillDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwBlendFillDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawSwBlendFillDscT.__Internal*) __Instance) = *((global::lvgl.LvDrawSwBlendFillDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr DestBuf
        {
            get
            {
                return ((__Internal*)__Instance)->dest_buf;
            }

            set
            {
                ((__Internal*)__Instance)->dest_buf = (__IntPtr) value;
            }
        }

        public int DestW
        {
            get
            {
                return ((__Internal*)__Instance)->dest_w;
            }

            set
            {
                ((__Internal*)__Instance)->dest_w = value;
            }
        }

        public int DestH
        {
            get
            {
                return ((__Internal*)__Instance)->dest_h;
            }

            set
            {
                ((__Internal*)__Instance)->dest_h = value;
            }
        }

        public int DestStride
        {
            get
            {
                return ((__Internal*)__Instance)->dest_stride;
            }

            set
            {
                ((__Internal*)__Instance)->dest_stride = value;
            }
        }

        public byte* MaskBuf
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->mask_buf;
            }
        }

        public int MaskStride
        {
            get
            {
                return ((__Internal*)__Instance)->mask_stride;
            }

            set
            {
                ((__Internal*)__Instance)->mask_stride = value;
            }
        }

        public global::lvgl.LvColorT Color
        {
            get
            {
                return global::lvgl.LvColorT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->color = *(global::lvgl.LvColorT.__Internal*) value.__Instance;
            }
        }

        public byte Opa
        {
            get
            {
                return ((__Internal*)__Instance)->opa;
            }

            set
            {
                ((__Internal*)__Instance)->opa = value;
            }
        }
    }

    public unsafe partial class LvDrawSwBlendImageDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal __IntPtr dest_buf;
            internal int dest_w;
            internal int dest_h;
            internal int dest_stride;
            internal __IntPtr mask_buf;
            internal int mask_stride;
            internal __IntPtr src_buf;
            internal int src_stride;
            internal byte src_color_format;
            internal byte opa;
            internal byte blend_mode;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_draw_sw_blend_image_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwBlendImageDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwBlendImageDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawSwBlendImageDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawSwBlendImageDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawSwBlendImageDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawSwBlendImageDscT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawSwBlendImageDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawSwBlendImageDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawSwBlendImageDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawSwBlendImageDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawSwBlendImageDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawSwBlendImageDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawSwBlendImageDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwBlendImageDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawSwBlendImageDscT(global::lvgl.LvDrawSwBlendImageDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwBlendImageDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawSwBlendImageDscT.__Internal*) __Instance) = *((global::lvgl.LvDrawSwBlendImageDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr DestBuf
        {
            get
            {
                return ((__Internal*)__Instance)->dest_buf;
            }

            set
            {
                ((__Internal*)__Instance)->dest_buf = (__IntPtr) value;
            }
        }

        public int DestW
        {
            get
            {
                return ((__Internal*)__Instance)->dest_w;
            }

            set
            {
                ((__Internal*)__Instance)->dest_w = value;
            }
        }

        public int DestH
        {
            get
            {
                return ((__Internal*)__Instance)->dest_h;
            }

            set
            {
                ((__Internal*)__Instance)->dest_h = value;
            }
        }

        public int DestStride
        {
            get
            {
                return ((__Internal*)__Instance)->dest_stride;
            }

            set
            {
                ((__Internal*)__Instance)->dest_stride = value;
            }
        }

        public byte* MaskBuf
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->mask_buf;
            }
        }

        public int MaskStride
        {
            get
            {
                return ((__Internal*)__Instance)->mask_stride;
            }

            set
            {
                ((__Internal*)__Instance)->mask_stride = value;
            }
        }

        public __IntPtr SrcBuf
        {
            get
            {
                return ((__Internal*)__Instance)->src_buf;
            }
        }

        public int SrcStride
        {
            get
            {
                return ((__Internal*)__Instance)->src_stride;
            }

            set
            {
                ((__Internal*)__Instance)->src_stride = value;
            }
        }

        public byte SrcColorFormat
        {
            get
            {
                return ((__Internal*)__Instance)->src_color_format;
            }

            set
            {
                ((__Internal*)__Instance)->src_color_format = value;
            }
        }

        public byte Opa
        {
            get
            {
                return ((__Internal*)__Instance)->opa;
            }

            set
            {
                ((__Internal*)__Instance)->opa = value;
            }
        }

        public byte BlendMode
        {
            get
            {
                return ((__Internal*)__Instance)->blend_mode;
            }

            set
            {
                ((__Internal*)__Instance)->blend_mode = value;
            }
        }
    }

    public unsafe partial class lv_draw_sw_blend
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_blend", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwBlend(__IntPtr draw_unit, __IntPtr dsc);
        }

        /// <summary>Call the blend function of the `layer`.</summary>
        /// <param name="draw_unit">pointer to a draw unit</param>
        /// <param name="dsc">pointer to an initialized blend descriptor</param>
        public static void LvDrawSwBlend(global::lvgl.LvDrawUnitT draw_unit, global::lvgl.LvDrawSwBlendDscT dsc)
        {
            var __arg0 = draw_unit is null ? __IntPtr.Zero : draw_unit.__Instance;
            var __arg1 = dsc is null ? __IntPtr.Zero : dsc.__Instance;
            __Internal.LvDrawSwBlend(__arg0, __arg1);
        }
    }

    /// <summary>
    /// <para>A common callback type for every mask type.</para>
    /// <para>Used internally by the library.</para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate byte LvDrawSwMaskXcbT(byte* mask_buf, int abs_x, int abs_y, int len, __IntPtr p);

    public unsafe partial class LvDrawSwMaskCommonDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr cb;
            internal byte type;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_draw_sw_mask_common_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskCommonDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskCommonDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawSwMaskCommonDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawSwMaskCommonDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawSwMaskCommonDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawSwMaskCommonDscT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawSwMaskCommonDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawSwMaskCommonDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawSwMaskCommonDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawSwMaskCommonDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawSwMaskCommonDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawSwMaskCommonDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawSwMaskCommonDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskCommonDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawSwMaskCommonDscT(global::lvgl.LvDrawSwMaskCommonDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskCommonDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawSwMaskCommonDscT.__Internal*) __Instance) = *((global::lvgl.LvDrawSwMaskCommonDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawSwMaskXcbT Cb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->cb;
                return __ptr0 == IntPtr.Zero? null : (global::lvgl.LvDrawSwMaskXcbT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::lvgl.LvDrawSwMaskXcbT));
            }

            set
            {
                ((__Internal*)__Instance)->cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }
    }

    public unsafe partial class LvDrawSwMaskLineParamT : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::lvgl.LvDrawSwMaskCommonDscT.__Internal dsc;

            [FieldOffset(16)]
            internal global::lvgl.LvDrawSwMaskLineParamT.Cfg.__Internal cfg;

            [FieldOffset(36)]
            internal global::lvgl.LvPointT.__Internal origo;

            [FieldOffset(44)]
            internal int xy_steep;

            [FieldOffset(48)]
            internal int yx_steep;

            [FieldOffset(52)]
            internal int steep;

            [FieldOffset(56)]
            internal int spx;

            [FieldOffset(60)]
            internal byte flat;

            [FieldOffset(60)]
            internal byte inv;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_sw_mask_line_param_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial class Cfg : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 20)]
            public partial struct __Internal
            {
                internal global::lvgl.LvPointT.__Internal p1;
                internal global::lvgl.LvPointT.__Internal p2;
                internal byte side;

                [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0<unnamed-type-cfg>@lv_draw_sw_mask_line_param_t@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskLineParamT.Cfg> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskLineParamT.Cfg>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawSwMaskLineParamT.Cfg managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawSwMaskLineParamT.Cfg managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Cfg __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Cfg(native.ToPointer(), skipVTables);
            }

            internal static Cfg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Cfg)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Cfg __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Cfg(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Cfg(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Cfg(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Cfg()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskLineParamT.Cfg.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public Cfg(global::lvgl.LvDrawSwMaskLineParamT.Cfg _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskLineParamT.Cfg.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::lvgl.LvDrawSwMaskLineParamT.Cfg.__Internal*) __Instance) = *((global::lvgl.LvDrawSwMaskLineParamT.Cfg.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::lvgl.LvPointT P1
            {
                get
                {
                    return global::lvgl.LvPointT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->p1));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->p1 = *(global::lvgl.LvPointT.__Internal*) value.__Instance;
                }
            }

            public global::lvgl.LvPointT P2
            {
                get
                {
                    return global::lvgl.LvPointT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->p2));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->p2 = *(global::lvgl.LvPointT.__Internal*) value.__Instance;
                }
            }

            public byte Side
            {
                get
                {
                    return ((__Internal*)__Instance)->side;
                }

                set
                {
                    ((__Internal*)__Instance)->side = value;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskLineParamT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskLineParamT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawSwMaskLineParamT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawSwMaskLineParamT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawSwMaskLineParamT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawSwMaskLineParamT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawSwMaskLineParamT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawSwMaskLineParamT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawSwMaskLineParamT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawSwMaskLineParamT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawSwMaskLineParamT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawSwMaskLineParamT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawSwMaskLineParamT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskLineParamT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawSwMaskLineParamT(global::lvgl.LvDrawSwMaskLineParamT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskLineParamT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawSwMaskLineParamT.__Internal*) __Instance) = *((global::lvgl.LvDrawSwMaskLineParamT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawSwMaskCommonDscT Dsc
        {
            get
            {
                return global::lvgl.LvDrawSwMaskCommonDscT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->dsc));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->dsc = *(global::lvgl.LvDrawSwMaskCommonDscT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvDrawSwMaskLineParamT.Cfg cfg
        {
            get
            {
                return global::lvgl.LvDrawSwMaskLineParamT.Cfg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->cfg));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->cfg = *(global::lvgl.LvDrawSwMaskLineParamT.Cfg.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvPointT Origo
        {
            get
            {
                return global::lvgl.LvPointT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->origo));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->origo = *(global::lvgl.LvPointT.__Internal*) value.__Instance;
            }
        }

        public int XySteep
        {
            get
            {
                return ((__Internal*)__Instance)->xy_steep;
            }

            set
            {
                ((__Internal*)__Instance)->xy_steep = value;
            }
        }

        public int YxSteep
        {
            get
            {
                return ((__Internal*)__Instance)->yx_steep;
            }

            set
            {
                ((__Internal*)__Instance)->yx_steep = value;
            }
        }

        public int Steep
        {
            get
            {
                return ((__Internal*)__Instance)->steep;
            }

            set
            {
                ((__Internal*)__Instance)->steep = value;
            }
        }

        public int Spx
        {
            get
            {
                return ((__Internal*)__Instance)->spx;
            }

            set
            {
                ((__Internal*)__Instance)->spx = value;
            }
        }

        public byte Flat
        {
            get
            {
                return ((__Internal*)__Instance)->flat;
            }

            set
            {
                ((__Internal*)__Instance)->flat = value;
            }
        }

        public byte Inv
        {
            get
            {
                return ((__Internal*)__Instance)->inv;
            }

            set
            {
                ((__Internal*)__Instance)->inv = value;
            }
        }
    }

    public unsafe partial class LvDrawSwMaskAngleParamT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 168)]
        public partial struct __Internal
        {
            internal global::lvgl.LvDrawSwMaskCommonDscT.__Internal dsc;
            internal global::lvgl.LvDrawSwMaskAngleParamT.Cfg.__Internal cfg;
            internal global::lvgl.LvDrawSwMaskLineParamT.__Internal start_line;
            internal global::lvgl.LvDrawSwMaskLineParamT.__Internal end_line;
            internal ushort delta_deg;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_sw_mask_angle_param_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial class Cfg : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal global::lvgl.LvPointT.__Internal vertex_p;
                internal int start_angle;
                internal int end_angle;

                [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0<unnamed-type-cfg>@lv_draw_sw_mask_angle_param_t@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskAngleParamT.Cfg> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskAngleParamT.Cfg>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawSwMaskAngleParamT.Cfg managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawSwMaskAngleParamT.Cfg managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Cfg __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Cfg(native.ToPointer(), skipVTables);
            }

            internal static Cfg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Cfg)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Cfg __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Cfg(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Cfg(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Cfg(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Cfg()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskAngleParamT.Cfg.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public Cfg(global::lvgl.LvDrawSwMaskAngleParamT.Cfg _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskAngleParamT.Cfg.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::lvgl.LvDrawSwMaskAngleParamT.Cfg.__Internal*) __Instance) = *((global::lvgl.LvDrawSwMaskAngleParamT.Cfg.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::lvgl.LvPointT VertexP
            {
                get
                {
                    return global::lvgl.LvPointT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->vertex_p));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->vertex_p = *(global::lvgl.LvPointT.__Internal*) value.__Instance;
                }
            }

            public int StartAngle
            {
                get
                {
                    return ((__Internal*)__Instance)->start_angle;
                }

                set
                {
                    ((__Internal*)__Instance)->start_angle = value;
                }
            }

            public int EndAngle
            {
                get
                {
                    return ((__Internal*)__Instance)->end_angle;
                }

                set
                {
                    ((__Internal*)__Instance)->end_angle = value;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskAngleParamT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskAngleParamT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawSwMaskAngleParamT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawSwMaskAngleParamT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawSwMaskAngleParamT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawSwMaskAngleParamT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawSwMaskAngleParamT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawSwMaskAngleParamT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawSwMaskAngleParamT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawSwMaskAngleParamT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawSwMaskAngleParamT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawSwMaskAngleParamT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawSwMaskAngleParamT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskAngleParamT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawSwMaskAngleParamT(global::lvgl.LvDrawSwMaskAngleParamT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskAngleParamT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawSwMaskAngleParamT.__Internal*) __Instance) = *((global::lvgl.LvDrawSwMaskAngleParamT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawSwMaskCommonDscT Dsc
        {
            get
            {
                return global::lvgl.LvDrawSwMaskCommonDscT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->dsc));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->dsc = *(global::lvgl.LvDrawSwMaskCommonDscT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvDrawSwMaskAngleParamT.Cfg cfg
        {
            get
            {
                return global::lvgl.LvDrawSwMaskAngleParamT.Cfg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->cfg));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->cfg = *(global::lvgl.LvDrawSwMaskAngleParamT.Cfg.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvDrawSwMaskLineParamT StartLine
        {
            get
            {
                return global::lvgl.LvDrawSwMaskLineParamT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->start_line));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->start_line = *(global::lvgl.LvDrawSwMaskLineParamT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvDrawSwMaskLineParamT EndLine
        {
            get
            {
                return global::lvgl.LvDrawSwMaskLineParamT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->end_line));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->end_line = *(global::lvgl.LvDrawSwMaskLineParamT.__Internal*) value.__Instance;
            }
        }

        public ushort DeltaDeg
        {
            get
            {
                return ((__Internal*)__Instance)->delta_deg;
            }

            set
            {
                ((__Internal*)__Instance)->delta_deg = value;
            }
        }
    }

    public unsafe partial class LvDrawSwMaskRadiusCircleDscT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal __IntPtr buf;
            internal __IntPtr cir_opa;
            internal __IntPtr x_start_on_y;
            internal __IntPtr opa_start_on_y;
            internal int life;
            internal uint used_cnt;
            internal int radius;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_draw_sw_mask_radius_circle_dsc_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskRadiusCircleDscT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskRadiusCircleDscT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawSwMaskRadiusCircleDscT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawSwMaskRadiusCircleDscT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawSwMaskRadiusCircleDscT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawSwMaskRadiusCircleDscT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawSwMaskRadiusCircleDscT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawSwMaskRadiusCircleDscT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawSwMaskRadiusCircleDscT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawSwMaskRadiusCircleDscT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawSwMaskRadiusCircleDscT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawSwMaskRadiusCircleDscT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawSwMaskRadiusCircleDscT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskRadiusCircleDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawSwMaskRadiusCircleDscT(global::lvgl.LvDrawSwMaskRadiusCircleDscT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskRadiusCircleDscT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawSwMaskRadiusCircleDscT.__Internal*) __Instance) = *((global::lvgl.LvDrawSwMaskRadiusCircleDscT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte* Buf
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->buf;
            }

            set
            {
                ((__Internal*)__Instance)->buf = (__IntPtr) value;
            }
        }

        public byte* CirOpa
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->cir_opa;
            }

            set
            {
                ((__Internal*)__Instance)->cir_opa = (__IntPtr) value;
            }
        }

        public ushort* XStartOnY
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->x_start_on_y;
            }

            set
            {
                ((__Internal*)__Instance)->x_start_on_y = (__IntPtr) value;
            }
        }

        public ushort* OpaStartOnY
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->opa_start_on_y;
            }

            set
            {
                ((__Internal*)__Instance)->opa_start_on_y = (__IntPtr) value;
            }
        }

        public int Life
        {
            get
            {
                return ((__Internal*)__Instance)->life;
            }

            set
            {
                ((__Internal*)__Instance)->life = value;
            }
        }

        public uint UsedCnt
        {
            get
            {
                return ((__Internal*)__Instance)->used_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->used_cnt = value;
            }
        }

        public int Radius
        {
            get
            {
                return ((__Internal*)__Instance)->radius;
            }

            set
            {
                ((__Internal*)__Instance)->radius = value;
            }
        }
    }

    public unsafe partial class LvDrawSwMaskRadiusParamT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal global::lvgl.LvDrawSwMaskCommonDscT.__Internal dsc;
            internal global::lvgl.LvDrawSwMaskRadiusParamT.Cfg.__Internal cfg;
            internal __IntPtr circle;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_sw_mask_radius_param_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial class Cfg : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public partial struct __Internal
            {
                internal global::lvgl.LvAreaT.__Internal rect;
                internal int radius;
                internal byte outer;

                [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0<unnamed-type-cfg>@lv_draw_sw_mask_radius_param_t@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskRadiusParamT.Cfg> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskRadiusParamT.Cfg>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawSwMaskRadiusParamT.Cfg managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawSwMaskRadiusParamT.Cfg managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Cfg __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Cfg(native.ToPointer(), skipVTables);
            }

            internal static Cfg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Cfg)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Cfg __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Cfg(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Cfg(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Cfg(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Cfg()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskRadiusParamT.Cfg.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public Cfg(global::lvgl.LvDrawSwMaskRadiusParamT.Cfg _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskRadiusParamT.Cfg.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::lvgl.LvDrawSwMaskRadiusParamT.Cfg.__Internal*) __Instance) = *((global::lvgl.LvDrawSwMaskRadiusParamT.Cfg.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::lvgl.LvAreaT Rect
            {
                get
                {
                    return global::lvgl.LvAreaT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->rect));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->rect = *(global::lvgl.LvAreaT.__Internal*) value.__Instance;
                }
            }

            public int Radius
            {
                get
                {
                    return ((__Internal*)__Instance)->radius;
                }

                set
                {
                    ((__Internal*)__Instance)->radius = value;
                }
            }

            public byte Outer
            {
                get
                {
                    return ((__Internal*)__Instance)->outer;
                }

                set
                {
                    ((__Internal*)__Instance)->outer = value;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskRadiusParamT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskRadiusParamT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawSwMaskRadiusParamT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawSwMaskRadiusParamT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawSwMaskRadiusParamT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawSwMaskRadiusParamT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawSwMaskRadiusParamT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawSwMaskRadiusParamT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawSwMaskRadiusParamT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawSwMaskRadiusParamT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawSwMaskRadiusParamT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawSwMaskRadiusParamT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawSwMaskRadiusParamT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskRadiusParamT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawSwMaskRadiusParamT(global::lvgl.LvDrawSwMaskRadiusParamT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskRadiusParamT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawSwMaskRadiusParamT.__Internal*) __Instance) = *((global::lvgl.LvDrawSwMaskRadiusParamT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawSwMaskCommonDscT Dsc
        {
            get
            {
                return global::lvgl.LvDrawSwMaskCommonDscT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->dsc));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->dsc = *(global::lvgl.LvDrawSwMaskCommonDscT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvDrawSwMaskRadiusParamT.Cfg cfg
        {
            get
            {
                return global::lvgl.LvDrawSwMaskRadiusParamT.Cfg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->cfg));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->cfg = *(global::lvgl.LvDrawSwMaskRadiusParamT.Cfg.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvDrawSwMaskRadiusCircleDscT Circle
        {
            get
            {
                var __result0 = global::lvgl.LvDrawSwMaskRadiusCircleDscT.__GetOrCreateInstance(((__Internal*)__Instance)->circle, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->circle = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class LvDrawSwMaskFadeParamT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal global::lvgl.LvDrawSwMaskCommonDscT.__Internal dsc;
            internal global::lvgl.LvDrawSwMaskFadeParamT.Cfg.__Internal cfg;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0lv_draw_sw_mask_fade_param_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial class Cfg : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 28)]
            public partial struct __Internal
            {
                internal global::lvgl.LvAreaT.__Internal coords;
                internal int y_top;
                internal int y_bottom;
                internal byte opa_top;
                internal byte opa_bottom;

                [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0<unnamed-type-cfg>@lv_draw_sw_mask_fade_param_t@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskFadeParamT.Cfg> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskFadeParamT.Cfg>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawSwMaskFadeParamT.Cfg managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawSwMaskFadeParamT.Cfg managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Cfg __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Cfg(native.ToPointer(), skipVTables);
            }

            internal static Cfg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Cfg)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Cfg __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Cfg(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Cfg(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Cfg(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Cfg()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskFadeParamT.Cfg.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public Cfg(global::lvgl.LvDrawSwMaskFadeParamT.Cfg _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskFadeParamT.Cfg.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::lvgl.LvDrawSwMaskFadeParamT.Cfg.__Internal*) __Instance) = *((global::lvgl.LvDrawSwMaskFadeParamT.Cfg.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::lvgl.LvAreaT Coords
            {
                get
                {
                    return global::lvgl.LvAreaT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->coords));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->coords = *(global::lvgl.LvAreaT.__Internal*) value.__Instance;
                }
            }

            public int YTop
            {
                get
                {
                    return ((__Internal*)__Instance)->y_top;
                }

                set
                {
                    ((__Internal*)__Instance)->y_top = value;
                }
            }

            public int YBottom
            {
                get
                {
                    return ((__Internal*)__Instance)->y_bottom;
                }

                set
                {
                    ((__Internal*)__Instance)->y_bottom = value;
                }
            }

            public byte OpaTop
            {
                get
                {
                    return ((__Internal*)__Instance)->opa_top;
                }

                set
                {
                    ((__Internal*)__Instance)->opa_top = value;
                }
            }

            public byte OpaBottom
            {
                get
                {
                    return ((__Internal*)__Instance)->opa_bottom;
                }

                set
                {
                    ((__Internal*)__Instance)->opa_bottom = value;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskFadeParamT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskFadeParamT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawSwMaskFadeParamT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawSwMaskFadeParamT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawSwMaskFadeParamT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawSwMaskFadeParamT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawSwMaskFadeParamT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawSwMaskFadeParamT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawSwMaskFadeParamT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawSwMaskFadeParamT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawSwMaskFadeParamT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawSwMaskFadeParamT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawSwMaskFadeParamT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskFadeParamT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawSwMaskFadeParamT(global::lvgl.LvDrawSwMaskFadeParamT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskFadeParamT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawSwMaskFadeParamT.__Internal*) __Instance) = *((global::lvgl.LvDrawSwMaskFadeParamT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawSwMaskCommonDscT Dsc
        {
            get
            {
                return global::lvgl.LvDrawSwMaskCommonDscT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->dsc));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->dsc = *(global::lvgl.LvDrawSwMaskCommonDscT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvDrawSwMaskFadeParamT.Cfg cfg
        {
            get
            {
                return global::lvgl.LvDrawSwMaskFadeParamT.Cfg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->cfg));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->cfg = *(global::lvgl.LvDrawSwMaskFadeParamT.Cfg.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class LvDrawSwMaskMapParamT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal global::lvgl.LvDrawSwMaskCommonDscT.__Internal dsc;
            internal global::lvgl.LvDrawSwMaskMapParamT.Cfg.__Internal cfg;

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0_lv_draw_sw_mask_map_param_t@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial class Cfg : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public partial struct __Internal
            {
                internal global::lvgl.LvAreaT.__Internal coords;
                internal __IntPtr map;

                [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "??0<unnamed-type-cfg>@_lv_draw_sw_mask_map_param_t@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskMapParamT.Cfg> NativeToManagedMap =
                new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskMapParamT.Cfg>();

            internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawSwMaskMapParamT.Cfg managed)
            {
                NativeToManagedMap[native] = managed;
            }

            internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawSwMaskMapParamT.Cfg managed)
            {
    
                return NativeToManagedMap.TryGetValue(native, out managed);
            }

            protected bool __ownsNativeInstance;

            internal static Cfg __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                return new Cfg(native.ToPointer(), skipVTables);
            }

            internal static Cfg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (__TryGetNativeToManagedMapping(native, out var managed))
                    return (Cfg)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    __RecordNativeToManagedMapping(native, result);
                return result;
            }

            internal static Cfg __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Cfg(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Cfg(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            protected Cfg(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Cfg()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskMapParamT.Cfg.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
            }

            public Cfg(global::lvgl.LvDrawSwMaskMapParamT.Cfg _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskMapParamT.Cfg.__Internal));
                __ownsNativeInstance = true;
                __RecordNativeToManagedMapping(__Instance, this);
                *((global::lvgl.LvDrawSwMaskMapParamT.Cfg.__Internal*) __Instance) = *((global::lvgl.LvDrawSwMaskMapParamT.Cfg.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::lvgl.LvAreaT Coords
            {
                get
                {
                    return global::lvgl.LvAreaT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->coords));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->coords = *(global::lvgl.LvAreaT.__Internal*) value.__Instance;
                }
            }

            public byte* Map
            {
                get
                {
                    return (byte*) ((__Internal*)__Instance)->map;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskMapParamT> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::lvgl.LvDrawSwMaskMapParamT>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::lvgl.LvDrawSwMaskMapParamT managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::lvgl.LvDrawSwMaskMapParamT managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LvDrawSwMaskMapParamT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LvDrawSwMaskMapParamT(native.ToPointer(), skipVTables);
        }

        internal static LvDrawSwMaskMapParamT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LvDrawSwMaskMapParamT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LvDrawSwMaskMapParamT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LvDrawSwMaskMapParamT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LvDrawSwMaskMapParamT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LvDrawSwMaskMapParamT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public LvDrawSwMaskMapParamT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskMapParamT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public LvDrawSwMaskMapParamT(global::lvgl.LvDrawSwMaskMapParamT _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::lvgl.LvDrawSwMaskMapParamT.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::lvgl.LvDrawSwMaskMapParamT.__Internal*) __Instance) = *((global::lvgl.LvDrawSwMaskMapParamT.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::lvgl.LvDrawSwMaskCommonDscT Dsc
        {
            get
            {
                return global::lvgl.LvDrawSwMaskCommonDscT.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->dsc));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->dsc = *(global::lvgl.LvDrawSwMaskCommonDscT.__Internal*) value.__Instance;
            }
        }

        public global::lvgl.LvDrawSwMaskMapParamT.Cfg cfg
        {
            get
            {
                return global::lvgl.LvDrawSwMaskMapParamT.Cfg.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->cfg));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->cfg = *(global::lvgl.LvDrawSwMaskMapParamT.Cfg.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class lv_draw_sw_mask
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_mask_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwMaskInit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_mask_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwMaskDeinit();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_mask_apply", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte LvDrawSwMaskApply(__IntPtr[] masks, byte* mask_buf, int abs_x, int abs_y, int len);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_mask_free_param", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwMaskFreeParam(__IntPtr p);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "_lv_draw_sw_mask_cleanup", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwMaskCleanup();

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_mask_line_points_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwMaskLinePointsInit(__IntPtr param, int p1x, int p1y, int p2x, int p2y, byte side);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_mask_line_angle_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwMaskLineAngleInit(__IntPtr param, int p1x, int py, short angle, byte side);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_mask_angle_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwMaskAngleInit(__IntPtr param, int vertex_x, int vertex_y, int start_angle, int end_angle);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_mask_radius_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwMaskRadiusInit(__IntPtr param, __IntPtr rect, int radius, bool inv);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_mask_fade_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwMaskFadeInit(__IntPtr param, __IntPtr coords, byte opa_top, int y_top, byte opa_bottom, int y_bottom);

            [SuppressUnmanagedCodeSecurity, DllImport("lvgl", EntryPoint = "lv_draw_sw_mask_map_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LvDrawSwMaskMapInit(__IntPtr param, __IntPtr coords, byte* map);
        }

        /// <summary>
        /// <para>********************</para>
        /// <para>GLOBAL PROTOTYPES</para>
        /// <para>********************</para>
        /// </summary>
        public static void LvDrawSwMaskInit()
        {
            __Internal.LvDrawSwMaskInit();
        }

        public static void LvDrawSwMaskDeinit()
        {
            __Internal.LvDrawSwMaskDeinit();
        }

        /// <summary>Apply the added buffers on a line. Used internally by the library's drawing routines.</summary>
        /// <param name="masks">the masks list to apply, must be ended with NULL pointer in array.</param>
        /// <param name="mask_buf">store the result mask here. Has to be `len` byte long. Should be initialized with `0xFF`.</param>
        /// <param name="abs_x">absolute X coordinate where the line to calculate start</param>
        /// <param name="abs_y">absolute Y coordinate where the line to calculate start</param>
        /// <param name="len">length of the line to calculate (in pixel count)</param>
        /// <returns>
        /// <para>One of these values:</para>
        /// <para>- `LV_DRAW_MASK_RES_FULL_TRANSP`: the whole line is transparent. `mask_buf` is not set to zero</para>
        /// <para>- `LV_DRAW_MASK_RES_FULL_COVER`: the whole line is fully visible. `mask_buf` is unchanged</para>
        /// <para>- `LV_DRAW_MASK_RES_CHANGED`: `mask_buf` has changed, it shows the desired opacity of each pixel in the given line</para>
        /// </returns>
        public static byte LvDrawSwMaskApply(__IntPtr[] masks, byte* mask_buf, int abs_x, int abs_y, int len)
        {
            var ___ret = __Internal.LvDrawSwMaskApply(masks, mask_buf, abs_x, abs_y, len);
            return ___ret;
        }

        /// <summary>
        /// <para>Free the data from the parameter.</para>
        /// <para>It's called inside `lv_draw_sw_mask_remove_id` and `lv_draw_sw_mask_remove_custom`</para>
        /// <para>Needs to be called only in special cases when the mask is not added by `lv_draw_mask_add`</para>
        /// <para>and not removed by `lv_draw_mask_remove_id` or `lv_draw_mask_remove_custom`</para>
        /// </summary>
        /// <param name="p">pointer to a mask parameter</param>
        public static void LvDrawSwMaskFreeParam(__IntPtr p)
        {
            __Internal.LvDrawSwMaskFreeParam(p);
        }

        /// <summary>
        /// <para>Called by LVGL the rendering of a screen is ready to clean up</para>
        /// <para>the temporal (cache) data of the masks</para>
        /// </summary>
        public static void LvDrawSwMaskCleanup()
        {
            __Internal.LvDrawSwMaskCleanup();
        }

        /// <summary>Initialize a line mask from two points.</summary>
        /// <param name="param">pointer to a `lv_draw_mask_param_t` to initialize</param>
        /// <param name="p1x">X coordinate of the first point of the line</param>
        /// <param name="p1y">Y coordinate of the first point of the line</param>
        /// <param name="p2x">X coordinate of the second point of the line</param>
        /// <param name="p2y">y coordinate of the second point of the line</param>
        /// <param name="side">
        /// <para>and element of `lv_draw_mask_line_side_t` to describe which side to keep.</para>
        /// <para>With `LV_DRAW_MASK_LINE_SIDE_LEFT/RIGHT` and horizontal line all pixels are kept</para>
        /// <para>With `LV_DRAW_MASK_LINE_SIDE_TOP/BOTTOM` and vertical line all pixels are kept</para>
        /// </param>
        public static void LvDrawSwMaskLinePointsInit(global::lvgl.LvDrawSwMaskLineParamT param, int p1x, int p1y, int p2x, int p2y, byte side)
        {
            var __arg0 = param is null ? __IntPtr.Zero : param.__Instance;
            __Internal.LvDrawSwMaskLinePointsInit(__arg0, p1x, p1y, p2x, p2y, side);
        }

        /// <summary>Initialize a line mask from a point and an angle.</summary>
        /// <param name="param">pointer to a `lv_draw_mask_param_t` to initialize</param>
        /// <param name="px">X coordinate of a point of the line</param>
        /// <param name="py">X coordinate of a point of the line</param>
        /// <param name="angle">right 0 deg, bottom: 90</param>
        /// <param name="side">
        /// <para>and element of `lv_draw_mask_line_side_t` to describe which side to keep.</para>
        /// <para>With `LV_DRAW_MASK_LINE_SIDE_LEFT/RIGHT` and horizontal line all pixels are kept</para>
        /// <para>With `LV_DRAW_MASK_LINE_SIDE_TOP/BOTTOM` and vertical line all pixels are kept</para>
        /// </param>
        public static void LvDrawSwMaskLineAngleInit(global::lvgl.LvDrawSwMaskLineParamT param, int p1x, int py, short angle, byte side)
        {
            var __arg0 = param is null ? __IntPtr.Zero : param.__Instance;
            __Internal.LvDrawSwMaskLineAngleInit(__arg0, p1x, py, angle, side);
        }

        /// <summary>Initialize an angle mask.</summary>
        /// <param name="param">pointer to a `lv_draw_mask_param_t` to initialize</param>
        /// <param name="vertex_x">X coordinate of the angle vertex (absolute coordinates)</param>
        /// <param name="vertex_y">Y coordinate of the angle vertex (absolute coordinates)</param>
        /// <param name="start_angle">start angle in degrees. 0 deg on the right, 90 deg, on the bottom</param>
        /// <param name="end_angle">end angle</param>
        public static void LvDrawSwMaskAngleInit(global::lvgl.LvDrawSwMaskAngleParamT param, int vertex_x, int vertex_y, int start_angle, int end_angle)
        {
            var __arg0 = param is null ? __IntPtr.Zero : param.__Instance;
            __Internal.LvDrawSwMaskAngleInit(__arg0, vertex_x, vertex_y, start_angle, end_angle);
        }

        /// <summary>Initialize a fade mask.</summary>
        /// <param name="param">pointer to an `lv_draw_mask_radius_param_t` to initialize</param>
        /// <param name="rect">coordinates of the rectangle to affect (absolute coordinates)</param>
        /// <param name="radius">radius of the rectangle</param>
        /// <param name="inv">true: keep the pixels inside the rectangle; keep the pixels outside of the rectangle</param>
        public static void LvDrawSwMaskRadiusInit(global::lvgl.LvDrawSwMaskRadiusParamT param, global::lvgl.LvAreaT rect, int radius, bool inv)
        {
            var __arg0 = param is null ? __IntPtr.Zero : param.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            __Internal.LvDrawSwMaskRadiusInit(__arg0, __arg1, radius, inv);
        }

        /// <summary>Initialize a fade mask.</summary>
        /// <param name="param">pointer to a `lv_draw_mask_param_t` to initialize</param>
        /// <param name="coords">coordinates of the area to affect (absolute coordinates)</param>
        /// <param name="opa_top">opacity on the top</param>
        /// <param name="y_top">at which coordinate start to change to opacity to `opa_bottom`</param>
        /// <param name="opa_bottom">opacity at the bottom</param>
        /// <param name="y_bottom">at which coordinate reach `opa_bottom`.</param>
        public static void LvDrawSwMaskFadeInit(global::lvgl.LvDrawSwMaskFadeParamT param, global::lvgl.LvAreaT coords, byte opa_top, int y_top, byte opa_bottom, int y_bottom)
        {
            var __arg0 = param is null ? __IntPtr.Zero : param.__Instance;
            var __arg1 = coords is null ? __IntPtr.Zero : coords.__Instance;
            __Internal.LvDrawSwMaskFadeInit(__arg0, __arg1, opa_top, y_top, opa_bottom, y_bottom);
        }

        /// <summary>Initialize a map mask.</summary>
        /// <param name="param">pointer to a `lv_draw_mask_param_t` to initialize</param>
        /// <param name="coords">coordinates of the map (absolute coordinates)</param>
        /// <param name="map">array of bytes with the mask values</param>
        public static void LvDrawSwMaskMapInit(global::lvgl.LvDrawSwMaskMapParamT param, global::lvgl.LvAreaT coords, byte* map)
        {
            var __arg0 = param is null ? __IntPtr.Zero : param.__Instance;
            var __arg1 = coords is null ? __IntPtr.Zero : coords.__Instance;
            __Internal.LvDrawSwMaskMapInit(__arg0, __arg1, map);
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr(__IntPtr class_p, __IntPtr obj);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr___IntPtr(__IntPtr draw_unit, __IntPtr layer);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr(__IntPtr draw_unit);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        public unsafe delegate bool Func_bool___IntPtr___IntPtr_uint_uint(__IntPtr __0, __IntPtr __1, uint letter, uint letter_next);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr(__IntPtr __0, __IntPtr __1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr(__IntPtr __0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        public unsafe delegate bool Func_bool___IntPtr(__IntPtr drv);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr___IntPtr_string8_byte(__IntPtr drv, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path, byte mode);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate byte Func_byte___IntPtr___IntPtr(__IntPtr drv, __IntPtr file_p);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate byte Func_byte___IntPtr___IntPtr___IntPtr_uint_uintPtr(__IntPtr drv, __IntPtr file_p, __IntPtr buf, uint btr, uint* br);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate byte Func_byte___IntPtr___IntPtr_uint_lvgl_lv_fs_whence_t(__IntPtr drv, __IntPtr file_p, uint pos, global::lvgl.LvFsWhenceT whence);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate byte Func_byte___IntPtr___IntPtr_uintPtr(__IntPtr drv, __IntPtr file_p, uint* pos_p);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr___IntPtr_string8(__IntPtr drv, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate byte Func_byte___IntPtr___IntPtr_sbytePtr_uint(__IntPtr drv, __IntPtr rddir_p, sbyte* fn, uint fn_len);
    }
}
namespace lvgl.__Symbols
{
    internal class lvgl
    {
        public static IntPtr _lv_obj_class { get; }
        public static IntPtr _lv_style_const_prop_id_inv { get; }
        public static IntPtr _lv_font_montserrat_14 { get; }
        public static IntPtr _lv_color_filter_shade { get; }
        public static IntPtr _lv_style_const_prop_id_WIDTH { get; }
        public static IntPtr _lv_style_const_prop_id_MIN_WIDTH { get; }
        public static IntPtr _lv_style_const_prop_id_MAX_WIDTH { get; }
        public static IntPtr _lv_style_const_prop_id_HEIGHT { get; }
        public static IntPtr _lv_style_const_prop_id_MIN_HEIGHT { get; }
        public static IntPtr _lv_style_const_prop_id_MAX_HEIGHT { get; }
        public static IntPtr _lv_style_const_prop_id_LENGTH { get; }
        public static IntPtr _lv_style_const_prop_id_X { get; }
        public static IntPtr _lv_style_const_prop_id_Y { get; }
        public static IntPtr _lv_style_const_prop_id_ALIGN { get; }
        public static IntPtr _lv_style_const_prop_id_TRANSFORM_WIDTH { get; }
        public static IntPtr _lv_style_const_prop_id_TRANSFORM_HEIGHT { get; }
        public static IntPtr _lv_style_const_prop_id_TRANSLATE_X { get; }
        public static IntPtr _lv_style_const_prop_id_TRANSLATE_Y { get; }
        public static IntPtr _lv_style_const_prop_id_TRANSFORM_SCALE_X { get; }
        public static IntPtr _lv_style_const_prop_id_TRANSFORM_SCALE_Y { get; }
        public static IntPtr _lv_style_const_prop_id_TRANSFORM_ROTATION { get; }
        public static IntPtr _lv_style_const_prop_id_TRANSFORM_PIVOT_X { get; }
        public static IntPtr _lv_style_const_prop_id_TRANSFORM_PIVOT_Y { get; }
        public static IntPtr _lv_style_const_prop_id_TRANSFORM_SKEW_X { get; }
        public static IntPtr _lv_style_const_prop_id_TRANSFORM_SKEW_Y { get; }
        public static IntPtr _lv_style_const_prop_id_PAD_TOP { get; }
        public static IntPtr _lv_style_const_prop_id_PAD_BOTTOM { get; }
        public static IntPtr _lv_style_const_prop_id_PAD_LEFT { get; }
        public static IntPtr _lv_style_const_prop_id_PAD_RIGHT { get; }
        public static IntPtr _lv_style_const_prop_id_PAD_ROW { get; }
        public static IntPtr _lv_style_const_prop_id_PAD_COLUMN { get; }
        public static IntPtr _lv_style_const_prop_id_MARGIN_TOP { get; }
        public static IntPtr _lv_style_const_prop_id_MARGIN_BOTTOM { get; }
        public static IntPtr _lv_style_const_prop_id_MARGIN_LEFT { get; }
        public static IntPtr _lv_style_const_prop_id_MARGIN_RIGHT { get; }
        public static IntPtr _lv_style_const_prop_id_BG_COLOR { get; }
        public static IntPtr _lv_style_const_prop_id_BG_OPA { get; }
        public static IntPtr _lv_style_const_prop_id_BG_GRAD_COLOR { get; }
        public static IntPtr _lv_style_const_prop_id_BG_GRAD_DIR { get; }
        public static IntPtr _lv_style_const_prop_id_BG_MAIN_STOP { get; }
        public static IntPtr _lv_style_const_prop_id_BG_GRAD_STOP { get; }
        public static IntPtr _lv_style_const_prop_id_BG_MAIN_OPA { get; }
        public static IntPtr _lv_style_const_prop_id_BG_GRAD_OPA { get; }
        public static IntPtr _lv_style_const_prop_id_BG_GRAD { get; }
        public static IntPtr _lv_style_const_prop_id_BG_IMAGE_SRC { get; }
        public static IntPtr _lv_style_const_prop_id_BG_IMAGE_OPA { get; }
        public static IntPtr _lv_style_const_prop_id_BG_IMAGE_RECOLOR { get; }
        public static IntPtr _lv_style_const_prop_id_BG_IMAGE_RECOLOR_OPA { get; }
        public static IntPtr _lv_style_const_prop_id_BG_IMAGE_TILED { get; }
        public static IntPtr _lv_style_const_prop_id_BORDER_COLOR { get; }
        public static IntPtr _lv_style_const_prop_id_BORDER_OPA { get; }
        public static IntPtr _lv_style_const_prop_id_BORDER_WIDTH { get; }
        public static IntPtr _lv_style_const_prop_id_BORDER_SIDE { get; }
        public static IntPtr _lv_style_const_prop_id_BORDER_POST { get; }
        public static IntPtr _lv_style_const_prop_id_OUTLINE_WIDTH { get; }
        public static IntPtr _lv_style_const_prop_id_OUTLINE_COLOR { get; }
        public static IntPtr _lv_style_const_prop_id_OUTLINE_OPA { get; }
        public static IntPtr _lv_style_const_prop_id_OUTLINE_PAD { get; }
        public static IntPtr _lv_style_const_prop_id_SHADOW_WIDTH { get; }
        public static IntPtr _lv_style_const_prop_id_SHADOW_OFFSET_X { get; }
        public static IntPtr _lv_style_const_prop_id_SHADOW_OFFSET_Y { get; }
        public static IntPtr _lv_style_const_prop_id_SHADOW_SPREAD { get; }
        public static IntPtr _lv_style_const_prop_id_SHADOW_COLOR { get; }
        public static IntPtr _lv_style_const_prop_id_SHADOW_OPA { get; }
        public static IntPtr _lv_style_const_prop_id_IMAGE_OPA { get; }
        public static IntPtr _lv_style_const_prop_id_IMAGE_RECOLOR { get; }
        public static IntPtr _lv_style_const_prop_id_IMAGE_RECOLOR_OPA { get; }
        public static IntPtr _lv_style_const_prop_id_LINE_WIDTH { get; }
        public static IntPtr _lv_style_const_prop_id_LINE_DASH_WIDTH { get; }
        public static IntPtr _lv_style_const_prop_id_LINE_DASH_GAP { get; }
        public static IntPtr _lv_style_const_prop_id_LINE_ROUNDED { get; }
        public static IntPtr _lv_style_const_prop_id_LINE_COLOR { get; }
        public static IntPtr _lv_style_const_prop_id_LINE_OPA { get; }
        public static IntPtr _lv_style_const_prop_id_ARC_WIDTH { get; }
        public static IntPtr _lv_style_const_prop_id_ARC_ROUNDED { get; }
        public static IntPtr _lv_style_const_prop_id_ARC_COLOR { get; }
        public static IntPtr _lv_style_const_prop_id_ARC_OPA { get; }
        public static IntPtr _lv_style_const_prop_id_ARC_IMAGE_SRC { get; }
        public static IntPtr _lv_style_const_prop_id_TEXT_COLOR { get; }
        public static IntPtr _lv_style_const_prop_id_TEXT_OPA { get; }
        public static IntPtr _lv_style_const_prop_id_TEXT_FONT { get; }
        public static IntPtr _lv_style_const_prop_id_TEXT_LETTER_SPACE { get; }
        public static IntPtr _lv_style_const_prop_id_TEXT_LINE_SPACE { get; }
        public static IntPtr _lv_style_const_prop_id_TEXT_DECOR { get; }
        public static IntPtr _lv_style_const_prop_id_TEXT_ALIGN { get; }
        public static IntPtr _lv_style_const_prop_id_RADIUS { get; }
        public static IntPtr _lv_style_const_prop_id_CLIP_CORNER { get; }
        public static IntPtr _lv_style_const_prop_id_OPA { get; }
        public static IntPtr _lv_style_const_prop_id_OPA_LAYERED { get; }
        public static IntPtr _lv_style_const_prop_id_COLOR_FILTER_DSC { get; }
        public static IntPtr _lv_style_const_prop_id_COLOR_FILTER_OPA { get; }
        public static IntPtr _lv_style_const_prop_id_ANIM { get; }
        public static IntPtr _lv_style_const_prop_id_ANIM_DURATION { get; }
        public static IntPtr _lv_style_const_prop_id_TRANSITION { get; }
        public static IntPtr _lv_style_const_prop_id_BLEND_MODE { get; }
        public static IntPtr _lv_style_const_prop_id_LAYOUT { get; }
        public static IntPtr _lv_style_const_prop_id_BASE_DIR { get; }
        public static IntPtr _lv_style_const_prop_id_BITMAP_MASK_SRC { get; }
        public static IntPtr _lv_style_const_prop_id_ROTARY_SENSITIVITY { get; }
        public static IntPtr _lv_style_const_prop_id_FLEX_FLOW { get; }
        public static IntPtr _lv_style_const_prop_id_FLEX_MAIN_PLACE { get; }
        public static IntPtr _lv_style_const_prop_id_FLEX_CROSS_PLACE { get; }
        public static IntPtr _lv_style_const_prop_id_FLEX_TRACK_PLACE { get; }
        public static IntPtr _lv_style_const_prop_id_FLEX_GROW { get; }
        public static IntPtr _lv_style_const_prop_id_GRID_COLUMN_DSC_ARRAY { get; }
        public static IntPtr _lv_style_const_prop_id_GRID_COLUMN_ALIGN { get; }
        public static IntPtr _lv_style_const_prop_id_GRID_ROW_DSC_ARRAY { get; }
        public static IntPtr _lv_style_const_prop_id_GRID_ROW_ALIGN { get; }
        public static IntPtr _lv_style_const_prop_id_GRID_CELL_COLUMN_POS { get; }
        public static IntPtr _lv_style_const_prop_id_GRID_CELL_X_ALIGN { get; }
        public static IntPtr _lv_style_const_prop_id_GRID_CELL_COLUMN_SPAN { get; }
        public static IntPtr _lv_style_const_prop_id_GRID_CELL_ROW_POS { get; }
        public static IntPtr _lv_style_const_prop_id_GRID_CELL_Y_ALIGN { get; }
        public static IntPtr _lv_style_const_prop_id_GRID_CELL_ROW_SPAN { get; }
        public static IntPtr _lv_animimg_class { get; }
        public static IntPtr _lv_image_class { get; }
        public static IntPtr _lv_arc_class { get; }
        public static IntPtr _lv_bar_class { get; }
        public static IntPtr _lv_label_class { get; }
        public static IntPtr _lv_button_class { get; }
        public static IntPtr _lv_buttonmatrix_class { get; }
        public static IntPtr _lv_calendar_class { get; }
        public static IntPtr _lv_calendar_header_arrow_class { get; }
        public static IntPtr _lv_calendar_header_dropdown_class { get; }
        public static IntPtr _lv_canvas_class { get; }
        public static IntPtr _lv_chart_class { get; }
        public static IntPtr _lv_checkbox_class { get; }
        public static IntPtr _lv_dropdown_class { get; }
        public static IntPtr _lv_dropdownlist_class { get; }
        public static IntPtr _lv_imagebutton_class { get; }
        public static IntPtr _lv_keyboard_class { get; }
        public static IntPtr _lv_led_class { get; }
        public static IntPtr _lv_line_class { get; }
        public static IntPtr _lv_list_class { get; }
        public static IntPtr _lv_list_text_class { get; }
        public static IntPtr _lv_list_button_class { get; }
        public static IntPtr _lv_menu_class { get; }
        public static IntPtr _lv_menu_page_class { get; }
        public static IntPtr _lv_menu_cont_class { get; }
        public static IntPtr _lv_menu_section_class { get; }
        public static IntPtr _lv_menu_separator_class { get; }
        public static IntPtr _lv_menu_sidebar_cont_class { get; }
        public static IntPtr _lv_menu_main_cont_class { get; }
        public static IntPtr _lv_menu_sidebar_header_cont_class { get; }
        public static IntPtr _lv_menu_main_header_cont_class { get; }
        public static IntPtr _lv_msgbox_class { get; }
        public static IntPtr _lv_msgbox_header_class { get; }
        public static IntPtr _lv_msgbox_content_class { get; }
        public static IntPtr _lv_msgbox_footer_class { get; }
        public static IntPtr _lv_msgbox_header_button_class { get; }
        public static IntPtr _lv_msgbox_footer_button_class { get; }
        public static IntPtr _lv_msgbox_backdrop_class { get; }
        public static IntPtr _lv_roller_class { get; }
        public static IntPtr _lv_scale_class { get; }
        public static IntPtr _lv_slider_class { get; }
        public static IntPtr _lv_spangroup_class { get; }
        public static IntPtr _lv_spinbox_class { get; }
        public static IntPtr _lv_textarea_class { get; }
        public static IntPtr _lv_spinner_class { get; }
        public static IntPtr _lv_switch_class { get; }
        public static IntPtr _lv_table_class { get; }
        public static IntPtr _lv_tabview_class { get; }
        public static IntPtr _lv_tileview_class { get; }
        public static IntPtr _lv_tileview_tile_class { get; }
        public static IntPtr _lv_win_class { get; }
        public static IntPtr _lv_global { get; }
        static lvgl()
        {
            var path = "lvgl";
            var image = CppSharp.SymbolResolver.LoadImage(ref path);
            if (image == IntPtr.Zero) throw new global::System.DllNotFoundException(path);
            _lv_obj_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_obj_class");
            _lv_style_const_prop_id_inv = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_style_const_prop_id_inv");
            _lv_font_montserrat_14 = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_font_montserrat_14");
            _lv_color_filter_shade = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_color_filter_shade");
            _lv_style_const_prop_id_WIDTH = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_WIDTH");
            _lv_style_const_prop_id_MIN_WIDTH = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_MIN_WIDTH");
            _lv_style_const_prop_id_MAX_WIDTH = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_MAX_WIDTH");
            _lv_style_const_prop_id_HEIGHT = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_HEIGHT");
            _lv_style_const_prop_id_MIN_HEIGHT = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_MIN_HEIGHT");
            _lv_style_const_prop_id_MAX_HEIGHT = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_MAX_HEIGHT");
            _lv_style_const_prop_id_LENGTH = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_LENGTH");
            _lv_style_const_prop_id_X = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_X");
            _lv_style_const_prop_id_Y = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_Y");
            _lv_style_const_prop_id_ALIGN = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_ALIGN");
            _lv_style_const_prop_id_TRANSFORM_WIDTH = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TRANSFORM_WIDTH");
            _lv_style_const_prop_id_TRANSFORM_HEIGHT = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TRANSFORM_HEIGHT");
            _lv_style_const_prop_id_TRANSLATE_X = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TRANSLATE_X");
            _lv_style_const_prop_id_TRANSLATE_Y = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TRANSLATE_Y");
            _lv_style_const_prop_id_TRANSFORM_SCALE_X = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TRANSFORM_SCALE_X");
            _lv_style_const_prop_id_TRANSFORM_SCALE_Y = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TRANSFORM_SCALE_Y");
            _lv_style_const_prop_id_TRANSFORM_ROTATION = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TRANSFORM_ROTATION");
            _lv_style_const_prop_id_TRANSFORM_PIVOT_X = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TRANSFORM_PIVOT_X");
            _lv_style_const_prop_id_TRANSFORM_PIVOT_Y = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TRANSFORM_PIVOT_Y");
            _lv_style_const_prop_id_TRANSFORM_SKEW_X = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TRANSFORM_SKEW_X");
            _lv_style_const_prop_id_TRANSFORM_SKEW_Y = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TRANSFORM_SKEW_Y");
            _lv_style_const_prop_id_PAD_TOP = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_PAD_TOP");
            _lv_style_const_prop_id_PAD_BOTTOM = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_PAD_BOTTOM");
            _lv_style_const_prop_id_PAD_LEFT = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_PAD_LEFT");
            _lv_style_const_prop_id_PAD_RIGHT = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_PAD_RIGHT");
            _lv_style_const_prop_id_PAD_ROW = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_PAD_ROW");
            _lv_style_const_prop_id_PAD_COLUMN = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_PAD_COLUMN");
            _lv_style_const_prop_id_MARGIN_TOP = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_MARGIN_TOP");
            _lv_style_const_prop_id_MARGIN_BOTTOM = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_MARGIN_BOTTOM");
            _lv_style_const_prop_id_MARGIN_LEFT = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_MARGIN_LEFT");
            _lv_style_const_prop_id_MARGIN_RIGHT = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_MARGIN_RIGHT");
            _lv_style_const_prop_id_BG_COLOR = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BG_COLOR");
            _lv_style_const_prop_id_BG_OPA = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BG_OPA");
            _lv_style_const_prop_id_BG_GRAD_COLOR = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BG_GRAD_COLOR");
            _lv_style_const_prop_id_BG_GRAD_DIR = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BG_GRAD_DIR");
            _lv_style_const_prop_id_BG_MAIN_STOP = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BG_MAIN_STOP");
            _lv_style_const_prop_id_BG_GRAD_STOP = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BG_GRAD_STOP");
            _lv_style_const_prop_id_BG_MAIN_OPA = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BG_MAIN_OPA");
            _lv_style_const_prop_id_BG_GRAD_OPA = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BG_GRAD_OPA");
            _lv_style_const_prop_id_BG_GRAD = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BG_GRAD");
            _lv_style_const_prop_id_BG_IMAGE_SRC = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BG_IMAGE_SRC");
            _lv_style_const_prop_id_BG_IMAGE_OPA = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BG_IMAGE_OPA");
            _lv_style_const_prop_id_BG_IMAGE_RECOLOR = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BG_IMAGE_RECOLOR");
            _lv_style_const_prop_id_BG_IMAGE_RECOLOR_OPA = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BG_IMAGE_RECOLOR_OPA");
            _lv_style_const_prop_id_BG_IMAGE_TILED = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BG_IMAGE_TILED");
            _lv_style_const_prop_id_BORDER_COLOR = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BORDER_COLOR");
            _lv_style_const_prop_id_BORDER_OPA = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BORDER_OPA");
            _lv_style_const_prop_id_BORDER_WIDTH = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BORDER_WIDTH");
            _lv_style_const_prop_id_BORDER_SIDE = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BORDER_SIDE");
            _lv_style_const_prop_id_BORDER_POST = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BORDER_POST");
            _lv_style_const_prop_id_OUTLINE_WIDTH = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_OUTLINE_WIDTH");
            _lv_style_const_prop_id_OUTLINE_COLOR = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_OUTLINE_COLOR");
            _lv_style_const_prop_id_OUTLINE_OPA = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_OUTLINE_OPA");
            _lv_style_const_prop_id_OUTLINE_PAD = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_OUTLINE_PAD");
            _lv_style_const_prop_id_SHADOW_WIDTH = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_SHADOW_WIDTH");
            _lv_style_const_prop_id_SHADOW_OFFSET_X = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_SHADOW_OFFSET_X");
            _lv_style_const_prop_id_SHADOW_OFFSET_Y = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_SHADOW_OFFSET_Y");
            _lv_style_const_prop_id_SHADOW_SPREAD = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_SHADOW_SPREAD");
            _lv_style_const_prop_id_SHADOW_COLOR = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_SHADOW_COLOR");
            _lv_style_const_prop_id_SHADOW_OPA = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_SHADOW_OPA");
            _lv_style_const_prop_id_IMAGE_OPA = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_IMAGE_OPA");
            _lv_style_const_prop_id_IMAGE_RECOLOR = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_IMAGE_RECOLOR");
            _lv_style_const_prop_id_IMAGE_RECOLOR_OPA = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_IMAGE_RECOLOR_OPA");
            _lv_style_const_prop_id_LINE_WIDTH = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_LINE_WIDTH");
            _lv_style_const_prop_id_LINE_DASH_WIDTH = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_LINE_DASH_WIDTH");
            _lv_style_const_prop_id_LINE_DASH_GAP = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_LINE_DASH_GAP");
            _lv_style_const_prop_id_LINE_ROUNDED = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_LINE_ROUNDED");
            _lv_style_const_prop_id_LINE_COLOR = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_LINE_COLOR");
            _lv_style_const_prop_id_LINE_OPA = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_LINE_OPA");
            _lv_style_const_prop_id_ARC_WIDTH = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_ARC_WIDTH");
            _lv_style_const_prop_id_ARC_ROUNDED = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_ARC_ROUNDED");
            _lv_style_const_prop_id_ARC_COLOR = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_ARC_COLOR");
            _lv_style_const_prop_id_ARC_OPA = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_ARC_OPA");
            _lv_style_const_prop_id_ARC_IMAGE_SRC = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_ARC_IMAGE_SRC");
            _lv_style_const_prop_id_TEXT_COLOR = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TEXT_COLOR");
            _lv_style_const_prop_id_TEXT_OPA = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TEXT_OPA");
            _lv_style_const_prop_id_TEXT_FONT = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TEXT_FONT");
            _lv_style_const_prop_id_TEXT_LETTER_SPACE = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TEXT_LETTER_SPACE");
            _lv_style_const_prop_id_TEXT_LINE_SPACE = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TEXT_LINE_SPACE");
            _lv_style_const_prop_id_TEXT_DECOR = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TEXT_DECOR");
            _lv_style_const_prop_id_TEXT_ALIGN = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TEXT_ALIGN");
            _lv_style_const_prop_id_RADIUS = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_RADIUS");
            _lv_style_const_prop_id_CLIP_CORNER = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_CLIP_CORNER");
            _lv_style_const_prop_id_OPA = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_OPA");
            _lv_style_const_prop_id_OPA_LAYERED = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_OPA_LAYERED");
            _lv_style_const_prop_id_COLOR_FILTER_DSC = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_COLOR_FILTER_DSC");
            _lv_style_const_prop_id_COLOR_FILTER_OPA = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_COLOR_FILTER_OPA");
            _lv_style_const_prop_id_ANIM = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_ANIM");
            _lv_style_const_prop_id_ANIM_DURATION = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_ANIM_DURATION");
            _lv_style_const_prop_id_TRANSITION = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_TRANSITION");
            _lv_style_const_prop_id_BLEND_MODE = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BLEND_MODE");
            _lv_style_const_prop_id_LAYOUT = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_LAYOUT");
            _lv_style_const_prop_id_BASE_DIR = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BASE_DIR");
            _lv_style_const_prop_id_BITMAP_MASK_SRC = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_BITMAP_MASK_SRC");
            _lv_style_const_prop_id_ROTARY_SENSITIVITY = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_ROTARY_SENSITIVITY");
            _lv_style_const_prop_id_FLEX_FLOW = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_FLEX_FLOW");
            _lv_style_const_prop_id_FLEX_MAIN_PLACE = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_FLEX_MAIN_PLACE");
            _lv_style_const_prop_id_FLEX_CROSS_PLACE = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_FLEX_CROSS_PLACE");
            _lv_style_const_prop_id_FLEX_TRACK_PLACE = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_FLEX_TRACK_PLACE");
            _lv_style_const_prop_id_FLEX_GROW = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_FLEX_GROW");
            _lv_style_const_prop_id_GRID_COLUMN_DSC_ARRAY = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_GRID_COLUMN_DSC_ARRAY");
            _lv_style_const_prop_id_GRID_COLUMN_ALIGN = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_GRID_COLUMN_ALIGN");
            _lv_style_const_prop_id_GRID_ROW_DSC_ARRAY = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_GRID_ROW_DSC_ARRAY");
            _lv_style_const_prop_id_GRID_ROW_ALIGN = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_GRID_ROW_ALIGN");
            _lv_style_const_prop_id_GRID_CELL_COLUMN_POS = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_GRID_CELL_COLUMN_POS");
            _lv_style_const_prop_id_GRID_CELL_X_ALIGN = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_GRID_CELL_X_ALIGN");
            _lv_style_const_prop_id_GRID_CELL_COLUMN_SPAN = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_GRID_CELL_COLUMN_SPAN");
            _lv_style_const_prop_id_GRID_CELL_ROW_POS = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_GRID_CELL_ROW_POS");
            _lv_style_const_prop_id_GRID_CELL_Y_ALIGN = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_GRID_CELL_Y_ALIGN");
            _lv_style_const_prop_id_GRID_CELL_ROW_SPAN = CppSharp.SymbolResolver.ResolveSymbol(image, "_lv_style_const_prop_id_GRID_CELL_ROW_SPAN");
            _lv_animimg_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_animimg_class");
            _lv_image_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_image_class");
            _lv_arc_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_arc_class");
            _lv_bar_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_bar_class");
            _lv_label_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_label_class");
            _lv_button_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_button_class");
            _lv_buttonmatrix_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_buttonmatrix_class");
            _lv_calendar_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_calendar_class");
            _lv_calendar_header_arrow_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_calendar_header_arrow_class");
            _lv_calendar_header_dropdown_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_calendar_header_dropdown_class");
            _lv_canvas_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_canvas_class");
            _lv_chart_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_chart_class");
            _lv_checkbox_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_checkbox_class");
            _lv_dropdown_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_dropdown_class");
            _lv_dropdownlist_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_dropdownlist_class");
            _lv_imagebutton_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_imagebutton_class");
            _lv_keyboard_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_keyboard_class");
            _lv_led_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_led_class");
            _lv_line_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_line_class");
            _lv_list_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_list_class");
            _lv_list_text_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_list_text_class");
            _lv_list_button_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_list_button_class");
            _lv_menu_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_menu_class");
            _lv_menu_page_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_menu_page_class");
            _lv_menu_cont_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_menu_cont_class");
            _lv_menu_section_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_menu_section_class");
            _lv_menu_separator_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_menu_separator_class");
            _lv_menu_sidebar_cont_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_menu_sidebar_cont_class");
            _lv_menu_main_cont_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_menu_main_cont_class");
            _lv_menu_sidebar_header_cont_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_menu_sidebar_header_cont_class");
            _lv_menu_main_header_cont_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_menu_main_header_cont_class");
            _lv_msgbox_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_msgbox_class");
            _lv_msgbox_header_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_msgbox_header_class");
            _lv_msgbox_content_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_msgbox_content_class");
            _lv_msgbox_footer_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_msgbox_footer_class");
            _lv_msgbox_header_button_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_msgbox_header_button_class");
            _lv_msgbox_footer_button_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_msgbox_footer_button_class");
            _lv_msgbox_backdrop_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_msgbox_backdrop_class");
            _lv_roller_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_roller_class");
            _lv_scale_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_scale_class");
            _lv_slider_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_slider_class");
            _lv_spangroup_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_spangroup_class");
            _lv_spinbox_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_spinbox_class");
            _lv_textarea_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_textarea_class");
            _lv_spinner_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_spinner_class");
            _lv_switch_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_switch_class");
            _lv_table_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_table_class");
            _lv_tabview_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_tabview_class");
            _lv_tileview_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_tileview_class");
            _lv_tileview_tile_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_tileview_tile_class");
            _lv_win_class = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_win_class");
            _lv_global = CppSharp.SymbolResolver.ResolveSymbol(image, "lv_global");
        }
    }
}

